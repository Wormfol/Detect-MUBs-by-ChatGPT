p192_3	1	_closePosition, _limitClose	Front-running	The smart contract lacks access control on gas price and does not prevent front-running attacks where an attacker can observe transactions in the mempool and quickly submit a similar transaction with a higher gas price.
p192_3	2	_closePosition	Reentrancy	The _closePosition function makes external calls to the modifyLongOi and modifyShortOi functions, which in turn make external calls to the pairsContract.modifyLongOi and pairsContract.modifyShortOi. This can potentially lead to reentrancy attacks.
p192_3	3	_setReferral	Missing access control	The _setReferral function lacks proper access control, allowing any address to call the function and potentially manipulate referral data.
p192_3	1	deposit	Missing input validation	The deposit function does not check if the _amount is greater than zero. This allows users to call the function with an _amount of zero, which might cause unexpected behavior.
p192_3	2	withdraw	Missing input validation	The withdraw function does not check if the _amount is greater than zero. This allows users to call the function with an _amount of zero, which might cause unexpected behavior.
p192_3	1	executeLimitOrder	Reentrancy Vulnerability	The `executeLimitOrder` function can be called by the minter, and there is no mutex or reentrancy guard to prevent reentrancy attacks. If the minter is malicious or compromised, they could potentially call this function multiple times before the state is updated.
p192_3	2	constructor	Missing Access Control	The constructor sets the `baseURI`, but there is no access control to restrict who can be the contract owner. An attacker could potentially take control of the contract ownership and manipulate the `baseURI`.
p192_3	1	claim()	Reentrancy	The function `claim()` allows for reentrancy attacks by calling an external contract before updating the state.
p192_3	2	claimDebt()	Reentrancy	The function `claimDebt()` allows for reentrancy attacks by calling an external contract before updating the state.
p192_3	3	release()	Reentrancy	The function `release()` allows for reentrancy attacks by calling an external contract before updating the state.
p192_3	1	claim()	Reentrancy	The claim() function contains a reentrancy vulnerability because it transfers tokens to the manager address before updating the bondPaid mapping. An attacker could exploit this by creating a malicious contract that calls back into the BondNFT contract before the transfer is complete, allowing them to claim multiple times.
p192_3	2	claimDebt()	Reentrancy	The claimDebt() function has a reentrancy vulnerability as it transfers tokens to the manager address before updating the userDebt mapping. A malicious contract could call back into the BondNFT contract before the transfer completes, allowing the attacker to claim multiple times.
p193_2	1	add	Reentrancy	The 'add' function allows users to deposit tokens and receive LP tokens. During the execution of this function, external calls are made to transfer tokens, which could potentially allow a reentrancy attack to occur.
p193_2	2	remove	Reentrancy	The 'remove' function allows users to remove liquidity by burning LP tokens and receiving tokens in return. External calls to transfer tokens are made during the execution of this function, which could potentially allow a reentrancy attack to occur.
p193_2	3	buy	Reentrancy	The 'buy' function allows users to swap base tokens for fractional tokens. External calls to transfer tokens are made during the execution of this function, which could potentially allow a reentrancy attack to occur.
p193_2	4	sell	Reentrancy	The 'sell' function allows users to swap fractional tokens for base tokens. External calls to transfer tokens are made during the execution of this function, which could potentially allow a reentrancy attack to occur.
p192_2	1	getVerifiedPrice	Front-running	The function getVerifiedPrice returns the price data after verifying the signature. However, the lack of a commit-reveal mechanism leaves the contract vulnerable to front-running attacks.
p192_2	2	_checkGas	Gas Price Manipulation	The function _checkGas checks if the transaction gas price is higher than the maxGasPrice. However, this can lead to gas price manipulation attacks, where an attacker could manipulate the gas price to block transactions.
p192_2	1	deposit, withdraw	Reentrancy	The deposit and withdraw functions interact with external contracts (token transfers) without ReentrancyGuard protection, which exposes the contract to reentrancy attacks.
p192_2	2	deposit, withdraw	Missing validation	The deposit and withdraw functions do not check for zero amount, which could lead to unnecessary token transfers and waste of gas.
p192_2	1	mint	Reentrancy	The 'mint' function is callable by a minter, who could potentially call the function again before the first call is completed, resulting in a reentrancy attack.
p192_2	2	executeLimitOrder	Reentrancy	The 'executeLimitOrder' function is callable by a minter, who could potentially call the function again before the first call is completed, resulting in a reentrancy attack.
p192_2	3	modifyMargin	Reentrancy	The 'modifyMargin' function is callable by a minter, who could potentially call the function again before the first call is completed, resulting in a reentrancy attack.
p192_2	4	addToPosition	Reentrancy	The 'addToPosition' function is callable by a minter, who could potentially call the function again before the first call is completed, resulting in a reentrancy attack.
p192_2	5	setAccInterest	Reentrancy	The 'setAccInterest' function is callable by a minter, who could potentially call the function again before the first call is completed, resulting in a reentrancy attack.
p192_2	6	reducePosition	Reentrancy	The 'reducePosition' function is callable by a minter, who could potentially call the function again before the first call is completed, resulting in a reentrancy attack.
p192_2	7	modifyTp	Reentrancy	The 'modifyTp' function is callable by a minter, who could potentially call the function again before the first call is completed, resulting in a reentrancy attack.
p192_2	8	modifySl	Reentrancy	The 'modifySl' function is callable by a minter, who could potentially call the function again before the first call is completed, resulting in a reentrancy attack.
p192_2	1	claim	Reentrancy	The `claim` function can be exploited through a reentrancy attack. It first updates the bondNFT state with `bondNFT.claim(_id, msg.sender);`, then transfers the tokens to the user with `IERC20(_tigAsset).transfer(msg.sender, _amount);`. An attacker could create a malicious ERC20 contract that calls the `claim` function again during the transfer, allowing them to withdraw more tokens than they should.
p192_2	2	claimDebt	Reentrancy	The `claimDebt` function is also vulnerable to a reentrancy attack. It first updates the bondNFT state with `bondNFT.claimDebt(msg.sender, _tigAsset);`, then transfers tokens with `IERC20(_tigAsset).transfer(msg.sender, amount);`. A malicious ERC20 contract could exploit this by calling the `claimDebt` function again during the transfer.
p192_2	1	claim	Reentrancy	The claim function has a reentrancy vulnerability due to the external call to IERC20(tigAsset).transfer(manager, amount) before updating the state.
p192_2	2	createLock	Integer Overflow	The calculation of shares in createLock function can cause an integer overflow if _amount and _period are large enough.
p143_3	1	currentPrice	Integer Overflow	The function 'currentPrice' converts the price from the Chainlink feed to a uint256 without checking for potential integer overflows. If the price is a large negative number, it could cause an integer overflow when casting to uint256.
p143_3	1	claimFor	Reentrancy	The 'claimFor' function is vulnerable to reentrancy attacks because it updates the unclaimed balance after calling an external contract (minting tokens). An attacker can exploit this vulnerability by recursively calling 'claimFor' to mint more tokens than they should be allowed to.
p143_3	null
p143_3	1	recordPaymentFrom	Reentrancy	This function is vulnerable to a reentrancy attack because it is marked as nonReentrant but calls an external contract (delegate) before state changes are made.
p143_3	2	recordRedemptionFor	Reentrancy	This function is vulnerable to a reentrancy attack because it is marked as nonReentrant but calls an external contract (delegate) before state changes are made.
p143_3	3	recordMigration	Reentrancy	This function is vulnerable to a reentrancy attack because it is marked as nonReentrant but doesn't implement any protection against reentrancy.
p191_2	1	winnerClaimNFT	Reentrancy	The winnerClaimNFT function allows the winner to retrieve their NFT, but it is vulnerable to a reentrancy attack since the transfer of the NFT happens after emitting the event.
p145_2	null
p145_2	1	_transfer	Reentrancy	The function _transfer in NameWrapper is called inside setRecord, and it emits an event 'TransferSingle' which can be used by an attacker to call back into the contract, leading to a reentrancy attack.
p145_2	2	registerAndWrapETH2LD	Front-running	The function registerAndWrapETH2LD allows a user to register a new domain and wrap it. However, since the function depends on external input, it can be subject to front-running attacks where an attacker can watch the transaction pool and submit a similar transaction with a higher gas price to register the domain before the original user.
p143_2	1	claimFor	Reentrancy	The `claimFor` function updates the unclaimed balances and then calls the `_token.mint()` function. If the mint function is maliciously implemented, it could cause reentrancy and result in an attacker claiming more tokens than they should.
p143_2	2	transferFrom	Reentrancy	The `transferFrom` function updates unclaimed balances of both the sender and recipient. A malicious recipient contract could cause reentrancy and result in an attacker transferring more tokens than they should.
p143_2	1	recordPaymentFrom	Reentrancy	The function 'recordPaymentFrom' can be exploited through reentrancy, since it is marked as nonReentrant but calls an external contract (`IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(_data)`), which can potentially call back into the same function, leading to unintended behavior and possible loss of funds.
p143_2	null
p143_2	1	currentPrice	Integer Overflow	In the currentPrice function, the uint256 conversion of a negative int256 price may lead to an incorrect value due to integer overflow.
p190_1	1	hook	Reentrancy	The 'hook' function transfers tokens to the treasury and calls the external '_tokenSender.send()' function before the state variables are updated. This behavior can expose the contract to reentrancy attacks.
p131_1	1	mint	Reentrancy	The mint function is marked as nonReentrant, but it calls the '_executeInflationRateUpdate()' function which in turn calls 'controller.inflationManager().checkpointAllGauges();'. If the called function 'checkpointAllGauges()' interacts with external contracts or calls back into the 'Minter' contract, it could lead to potential reentrancy attacks.
p123_3	1	_addReward	Reentrancy	The `_addReward` function is marked as `nonReentrant`, which is supposed to protect against reentrancy attacks. However, it calls the `IERC20.safeTransferFrom` function before updating the state, allowing for potential reentrancy attacks.
p115_3	1	executeOperation	Reentrancy	The `executeOperation` function is called as a callback from the Aave flash loan. This function executes one of the three operations (leverage, rebalance, empty) based on the input parameter. However, it is vulnerable to reentrancy attacks because it calls external contracts before the state has been properly updated.
p115_3	2	aggregatorSwap	Missing input validation	The `aggregatorSwap` function does not validate the input parameters. The function takes the `dexIndex` as an input, which is then used to retrieve the proxy and router addresses from the `_dexAP` address provider. If the `dexIndex` is incorrect or malicious, the function may interact with unintended contracts.
p125_1	1	_withdrawFromYieldPool	Reentrancy	The function performs external calls before updating the state, which can potentially allow reentrancy attacks.
p125_1	2	processYield	Front-running	The function uses a hardcoded slippage value of 200, which can be exploited by front-runners to profit from the trade.
p125_1	1	withdrawCollateral	Reentrancy	The withdrawCollateral function calls an external contract (ILendingPool) without applying the Checks-Effects-Interactions pattern, which may lead to a reentrancy attack.
p125_1	2	depositCollateral	Reentrancy	The depositCollateral function calls an external contract (ILendingPool) without applying the Checks-Effects-Interactions pattern, which may lead to a reentrancy attack.
p125_1	3	_getYieldAmount	Integer Overflow	The _getYieldAmount function does not check for overflow when multiplying the values in the if statement. This may lead to incorrect results and potential vulnerabilities.
p123_1	1	_addReward	Reentrancy	The _addReward function is marked as nonReentrant, but the IERC20(_token).safeTransferFrom call can still potentially allow reentrancy attacks in some cases.
p123_1	2	_addReward	Integer Overflow	The calculation of rPerT could result in an integer overflow as it multiplies _amount by 1e20 before dividing by supply.
p122_1	1	withdraw	Reentrancy	The 'withdraw' function calls 'harvest' function which in turn makes an external call (payable(msg.sender).safeTransferETH(amount)) before updating the state (ethBalance[msg.sender] = 0). This can lead to reentrancy attack allowing the attacker to drain the contract balance.
p122_1	2	createVault	Unchecked return values	The function 'createVault' uses transferFrom without checking if the transfer was successful. This can lead to an incorrect transfer of tokens or the creation of a vault without the required assets.
p115_1	1	executeOperation	Reentrancy	The executeOperation function is susceptible to reentrancy attacks, because it allows external calls to arbitrary addresses with no reentrancy protection, which could lead to unexpected behavior and potential loss of assets.
p115_1	2	depositToVault	Missing input validation	depositToVault function does not have the 'onlyOwner' modifier, which allows any address to call the function and deposit tokens to the vault. This could lead to unauthorized deposits and unexpected behavior.
p115_1	3	leverageSwap	Unlimited token approvals	The leverageSwap function approves an unlimited amount of tokens to be spent by a.core() by using 2**256 - 1 as the approved amount. This can be risky if the contract is compromised, as an attacker could drain tokens.
p113_1	1	repay	Reentrancy	The `repay` function allows potential reentrancy by making external calls after updating the state but before transferring the assets. An attacker could exploit this vulnerability by creating a malicious contract that calls back into the `repay` function, causing a loss of assets.
p113_1	2	_lend	Reentrancy	The `_lend` function is vulnerable to reentrancy due to external calls made before updating the state or transferring assets. This allows an attacker to create a malicious contract that can call back into the `_lend` function, leading to asset loss.
p110_3	1	reportAdditionalToken	Reentrancy	The function transfers tokens to external addresses (treasury, strategist, and badgerTree), which can potentially be malicious contracts, making the function vulnerable to reentrancy attacks.
p110_3	2	reportHarvest	Reentrancy	The function transfers tokens to external addresses (treasury and strategist), which can potentially be malicious contracts, making the function vulnerable to reentrancy attacks.
p107_3	1	lockFor	Missing input validation	The function `lockFor` does not validate if `_lockAmount` is greater than 0, which can lead to locking 0 tokens, causing confusion and potential asset loss.
p107_3	2	lockFor	Overwriting existing lock position	The function `lockFor` does not check if a lock position already exists for the given `_nftIndex`. If an existing lock position is present, calling the `lockFor` function again will overwrite it, causing potential asset loss.
p112_1	null
p110_1	1	deposit, depositAll, depositFor	Reentrancy	The functions deposit, depositAll, and depositFor are marked as nonReentrant but they call the internal function _depositWithAuthorization which is not marked as nonReentrant. This can potentially lead to reentrancy attacks, as other external calls within the same transaction could exploit this vulnerability.
p109_1	1	_burnTokenFrom	Reentrancy	The function _burnTokenFrom has a reentrancy issue. The external call to _callERC20Token can allow the called contract to re-enter the AxelarGateway contract before the execution is completed.
p109_1	2	_mintToken	Reentrancy	The function _mintToken has a reentrancy issue. The external call to _callERC20Token can allow the called contract to re-enter the AxelarGateway contract before the execution is completed.
p109_1	3	_burnToken	Reentrancy	The function _burnToken has a reentrancy issue. The external call to depositHandler.execute can allow the called contract to re-enter the AxelarGateway contract before the execution is completed.
p109_1	1	swap	Reentrancy	The `swap` function is vulnerable to reentrancy attacks, as it first transfers tokens from the user to the contract and then transfers the converted amount to the recipient. An attacker can make a recursive call to the `swap` function in the middle of the token transfer, which can lead to asset loss.
p107_1	null
p103_3	1	swapTokensGeneric	Reentrancy	The `swapTokensGeneric` function transfers the asset to the user before emitting the event, which could lead to reentrancy attacks if the user's fallback function calls back into the contract.
p103_3	1	swap	Reentrancy	The `swap` function calls an external contract using low-level calls with `_swapData.callTo.call{ value: msg.value }(_swapData.callData)`. This can potentially lead to reentrancy attacks if the called contract's fallback function calls back into the `swap` function.
p104_1	1	withdraw	Reentrancy	The 'withdraw' function may be exposed to reentrancy attacks because it transfers the funds before updating the internal state.
p104_1	2	mintToken	Integer Overflow	The '_handlePayment(mintFee * amount)' calculation is susceptible to integer overflow, which may lead to incorrect payment amounts.
p103_1	1	swapTokensGeneric	Reentrancy	The function swapTokensGeneric is susceptible to reentrancy attacks because it transfers assets to the caller before emitting the LiFiTransferStarted event. An attacker could exploit this by recursively calling the swapTokensGeneric function in the fallback function of a malicious contract, leading to asset loss.
p103_1	1	swap	Reentrancy	The swap function is vulnerable to reentrancy attacks because it performs external calls (low-level calls) with the call method and transfers assets afterward. A malicious contract can exploit this by calling the swap function recursively within its own fallback function, potentially causing asset loss.
p102_3	1	getCurrentOraclePrice	Integer Overflow	The function calculates the current oracle price based on the change rate, but it lacks proper overflow checks, which might cause incorrect results.
p102_3	2	requestCPIData	Reentrancy	The function allows external users to request CPI data after a certain time period. However, it does not protect against reentrancy attacks, which could lead to undesirable behavior.
p102_1	1	requestCPIData	Reentrancy	The requestCPIData function is callable by anyone after the 14th day of the month and might be susceptible to reentrancy attacks if a malicious contract is called through the chainlink request.
p102_1	2	fulfill	Integer Overflow/Underflow	The function does not check for possible integer overflows or underflows when manipulating _cpiData.
p102_1	3	requestCPIData	Timestamp manipulation	The function relies on block.timestamp, which can be manipulated by miners within a certain range.
p100_1	null
p96_3	1	mint	Reentrancy	The mint function is vulnerable to reentrancy attacks because it uses the Callback.mint() function before updating the state variables.
p96_3	2	lend	Reentrancy	The lend function is vulnerable to reentrancy attacks because it uses the Callback.lend() function before updating the state variables.
p96_3	3	borrow	Reentrancy	The borrow function is vulnerable to reentrancy attacks because it uses the Callback.borrow() function before updating the state variables.
p96_3	4	pay	Reentrancy	The pay function is vulnerable to reentrancy attacks because it uses the Callback.pay() function before updating the state variables.
p94_3	1	_getCreatorPaymentInfo	Reentrancy	The function _getCreatorPaymentInfo makes external calls to other contracts (e.g., ITokenCreator, IRoyaltyInfo, IOwnable, etc.) which can potentially be malicious, and if these contracts call back into _getCreatorPaymentInfo, it may result in a reentrancy attack.
p94_3	null
p94_3	1	placeBidOf	Reentrancy	The function placeBidOf is vulnerable to reentrancy attacks because it sends funds back to the original bidder using the _sendValueWithFallbackWithdraw function before updating the state of the auction.
p98_1	null
p98_1	1	executeMetaTransaction	Reentrancy	This function allows external calls to other contracts via the `address(this).call()` function, which opens up the possibility of a reentrancy attack if the called contract contains a malicious function.
p97_1	1	withdraw	Reentrancy	The 'withdraw' function is marked as nonReentrant, but it calls the 'lpToken.safeTransferFrom' function after updating the state. This could potentially allow a malicious contract to call 'withdraw' again before the first call is completed, leading to unintended consequences.
p97_1	2	reclaimTokens	Reentrancy	The 'reclaimTokens' function is marked as nonReentrant, but it calls the 'IERC20Upgradeable(_token).safeTransfer' function after updating the state. This could potentially allow a malicious contract to call 'reclaimTokens' again before the first call is completed, leading to unintended consequences.
p97_1	1	depositNative()	Reentrancy	This function allows a user to deposit native tokens (ETH) into the smart contract. However, it is possible for an attacker to use a malicious contract to call this function repeatedly before the state is updated, draining the contract's balance.
p97_1	2	sendFundsToUser()	Reentrancy	This function is responsible for transferring the requested amount to the user. An attacker may call this function repeatedly before the state is updated, resulting in multiple token transfers to the attacker's address.
p96_1	1	pay	Reentrancy	The 'pay' function calls an external contract through the 'Callback.pay' function before updating the state, making it vulnerable to a reentrancy attack.
p94_1	1	_getCreatorPaymentInfo	Reentrancy	The _getCreatorPaymentInfo function calls external contracts (nftContract) multiple times with low-level calls using the try-catch mechanism. This may lead to reentrancy attacks if the called contract is malicious.
p94_1	1	_distributeFunds	Reentrancy	The `_distributeFunds` function has a reentrancy vulnerability due to the usage of `_sendValueWithFallbackWithdraw` which can be exploited by a malicious recipient contract to re-enter and manipulate state variables.
p94_1	2	_distributeFunds	Integer Overflow	The function `_distributeFunds` has an unchecked addition `totalShares += creatorShares[i]`, which can lead to an integer overflow if `creatorShares[i]` is an extremely large value.
p94_1	1	placeBidOf	Reentrancy	The `placeBidOf` function is vulnerable to a reentrancy attack because it sends value to the original bidder before updating the state, allowing the original bidder to call the function again and potentially drain the contract's balance.
p19_3	1	fulfill	Reentrancy	The `fulfill` function is susceptible to reentrancy attacks as it calls external contracts before updating the state, which could result in multiple calls to `fulfill` before the state is updated, potentially leading to asset loss.
p19_3	2	prepare	Front-running	The `prepare` function is susceptible to front-running attacks. An attacker can observe a transaction broadcast to the network, and create a transaction with a higher gas price, causing their transaction to be mined first, which may result in asset loss or other undesirable outcomes.
p17_3	0	N/A	None	There are no high-risk bugs in the provided Solidity smart contract that would cause asset loss.
p17_3	1	burnGToken	Reentrancy	The function burnGToken can be exploited by a malicious contract if a reentrancy attack is performed. The external call to `IPnL(pnl).decreaseGTokenLastAmount(pwrd, amount, bonus);` could lead to the function being called again before the state is updated, causing potential asset loss.
p17_3	2	mintGToken	Reentrancy	The function mintGToken is also vulnerable to reentrancy attacks. The external call to `IPnL(pnl).increaseGTokenLastAmount(pwrd, amount);` could lead to the function being called again before the state is updated, causing potential asset loss.
p19_2	null
p17_2	null
p17_2	1	burnGToken	Reentrancy Vulnerability	The burnGToken function allows external callers (withdrawHandler, emergencyHandler) to burn gTokens. However, the IPnL(pnl).decreaseGTokenLastAmount call that follows the burn is susceptible to reentrancy attacks, since it might interact with an untrusted contract.
p17_2	2	mintGToken	Reentrancy Vulnerability	The mintGToken function allows external callers (depositHandler) to mint gTokens. However, the IPnL(pnl).increaseGTokenLastAmount call that follows the mint is susceptible to reentrancy attacks, since it might interact with an untrusted contract.
p16_3	1	applyTrade	Integer Overflow	When calculating the quoteChange, there is a possibility of integer overflow, which can cause incorrect position updates, resulting in asset loss.
p16_3	2	applyTrade	Unchecked Underflow	The arithmetic operations for newQuote and newBase in the applyTrade function can result in underflows, leading to incorrect position updates and asset loss.
p16_3	1	updatePrice	Integer Overflow	In the updatePrice function, the cumulativePrice of hourlyTracerPrices and hourlyOraclePrices are not checked for integer overflow while performing addition. If cumulativePrice becomes very large, it can cause an integer overflow and incorrect calculations.
p16_3	2	recordTrade	Reentrancy	The recordTrade function calls an external contract (oracle.latestAnswer()) before updating the state variables, which can potentially lead to reentrancy attacks if the external contract is malicious.
p16_3	null
p16_3	1	deposit	Reentrancy	The 'deposit' function allows for potential reentrancy attacks because it updates the user's balance before performing the token transfer. An attacker could exploit this by calling 'deposit' within their malicious contract's fallback function, repeatedly calling 'deposit' and draining the contract.
p16_3	2	withdraw	Reentrancy	The 'withdraw' function is also vulnerable to reentrancy attacks as it updates the user's balance before performing the token transfer. An attacker could exploit this in the same way as the 'deposit' function by repeatedly calling 'withdraw' and draining the contract.
p16_3	1	claimReceipt	Reentrancy	The `claimReceipt` function allows a reentrancy attack because it updates the contract state (specifically `liquidatorRefundClaimed` and `escrowClaimed`) after external contract calls (`tracer.updateAccountsOnClaim`). An attacker can potentially call the function again before the state is updated, causing incorrect behavior or allowing them to claim more than they should.
p16_3	2	liquidate	Front-running	The `liquidate` function relies on the `pricing.fairPrice()` function which can be front-run by an attacker to manipulate the fair price and potentially cause an incorrect liquidation. The attacker can observe the transaction in the mempool and place a higher gas price transaction to manipulate the fair price before the `liquidate` function is executed.
p19_1	1	fulfill	Reentrancy	The `fulfill` function contains external calls (e.g., `IFulfillHelper(txData.callTo).addFunds`, `IFulfillHelper(txData.callTo).execute`) that could make the contract vulnerable to reentrancy attacks if the callee contract is malicious.
p19_1	null
p19_1	null
p19_1	null
p17_1	1	distributeStrategyGainLoss	Reentrancy	The function `distributeStrategyGainLoss` calls an external contract `IPnL(pnl).distributeStrategyGainLoss(gainUsd, lossUsd, reward)` without considering possible reentrancy attacks. This can lead to potential asset loss if the external contract is compromised or malicious.
p17_1	2	realizePriceChange	Unsafe External Calls	The function `realizePriceChange` calls an external contract `ibuoy.updateRatiosWithTolerance(tolerance)` without considering possible malicious behavior in the external contract, which can lead to unpredictable behavior or a potential asset loss.
p17_1	1	safetyCheck	Reentrancy	The safetyCheck function has an external call to curvePool.get_dy within a loop which can make it vulnerable to reentrancy attacks.
p17_1	2	_stableToUsd	Integer Overflow	The multiplication of tokenAmounts[i] and lpAmount in _stableToUsd function can lead to integer overflow.
p16_2	1	recordTrade	Reentrancy	The recordTrade function calls external contract functions (oracle.latestAnswer() and insurance.getPoolFundingRate()), which can be potentially malicious and cause reentrancy attacks.
p16_2	2	updatePrice	Integer Overflow	The updatePrice function has potential integer overflow when updating the cumulativePrice and trades values in the hourlyTracerPrices and hourlyOraclePrices arrays.
p16_2	1	applyTrade	Integer Overflow	In the applyTrade function, the calculation of quoteChange does not check for potential integer overflow issues, which could lead to incorrect position updates and potential asset loss.
p16_2	2	getFee	Incorrect Fee Calculation	The getFee function calculates the fee using the executionPrice, which can lead to incorrect fee calculations if the token decimals are not considered.
p16_2	1	latestAnswer	Potential Price Manipulation	The latestAnswer function relies on external Chainlink Oracles for gas and ETH prices, which can be manipulated by attackers through oracle attacks, leading to an incorrect USD/Gas price calculation.
p16_2	1	claimReceipt	Reentrancy Vulnerability	The `claimReceipt` function updates the state variables before calling external contracts, which can lead to reentrancy attacks. An attacker can potentially call `claimReceipt` again before the execution of the first call is finished, leading to undesired behavior and asset loss.
p16_2	1	withdraw	Reentrancy	The 'withdraw' function updates the user's balance and the 'tvl' variable before transferring the tokens to the user. This can potentially lead to reentrancy attacks if the ERC20 token implementation is malicious.
p16_2	2	_updateTracerLeverage	Integer Overflow	The '_updateTracerLeverage' function updates 'leveragedNotionalValue' without checking for overflow. This can lead to incorrect calculations and potential exploits.
p16_1	1	withdraw	Reentrancy Vulnerability	The `withdraw` function does not use the Checks-Effects-Interactions pattern, which makes it vulnerable to reentrancy attacks. An attacker could use a malicious contract to call `withdraw` recursively and drain the contract's funds.
p16_1	2	deposit	Reentrancy Vulnerability	The `deposit` function is also vulnerable to reentrancy attacks since it calls an external contract (IERC20.transferFrom) before updating the state variables. A malicious contract could call `deposit` recursively and cause unexpected behavior.
p16_1	1	recordTrade	Reentrancy	The 'recordTrade' function calls external contracts (oracle and insurance), which can potentially be malicious and cause a reentrancy attack.
p16_1	2	updatePrice	Integer Overflow	In the 'updatePrice' function, the 'cumulativePrice' of both 'hourlyTracerPrices' and 'hourlyOraclePrices' is updated without checking for potential integer overflows.
p16_1	3	updateTimeValue	Integer Underflow	In the 'updateTimeValue' function, there is no check for integer underflows when calculating the time value using 'Prices.timeValue(avgPrice, oracleAvgPrice)'.
p16_1	4	recordTrade, updateFundingRate	Timestamp Manipulation	The 'recordTrade' and 'updateFundingRate' functions rely on 'block.timestamp' for time-based calculations. Miners can manipulate the timestamp within certain limits, which could affect the contract's logic.
p16_1	1	wadToToken	Integer Overflow	In the division operation `wadAmount / scaler`, there is a possibility of an integer overflow when `scaler` equals 0, causing the division to fail and throw an error.
p16_1	1	claimReceipt	Reentrancy	The claimReceipt function updates the liquidatorRefundClaimed and escrowClaimed status of a receipt and then calls the tracer.updateAccountsOnClaim function, which might call external contracts, allowing for reentrancy attacks.
p16_1	1	toWad	Integer Overflow	In the 'toWad' function, the multiplication of 'raw' and 'scaler' could lead to an integer overflow if the values are large enough.
p16_1	2	setDecimals	Missing input validation	The 'setDecimals' function allows setting the number of decimals to any value without validation, which could lead to unintended consequences or vulnerabilities.
p14_3	1	redeemToken	Reentrancy	The redeemToken function is vulnerable to a reentrancy attack, as it first updates the user's balance and then transfers tokens to the user. An attacker could recursively call the redeemToken function and drain the contract of its assets.
p14_3	null
p12&13_3	1	CauldronMath.add	Integer Overflow	The add function is not protected against integer overflow, which could lead to an incorrect result and potential asset loss.
p12&13_3	2	mature	Missing Access Control	The mature function can be called by anyone which can lead to unauthorized users manipulating the contract state.
p12&13_3	3	pour	Reentrancy	The pour function updates the state (balances) after external calls which could lead to potential reentrancy attacks and asset loss.
p12&13_3	1	_pour	Reentrancy	The _pour function can potentially allow reentrancy attacks by calling external contracts (IJoin) before updating the state of the vault.
p12&13_3	1	deposit	Reentrancy	The 'deposit' function allows an attacker to re-enter the function before the user's deposit is updated, leading to potential loss of assets.
p12&13_3	2	withdrawDeposit	Reentrancy	The 'withdrawDeposit' function is susceptible to reentrancy attacks. An attacker could re-enter the function before the user's deposit is updated, leading to potential loss of assets.
p10_3	1	transferETH	Reentrancy	The `transferETH` function is vulnerable to reentrancy attacks because it is transferring ETH to an external address without any reentrancy guard in place.
p10_3	2	timeLockERC721	Missing input validation	The `timeLockERC721` function is missing input validation for the `nftContract` parameter, which could lead to unexpected behavior if an invalid address is passed.
p14_2	1	redeemToken	Reentrancy	The `redeemToken` function is vulnerable to reentrancy attack as it updates the user's balance after transferring tokens to the user. An attacker can call this function repeatedly in a loop and withdraw more tokens than they should.
p14_2	null
p13_2	1	deposit	Reentrancy	The 'deposit' function updates the user's deposit before calling 'orderbook.removeOldBids(_user)'. If the removeOldBids function contains external calls, it could potentially call back into the deposit function, leading to reentrancy.
p13_2	2	withdrawDeposit	Reentrancy	The 'withdrawDeposit' function updates the user's deposit before calling the external contract 'IRCBridge bridge'. This could potentially call back into the withdrawDeposit function, leading to reentrancy.
p13_2	3	sponsor	Reentrancy	The 'sponsor' function updates the marketPot and totalMarketPots before calling 'erc20.transferFrom(_sponsor, address(this), _amount)'. This could potentially call back into the sponsor function, leading to reentrancy.
p13_2	4	payout	Reentrancy	The 'payout' function updates the user's deposit, marketPot, and totalMarketPots before calling 'emit LogAdjustDeposit(_user, _amount, true)'. This could potentially call back into the payout function, leading to reentrancy.
P12_2	1	pour	Reentrancy	The `pour` function updates the vault's balances and then checks if the vault is undercollateralized. This can be exploited if a malicious user calls the function again before the first call is completed, leading to an inconsistent state.
P12_2	2	add	Integer Overflow/Underflow	The `add` function in the `CauldronMath` library can cause integer overflow or underflow, as it does not validate the result of addition or subtraction.
P12_2	1	batch	Reentrancy	The `batch` function, when used with a combination of specific operations, might be vulnerable to a reentrancy attack. An attacker can call back into the `batch` function before the state is updated, possibly leading to asset loss.
P10_2	1	rageQuit	Reentrancy Vulnerability	The `rageQuit` function allows the owner to call `IRageQuit(delegate).rageQuit{gas: RAGEQUIT_GAS}()` which can potentially call back into the Visor contract, allowing malicious contracts to manipulate the state.
P14_1	1	redeemToken	Reentrancy	The function `redeemToken` is vulnerable to reentrancy attacks since the external call to `badger.transfer` is made after updating the user balance but before the function ends.
P14_1	null
P13_1	1	withdrawDeposit	Reentrancy	The function withdrawDeposit() allows external calls to the bridge.withdrawToMainnet() function before updating the user's deposit and totalDeposits, making it vulnerable to reentrancy attacks.
P13_1	2	rentOwedBetweenTimestmaps	Integer Overflow and Underflow	In the rentOwedBetweenTimestmaps() function, the difference between _time1 and _time2 is calculated without checking for underflow, which could lead to incorrect rent calculations.
P12_1	1	CauldronMath.add	Integer Overflow	The 'add' function in CauldronMath library doesn't check for potential integer overflows, which can result in incorrect calculations.
P12_1	2	pour	Reentrancy	The 'pour' function modifies the state after performing external calls, making it vulnerable to reentrancy attacks.
P12_1	3	stir	Reentrancy	The 'stir' function modifies the state after performing external calls, making it vulnerable to reentrancy attacks.
P12_1	4	grab	Reentrancy	The 'grab' function modifies the state after performing external calls, making it vulnerable to reentrancy attacks.
P12_1	5	slurp	Reentrancy	The 'slurp' function modifies the state after performing external calls, making it vulnerable to reentrancy attacks.
P12_1	6	roll	Reentrancy	The 'roll' function modifies the state after performing external calls, making it vulnerable to reentrancy attacks.
P12_1	1	_serve	Reentrancy	The _serve function calls an external contract (pool.buyBase) after updating the state (cauldron.pour), but before transferring tokens. This could lead to reentrancy, where an attacker recursively calls the _serve function before the previous call is complete.
P12_1	2	batch	Missing input validation	The batch function accepts an array of operations and data, but does not validate the input lengths. An attacker could provide a malicious input causing unexpected behavior or out-of-gas errors.
p10_1	1	rageQuit	Reentrancy vulnerability	The `rageQuit` function may allow a reentrancy attack, as it calls an external contract (IRageQuit(delegate).rageQuit{gas: RAGEQUIT_GAS}()) before deleting the lock.
p10_1	2	transferERC721	No proper checks on NFT transfers	The `transferERC721` function allows any user to transfer an NFT without proper checks or authorization, as long as the NFT approval is set.
p10_1	3	getNftById	Unchecked array access	The `getNftById` function does not check if the provided index is within bounds of the `nfts` array, potentially causing an out-of-bounds access.
p8_3	1	swapTo	Reentrancy	The swapTo function is vulnerable to reentrancy attacks, as it does not use the ReentrancyGuard modifiers. An attacker could exploit this by calling the swapTo function recursively, potentially causing asset loss.
p8_3	2	setEligibilityStorage	Missing validation	The setEligibilityStorage function allows setting the eligibility storage address to any arbitrary address without proper validation, potentially leading to asset loss or manipulation of the vault contract.
p8_3	1	deposit	Reentrancy	The `deposit` function calls an external contract (`IERC20Upgradeable(pool.stakingToken).transferFrom`) before updating the state of the contract by minting new tokens. This could expose the contract to reentrancy attacks.
p8_3	2	deposit	Lack of input validation	The `deposit` function does not validate the `amount` parameter, which could lead to users depositing 0 tokens while still minting new reward distribution tokens.
p5_3	1	decreaseAllowance	Integer Underflow	When subtracting 'subtractedValue' from '_allowances[msg.sender][spender]', there is no check to ensure the result is not negative. This can cause an integer underflow, leading to an unexpectedly high allowance.
p5_3	2	addExcluded	Missing Access Control	The addExcluded function allows anyone to add an address to the excluded list, which can result in misuse of the fee exemption feature.
p5_3	3	_transfer	Integer Overflow	The check '_balances[_to] + _value >= _balances[_to]' is insufficient to prevent integer overflow as it does not account for the fee. This could result in a loss of assets for the recipient.
p5_3	1	withdraw	Reentrancy	The 'withdraw' function allows the user to withdraw funds before the balances are updated, which can lead to a reentrancy attack.
p5_3	2	addExcluded	Lack of access control	The 'addExcluded' function is publicly accessible, which can lead to unauthorized access control changes.
p5_3	1	redeemToMember	reentrancy	The redeemToMember function allows for reentrancy attacks by calling external contracts (iROUTER) before updating the state.
p5_3	2	transferTo	unprotected function	The transferTo function is vulnerable to phishing attacks since it uses tx.origin, which could be manipulated by an attacker.
p5_3	3	_transfer	integer underflow	The _transfer function may result in integer underflows due to unchecked subtraction operations on the _balances mapping.
p5_3	1	getCollateralValueInBase	Reentrancy	The function calls an external contract (iSYNTH) which could potentially call back into the current contract leading to a reentrancy attack.
p5_3	2	getDebtValueInCollateral	Reentrancy	The function calls an external contract (iROUTER) which could potentially call back into the current contract leading to a reentrancy attack.
p5_3	3	getInterestOwed	Reentrancy	The function calls an external contract (iFACTORY) which could potentially call back into the current contract leading to a reentrancy attack.
p5_3	1	addLiquidity	Reentrancy	The addLiquidity function allows external contracts to be called before updating the internal state, which might lead to reentrancy attacks.
p5_3	2	_removeLiquidity	Reentrancy	The _removeLiquidity function allows external contracts to be called before updating the internal state, which might lead to reentrancy attacks.
p5_3	3	swap	Reentrancy	The swap function allows external contracts to be called before updating the internal state, which might lead to reentrancy attacks.
p5_3	4	mintSynth	Reentrancy	The mintSynth function allows external contracts to be called before updating the internal state, which might lead to reentrancy attacks.
p5_3	5	burnSynth	Reentrancy	The burnSynth function allows external contracts to be called before updating the internal state, which might lead to reentrancy attacks.
p5_3	1	mintSynth	Reentrancy	The `mintSynth` function calls an external contract, `Synth(synth).mint(member, amount);`, before properly finalizing its own state changes. This opens up the possibility for a reentrancy attack, where the external call is used to call back into the `mintSynth` function and manipulate its behavior.
p5_3	1	finaliseProposal	Missing access control	The `finaliseProposal` function can be called by anyone, which allows an attacker to finalize a proposal before the intended participants have the chance to vote. This could lead to undesired outcomes or manipulation of the voting process.
p5_3	2	newAddressProposal	No validation of user input	The `newAddressProposal` function allows creating a proposal with an empty or arbitrary string as the `typeStr` parameter. This could lead to confusion in understanding the proposal's purpose or potential misuse.
p3_3	1	getPriceFromAMM	Front-running	The function getPriceFromAMM updates the price of a token based on the output received from the AMM. However, this leaves the smart contract vulnerable to front-running attacks, where an attacker can manipulate the price of the token by placing a transaction before the getPriceFromAMM function is executed.
p3_3	2	liquidateToPeg and liquidateFromPeg	Reentrancy	Both the liquidateToPeg and liquidateFromPeg functions call the external contract MarginRouter's authorizedSwapExactT4T and authorizedSwapT4ExactT functions, which may potentially be manipulated to call back into these functions and result in reentrancy attacks.
p3_3	1	crossDeposit, crossDepositETH	Reentrancy	In both crossDeposit and crossDepositETH functions, external calls to Fund and Lending contracts are made before the events are emitted. An attacker can create a malicious contract to exploit this and cause a reentrancy attack.
p3_3	2	crossWithdraw, crossWithdrawETH	Reentrancy	In both crossWithdraw and crossWithdrawETH functions, an external call to Fund contract is made before the event is emitted. An attacker can create a malicious contract to exploit this and cause a reentrancy attack.
p3_3	3	crossBorrow	Reentrancy	In the crossBorrow function, external calls to Lending and IMarginTrading contracts are made before the event is emitted. An attacker can create a malicious contract to exploit this and cause a reentrancy attack.
p3_3	4	crossOvercollateralizedBorrow	Reentrancy	In the crossOvercollateralizedBorrow function, external calls to Fund and Lending contracts are made before the event is emitted. An attacker can create a malicious contract to exploit this and cause a reentrancy attack.
p3_3	5	crossCloseAccount	Reentrancy	In the crossCloseAccount function, an external call to Fund contract is made inside a loop. An attacker can create a malicious contract to exploit this and cause a reentrancy attack.
p3_3	1	withdrawHourlyBond	Reentrancy	The function withdrawHourlyBond calls an external function, disburse, before updating the state, which makes it vulnerable to reentrancy attacks.
p3_3	2	closeHourlyBondAccount	Reentrancy	The function closeHourlyBondAccount calls an external function, disburse, before updating the state, making it vulnerable to reentrancy attacks.
p3_3	3	withdrawBond	Reentrancy	The function withdrawBond calls an external function, disburse, before updating the state, making it vulnerable to reentrancy attacks.
p3_3	1	liquidate	Reentrancy	The liquidate function calls an external contract (Fund(fund()).withdraw) before updating the state of the smart contract. This can lead to reentrancy attacks where an attacker can manipulate the state of the contract during execution.
p3_3	2	liquidate	Integer Overflow	In the liquidate function, the variable 'liquidationTarget' is multiplied by '(100 + MAINTAINER_CUT_PERCENT) / 100', which can lead to an integer overflow if MAINTAINER_CUT_PERCENT is too large.
p3_3	3	disburseLiqStakeAttacks	Unbounded Loop	The function disburseLiqStakeAttacks has a loop that iterates over the input array 'liquidatedAccounts'. If this array is very large, it can cause the function to exceed the block gas limit and become uncallable.
p3_3	1	borrow	Reentrancy	The `borrow` function calls the `updateLoan` function, which further interacts with external contracts, allowing for a reentrancy attack.
p3_3	2	extinguishDebt	Arithmetic underflow	The `account.borrowed -= extinguishAmount;` operation could potentially result in an arithmetic underflow if `extinguishAmount` is greater than `account.borrowed`.
p3_3	3	belowMaintenanceThreshold	Arithmetic overflow	The multiplication `100 * holdings` and `liquidationThresholdPercent * loan` can result in an arithmetic overflow.
p3_3	1	calcCumulativeYieldFP	Arithmetic overflow	The multiplication operations in `calcCumulativeYieldFP` function, such as `yieldAccumulator.accumulatorFP * yieldAccumulator.hourlyYieldFP * secondsDelta`, can result in an arithmetic overflow.
p3_3	2	_withdrawHourlyBond	Arithmetic underflow	The operation `bond.amount -= amount` could potentially result in an arithmetic underflow if `amount` is greater than `bond.amount`.
p3_3	3	_withdrawHourlyBond	Reentrancy	The `_withdrawHourlyBond` function updates the state after external calls, which could potentially allow for reentrancy attacks.
p3_3	1	registerDeposit	Reentrancy	When depositing and extinguishing debt, the totalShort balance is updated after calling the extinguishDebt() function, which is susceptible to reentrancy attacks.
p3_3	2	registerLiquidation	Missing function access control	The function registerLiquidation can be called by any address with the marginTrader role, allowing unauthorized liquidations.
p3_3	3	registerTradeAndBorrow	Incorrect calculation of totalLong and totalShort	totalLong and totalShort are not updated correctly, as they should be updated after borrow() and adjustAmounts() function calls.
p3_3	1	liquidate	Reentrancy	In the liquidate() function, there is a call to Fund(fund()).withdraw(), which transfers funds to the user. However, there is no reentrancy guard to prevent the user from calling the function again before the previous call is completed, potentially leading to asset loss.
p3_3	1	borrow	Reentrancy	The 'borrow' function allows external contracts to call it, which might lead to reentrancy attacks. Attackers can exploit this vulnerability to manipulate the contract state and drain the assets.
p3_3	2	borrow	Missing function access control	The 'borrow' function is internal, but it should be restricted to only the margin trader role, as stated in the contract goal. This might lead to unauthorized access to the function.
p3_3	1	updatedYieldFP	Reentrancy	The updatedYieldFP function uses the block.timestamp (alias for now), which can be manipulated by miners to some extent. This can be exploited by an attacker to cause reentrancy issues.
p3_3	2	updateSpeed	Integer Overflow	The updateSpeed function is prone to integer overflow when calculating 'updateAmount', as it multiplies 'amount' and 'runtime' without checking for an overflow.
ERC20 Contract Roles	null
ERC20 Contract Roles	null
ERC20 Contract Roles	null
ERC20 Contract Roles	null
ERC20 Contract Roles	null
ERC20 Contract Roles	null
ERC20 Contract Roles	null
ERC20 Contract Roles	null
ERC20 Contract Roles	null
ERC20 Contract Roles	null
ERC20 Contract Roles	null
ERC20 Contract Roles	null
ERC20 Contract Roles	null
ERC20 Contract Roles	null
p8_2	1	swapTo	Reentrancy	The 'swapTo' function is vulnerable to reentrancy attack, because it allows external calls before updating the state (ERC20 token transfer).
p8_2	2	getRandomTokenIdFromFund	Front-running	The 'getRandomTokenIdFromFund' function uses a predictable random number generator which can be exploited by front-runners to predict the tokenId that will be redeemed.
p8_2	1	deposit	Reentrancy	The `deposit` function calls an external contract with the `transferFrom` function before minting tokens to the sender, which can lead to reentrancy attacks.
p8_2	2	exit	Reentrancy	The `exit` function calls `_claimRewards` and `_withdraw` functions which interact with external contracts before making necessary state changes, leading to potential reentrancy attacks.
p8_2	3	emergencyExitAndClaim	Reentrancy	The `emergencyExitAndClaim` function calls `_claimRewards` and `_withdraw` functions which interact with external contracts before making necessary state changes, leading to potential reentrancy attacks.
p8_2	4	withdraw	Reentrancy	The `withdraw` function interacts with external contracts before making necessary state changes, leading to potential reentrancy attacks.
p8_2	5	claimRewards	Reentrancy	The `claimRewards` function interacts with external contracts before making necessary state changes, leading to potential reentrancy attacks.
p5_2	1	decreaseAllowance	Arithmetic Underflow	The decreaseAllowance function does not check if subtractedValue is greater than the current allowance, which could lead to an underflow in the new allowance.
p5_2	2	_transfer	Arithmetic Overflow	The _transfer function checks for overflow in the recipient's balance using an incorrect condition, which may not prevent an overflow.
p5_2	1	withdraw	Reentrancy	The `withdraw` function sends funds to the user before updating the state, which could lead to a reentrancy attack.
p5_2	2	depositForMember	Economic Exploit	Users can manipulate the token price on DEX before depositing, leading to inflated weights and incorrect rewards distribution.
p5_2	3	harvest	Economic Exploit	Users can manipulate the token price on DEX before harvesting, leading to inflated rewards and incorrect rewards distribution.
p5_2	1	redeemToMember	Reentrancy	The redeemToMember function is vulnerable to reentrancy attacks, as it calls an external contract (iROUTER) before updating the state. An attacker can exploit this to repeatedly call the function and redeem more tokens than they should.
p5_2	2	_approve	Unchecked Underflow	The '_approve' function doesn't validate that the new allowance doesn't underflow. This may cause users to unintentionally set a very high allowance when trying to decrease it.
p5_2	3	_transfer	Unchecked Underflow	The '_transfer' function doesn't check for underflow when subtracting the 'amount' from the sender's balance. This may cause the sender's balance to underflow and become an extremely large value.
p5_2	4	burnFrom	Unchecked Underflow	The 'burnFrom' function doesn't check for underflow when decreasing the allowance. This may result in unintentionally setting a very high allowance value when trying to decrease it.
p5_2	1	assetChecks	Reentrancy	The function assetChecks is calling external contracts (iPOOLS and iSYNTH) that can be exploited using reentrancy attacks. An attacker can create a malicious contract that calls back into the assetChecks function leading to unexpected behavior.
p5_2	1	addLiquidity	Reentrancy	The function updates the internal state of the contract after performing external calls, which may lead to reentrancy attacks.
p5_2	2	swap	Front-running	The swap function is vulnerable to front-running attacks as an attacker could observe a pending transaction and submit their own transaction with a higher gas price to influence the outcome.
p5_2	3	_removeLiquidity	Missing Input Validation	The function does not validate if the provided basisPoints value is within a valid range (0-10000). This could lead to unexpected results.
p5_2	1	mintSynth	Reentrancy	The 'mintSynth' function calls an external contract (Synth) without following the Checks-Effects-Interactions pattern, which may lead to reentrancy attacks.
p5_2	1	voteProposal	Reentrancy	The 'voteProposal' function calls '_finalise' which emits an event before updating the state. This may lead to reentrancy attacks.
p3_2	1	liquidateToPeg	Reentrancy	The function calls an external contract (MarginRouter) before adjusting the state, which may lead to reentrancy attacks if malicious contracts are involved.
p3_2	2	liquidateFromPeg	Reentrancy	The function calls an external contract (MarginRouter) before adjusting the state, which may lead to reentrancy attacks if malicious contracts are involved.
p3_2	1	crossDeposit	Reentrancy	The crossDeposit function calls an external contract (Fund) before updating the state, making it vulnerable to reentrancy attacks.
p3_2	2	crossDepositETH	Reentrancy	The crossDepositETH function calls an external contract (Fund) before updating the state, making it vulnerable to reentrancy attacks.
p3_2	3	crossWithdraw	Reentrancy	The crossWithdraw function calls an external contract (Fund) before updating the state, making it vulnerable to reentrancy attacks.
p3_2	4	crossWithdrawETH	Reentrancy	The crossWithdrawETH function calls an external contract (Fund) before updating the state, making it vulnerable to reentrancy attacks.
p3_2	5	crossBorrow	Reentrancy	The crossBorrow function calls an external contract (Lending) before updating the state, making it vulnerable to reentrancy attacks.
p3_2	6	crossOvercollateralizedBorrow	Reentrancy	The crossOvercollateralizedBorrow function calls external contracts (Fund and Lending) before updating the state, making it vulnerable to reentrancy attacks.
p3_2	7	crossCloseAccount	Reentrancy	The crossCloseAccount function calls an external contract (Fund) before updating the state, making it vulnerable to reentrancy attacks.
p3_2	1	withdrawHourlyBond	Reentrancy	The withdrawHourlyBond function is susceptible to reentrancy attacks because it calls the disburse() function, which interacts with an external contract, before updating the user's balance.
p3_2	2	closeHourlyBondAccount	Reentrancy	The closeHourlyBondAccount function is susceptible to reentrancy attacks because it calls the disburse() function, which interacts with an external contract, before updating the user's bond account.
p3_2	3	withdrawBond	Reentrancy	The withdrawBond function is susceptible to reentrancy attacks because it calls the disburse() function, which interacts with an external contract, before deleting the user's bond.
p3_2	1	liquidate	Reentrancy	The liquidate function calls external contracts (such as Fund and Admin) that can be manipulated by an attacker to re-enter the liquidate function and potentially cause asset loss.
p3_2	2	calcLiquidationAmounts	Integer Overflow	When calculating sellAmount and buyTarget, the values are added to the existing amounts, which may lead to integer overflow if the values are large enough.
p3_2	3	liquidate	Insecure Liquidation Target Calculation	The calculation of the liquidationTarget is imprecise, which may lead to an incorrect target, and the contract may not be able to cover the shortfall or distribute the correct amounts to stakeholders.
p3_2	1	extinguishDebt	Unchecked Underflow	In the function 'extinguishDebt', the subtraction of 'extinguishAmount' from 'account.borrowed' might cause an underflow if 'extinguishAmount' is greater than 'account.borrowed'.
p3_2	2	setLeveragePercent	Missing Input Validation	There is no function to set 'leveragePercent', which could lead to incorrect calculations if an invalid value is used.
p3_2	1	_withdrawHourlyBond	Unchecked Underflow	In the function '_withdrawHourlyBond', the subtraction of 'amount' from 'bond.amount' might cause an underflow if 'amount' is greater than 'bond.amount'.
p3_2	2	setWithdrawalWindow	Missing Input Validation	The 'setWithdrawalWindow' function does not validate the input value for the 'window' parameter, which might lead to incorrect withdrawal windows.
p3_2	1	registerWithdrawal	Reentrancy	The function registerWithdrawal allows external calls to msg.sender before updating the state, making the contract vulnerable to reentrancy attacks.
p3_2	2	_registerBorrow	Integer Overflow	The function _registerBorrow updates totalShort and totalLong without checking for integer overflow, making the contract vulnerable to integer overflow attacks.
p3_2	3	_registerWithdrawal	Integer Underflow	The function _registerWithdrawal subtracts withdrawAmount from totalLong[withdrawToken] without checking for integer underflow, making the contract vulnerable to integer underflow attacks.
p3_2	1	borrow()	Reentrancy	The 'borrow()' function interacts with the external contract Lending before modifying the storage, which can lead to reentrancy attacks.
p3_2	2	deleteAccount()	Missing access control	The 'deleteAccount()' function is not restricted to any specific role, which could allow unauthorized users to delete accounts.
p3_2	3	adjustAmounts()	Missing access control	The 'adjustAmounts()' function is not restricted to any specific role, which could allow unauthorized users to modify account holdings.
p3_2	1	liquidate	Reentrancy	The `liquidate` function can be exploited using a reentrancy attack. The attacker may use a malicious contract to withdraw funds from the `Fund` contract during the execution of the `liquidate` function, potentially causing asset loss.
p3_2	2	liquidate	Integer Overflow	In the `liquidate` function, an integer overflow may occur when calculating `peg2targetCost * (100 + MAINTAINER_CUT_PERCENT) / 100`. If the multiplication result is too large, it can wrap around and become a small number, leading to incorrect calculations and potential asset loss.
Smart Contract Bug Prompts	null
p8_1	1	mintTo	Reentrancy	The 'mintTo' function is marked as nonReentrant, but it doesn't protect against reentrancy attacks because the '_distributeFees' function can call an external contract, allowing the contract to be called again before the function is finished.
p8_1	2	redeemTo	Reentrancy	The 'redeemTo' function is marked as nonReentrant, but it doesn't protect against reentrancy attacks because the '_distributeFees' function can call an external contract, allowing the contract to be called again before the function is finished.
p8_1	3	swapTo	Reentrancy	The 'swapTo' function is marked as nonReentrant, but it doesn't protect against reentrancy attacks because the '_distributeFees' function can call an external contract, allowing the contract to be called again before the function is finished.
p8_1	1	receiveRewards	Reentrancy	The receiveRewards function calls rewardDistToken.distributeRewards() after transferring tokens to the rewardDistToken address. If the reward token is malicious and implements a callback function, it could potentially re-enter the receiveRewards function.
p8_1	2	deposit	Front-running	The deposit function is susceptible to front-running attacks since it updates the pool state after the user has sent their tokens. An attacker can observe the transaction in the mempool and submit their own deposit with a higher gas price to benefit from the user's deposit.
p8_1	3	deposit	Unchecked return value	The function deposit() does not check the return value of the transferFrom call. If the transferFrom call fails, the function will continue to mint reward tokens, which can lead to incorrect token balances.
p5_1	1	redeemToMember	Reentrancy	The redeemToMember function is vulnerable to reentrancy attacks because it first transfers the USDV tokens to the contract and then calls an external contract (iROUTER) before updating the contract state (minting VADER tokens).
p5_1	1	grantFunds	Reentrancy	The grantFunds function calls the external contract iVAULT(VAULT).grant() before finalizing the proposal, making it vulnerable to reentrancy attacks.
p5_1	1	assetChecks	Reentrancy	The assetChecks function calls external contracts (iPOOLS and iSYNTH), which may lead to reentrancy attacks by a malicious contract.
p5_1	1	transferOut	Reentrancy	The `transferOut` function transfers tokens to a recipient before updating the accounting variables `pooledVADER` and `pooledUSDV`. This can allow an attacker to exploit reentrancy vulnerability, potentially leading to loss of assets.
p5_1	1	depositForMember	Reentrancy	This function can be called recursively by a malicious contract because it receives funds before updating the state (mapMemberSynth_deposit), thus allowing an attacker to drain the contract's funds.
p5_1	2	_deposit	Integer Overflow	The '_deposit()' function does not check for integer overflow when adding '_weight' to 'totalWeight' and 'mapMember_weight[_member]'. An attacker might craft an input that causes an overflow, leading to incorrect calculations and potential asset loss.
p5_1	3	withdraw	Reentrancy	This function can be called recursively by a malicious contract because it sends funds before updating the state (mapMemberSynth_deposit), thus allowing an attacker to drain the contract's funds.
p5_1	1	init	Missing Access Control	The 'init' function can be called by anyone, allowing an attacker to re-initialize the contract, which may lead to loss of control over the contract.
p5_1	1	addExcluded	Missing Access Control	The 'addExcluded' function can be called by anyone, allowing an attacker to exclude any address from paying fees, which may lead to potential abuse and revenue loss.
p3_1	1	crossDeposit	Reentrancy	The crossDeposit function may allow reentrancy attacks due to calling external contracts before updating the state. This may lead to asset loss.
p3_1	2	crossDepositETH	Reentrancy	The crossDepositETH function may allow reentrancy attacks due to calling external contracts before updating the state. This may lead to asset loss.
p3_1	1	borrow	Reentrancy	The `borrow` function updates the loan and modifies the account state without implementing a reentrancy guard. This can potentially allow for a reentrancy attack leading to unintended behavior and potential asset loss.
p3_1	2	extinguishDebt	Underflow	The `extinguishDebt` function subtracts `extinguishAmount` from `account.borrowed` without checking for underflow. This can result in incorrect calculations and unintended behavior.
p3_1	1	addHolding	Missing access control	The addHolding function is marked as internal but it manipulates the state of CrossMarginAccounts without any access control. This could lead to unauthorized manipulation of the smart contract state if called by an external function that doesn't have proper access control.
p3_1	1	liquidateToPeg	Reentrancy	The function 'liquidateToPeg' calls 'MarginRouter(router()).authorizedSwapExactT4T', which is an external contract function call. This may lead to a reentrancy attack if a malicious contract is used.
p3_1	2	liquidateFromPeg	Reentrancy	The function 'liquidateFromPeg' calls 'MarginRouter(router()).authorizedSwapT4ExactT', which is an external contract function call. This may lead to a reentrancy attack if a malicious contract is used.
p3_1	1	withdrawHourlyBond	Reentrancy	The 'withdrawHourlyBond' function allows an attacker to call it recursively using reentrancy, potentially causing asset loss.
p3_1	2	closeHourlyBondAccount	Reentrancy	The 'closeHourlyBondAccount' function allows an attacker to call it recursively using reentrancy, potentially causing asset loss.
p3_1	1	_makeFallbackBond	Reentrancy	The _makeFallbackBond function is a virtual function that is meant to be overridden in derived contracts. If it includes any external calls, it could open up the contract to reentrancy attacks.
p3_1	1	calcCumulativeYieldFP	Integer Overflow/Underflow	In calcCumulativeYieldFP, when calculating the accumulatorFP, an integer overflow/underflow can occur when multiplying yieldAccumulator.accumulatorFP, yieldAccumulator.hourlyYieldFP, and secondsDelta.
p3_1	1	liquidate	Reentrancy	The 'liquidate' function allows an attacker to recursively call the function through the 'Fund(fund()).withdraw' calls, leading to potential asset loss.
p3_1	1	liquidate	Reentrancy	The `liquidate` function interacts with external contracts (Fund and Admin) after changing the state variables, which may allow a reentrancy attack.
p3_1	1	registerDeposit	Reentrancy	The 'registerDeposit' function can be exploited by a reentrancy attack due to the external call to the 'extinguishDebt' function before updating the 'totalShort' variable.
p92_3	1	boost	Reentrancy	The 'boost' function calls the 'vault.deposit' function after performing 'feiTurboCToken.borrow', which can potentially lead to reentrancy attacks if the called vault's deposit function is malicious or compromised.
p92_3	2	less	Reentrancy	The 'less' function calls 'vault.withdraw' after updating state variables, which can potentially lead to reentrancy attacks if the called vault's withdraw function is malicious or compromised.
p92_1	1	boost	Reentrancy	The 'boost' function is vulnerable to reentrancy attacks since it first makes an external call to 'vault.deposit' and updates the state variables later. An attacker can exploit this vulnerability by making a recursive call to the 'boost' function before the state is updated.
p92_1	2	less	Reentrancy	The 'less' function is vulnerable to reentrancy attacks since it first makes an external call to 'vault.withdraw' and updates the state variables later. An attacker can exploit this vulnerability by making a recursive call to the 'less' function before the state is updated.
p90_3	1	mint	Reentrancy	The mint function is called before updating the balance in the vToken.mint() loop. This allows for potential reentrancy attacks, where an attacker could repeatedly call the mint function before the state is updated.
p90_3	2	mint	Integer Overflow	The 'lastAssetBalanceInBase' variable can overflow when summing up the 'balanceInBase' values in the loop. This can lead to incorrect calculations and potential asset loss.
p90_3	3	burn	Missing input validation	The burn function lacks input validation for the '_recipient' parameter. This can lead to unintended behavior and potential asset loss if the recipient address is invalid (e.g., zero address).
p90_1	1	mint	Reentrancy	The 'mint' function allows for tokens to be minted before updating the balance of the underlying assets, which could enable reentrancy attacks.
p90_1	2	burn	Reentrancy	The 'burn' function can be vulnerable to reentrancy attacks as it performs external calls and token transfers before burning the index tokens.
p83_1	null
p83_1	1	deposit	Reentrancy	The deposit function is using the safeConcurTransfer function to send the pending rewards to the recipient. However, the function is not marked as nonReentrant, which makes it vulnerable to reentrancy attacks.
p83_1	2	deposit	Integer Overflow	The deposit function calculates the deposit fee using _amount.mul(pool.depositFeeBP).div(_perMille). However, there is no check to ensure that the depositFeeBP variable is within a reasonable range, which can lead to integer overflow.
p83_1	1	donate	Integer Overflow	In the donate function, the savedTokens mapping value is incremented by _amount directly, which can lead to integer overflow if _amount is large enough.
p83_1	2	withdraw	Missing input validation	The withdraw function does not check whether a user has already claimed their tokens, which allows a user to withdraw multiple times and drain the contract's balance.
p83_1	1	deposit	Integer Overflow/Underflow	The deposit function adds token amounts to total and user liquidity directly, which can lead to integer overflow if the amounts are large enough.
p83_1	2	withdraw	Integer Overflow/Underflow	The withdraw function subtracts token amounts from total and user liquidity directly, which can lead to integer underflow if the amounts are large enough.
p80_3	1	nonReentrant	Reentrancy	The nonReentrant modifier in the code is not using the standard OpenZeppelin ReentrancyGuard, leaving it vulnerable to reentrancy attacks. The variable _status can be manipulated, and the function using nonReentrant could be called multiple times before the state is reverted.
p80_3	2	setApprovals	Unprotected function	The setApprovals() function is publicly accessible, allowing anyone to call it and potentially manipulate approvals for the contract.
p80_3	1	wrap	Reentrancy	The wrap function allows external calls to other contracts (e.g., IRewardStaking(convexPool).stake(amount_);) after updating the state variables (_mint function) but before the emit statement. This exposes the contract to reentrancy attacks.
p80_3	2	unwrap	Reentrancy	The unwrap function allows external calls to other contracts (e.g., IRewardStaking(convexPool).withdraw(amount_, false);) after updating the state variables (_burn function) but before the emit statement. This exposes the contract to reentrancy attacks.
p81_1	1	claimCOMPAndTransfer	Reentrancy	The claimCOMPAndTransfer function is vulnerable to reentrancy attacks as the external call to COMPTROLLER.claimComp() is followed by the state-changing action of transferring COMP tokens. An attacker can exploit this vulnerability by causing the called contract to re-enter the claimCOMPAndTransfer function, possibly draining more COMP tokens than intended.
p81_1	2	setReserveBuffer	Missing input validation	The setReserveBuffer function does not validate the input value of bufferAmount, which could lead to unexpected behavior if the provided value is extremely large. This could affect the functionality of the contract.
p81_1	0	N/A	None	The provided Solidity smart contract does not contain any high-risk bugs that can cause asset loss.
p80_1	1	nonReentrant	Reentrancy	The nonReentrant modifier is vulnerable to reentrancy attacks as it sets the _status back to _NOT_ENTERED after executing the protected function.
p80_1	1	wrap	Reentrancy	The `wrap` function allows for reentrancy because it calls `_mint` and `IRewardStaking(convexPool).stake(amount_)` without employing proper reentrancy prevention mechanisms.
p80_1	2	unwrap	Reentrancy	The `unwrap` function allows for reentrancy as it calls `_burn`, `IRewardStaking(convexPool).withdraw(amount_, false)` and `IERC20(convexToken).safeTransfer(to_, amount_)` without employing proper reentrancy prevention mechanisms.
p79_3	null
p77_3	1	swapBaseTokenForQuoteToken, swapQuoteTokenForBaseToken	Front-running attack	These functions are vulnerable to front-running attacks where a malicious user can observe the pending transaction and submit their own transaction with a higher gas price to take advantage of price changes.
p77_3	2	swapBaseTokenForQuoteToken, swapQuoteTokenForBaseToken	Inaccurate price oracle	The price calculation inside these functions does not use an external price oracle. The internal price may deviate significantly from the market price, opening up opportunities for arbitrage and price manipulation.
p77_3	1	calculateLiquidityTokenQtyForDoubleAssetEntry	Integer Overflow and Underflow	The multiplication of `_quoteTokenQty` and `_totalSupplyOfLiquidityTokens` might result in an integer overflow. This could lead to incorrect calculation of `liquidityTokenQty` and unintended consequences.
p77_3	2	calculateAddLiquidityQuantities	Reentrancy	The function calls external contracts when updating the `_internalBalances` storage. This could potentially allow for reentrancy attacks, leading to unexpected changes in the contract's state.
p79_1	1	initialize	No input validation on initialize() function	The initialize() function can be called by any external address, potentially allowing an attacker to reinitialize the contract with malicious parameters.
p79_1	2	allowEmergencyWithdraw	No input validation on allowEmergencyWithdraw() function	The allowEmergencyWithdraw() function can be called by any external address, potentially allowing an attacker to stop the contract prematurely.
p78_1	1	purchasePyroFlan	Front-running	In the purchasePyroFlan function, a miner or any user with enough knowledge of the contract's state can execute a transaction to manipulate the price of Flan before the purchasePyroFlan is executed, leading to a less favorable exchange rate for the user.
p78_1	2	purchasePyroFlan	Reentrancy	The purchasePyroFlan function calls external contracts (FlanLike, PyroTokenLike, and UniPairLike) after updating the state and before transferring tokens to the user. This can lead to potential reentrancy attacks if these external contracts are compromised or malicious.
p78_1	3	purchasePyroFlan	Economic Incentive Misalignment	The purchasePyroFlan function calculates the premium based on the growth variable, which is the percentage of price change. However, this calculation can lead to a misaligned economic incentive, as users can potentially exploit the premium by making larger purchases, which could negatively affect the system's stability.
p78_1	1	setEnforcement	Missing Access Control	The setEnforcement function is missing access control, allowing any address to call it and potentially enable or disable enforcement in the FlashGovernanceArbiterLike contract, affecting the contract's functionality and security.
p78_1	1	transferAndCall	Double Transfer	In the transferAndCall function, the "super.transfer(_to, _value)" call already transfers the tokens. However, the following line "_transfer(msg.sender, _to, _value)" transfers the tokens again, causing a double transfer.
p78_1	1	withdrawGovernanceAsset	Reentrancy	The 'withdrawGovernanceAsset' function transfers the asset to the user before deleting the pending flash decision. This can potentially be exploited by a reentrancy attack.
p78_1	1	convertFateToFlan	Reentrancy	The convertFateToFlan function updates the user's fate balance before calling an external contract (Flan) with the mint function. This can lead to reentrancy attacks if the mint function is not carefully implemented.
p78_1	2	setEYEBasedAssetStake	Reentrancy	The setEYEBasedAssetStake function updates the user's fate balance and clout before calling an external contract with the ERC20NetTransfer function. This can lead to reentrancy attacks if the called function is not carefully implemented.
p78_1	3	burnAsset	Reentrancy	The burnAsset function updates the user's fate balance before calling external contracts with the transferFrom and burn functions. This can lead to reentrancy attacks if the called functions are not carefully implemented.
p77_1	1	swapBaseTokenForQuoteToken	Reentrancy Attack	The function swapBaseTokenForQuoteToken is vulnerable to a reentrancy attack because it performs an external call to transfer the quoteToken to the msg.sender before updating the internal balances. This can potentially be exploited by an attacker who can re-enter the function before the internal balances are updated, effectively draining the quoteToken balance.
p77_1	1	calculateAddLiquidityQuantities	Reentrancy	The calculateAddLiquidityQuantities function updates the _internalBalances storage, which may lead to a reentrancy attack if the function is called again before the previous execution is finished.
p74_2	1	receive()	Reentrancy	The receive() function accepts incoming ETH payments without any restrictions, which makes the contract vulnerable to reentrancy attacks.
p74_2	1	mint, burn, lend, withdraw, borrow, pay	Reentrancy	Functions use the lock modifier to prevent reentrancy, but the callback functions in each of these methods may allow external calls, which could introduce a reentrancy vulnerability.
p73_3	1	migrateDelegator, migrateUnbondingLocks, migrateSender	Front-Running Vulnerability	The functions `migrateDelegator`, `migrateUnbondingLocks`, and `migrateSender` can be vulnerable to front-running attacks. A malicious actor can monitor pending transactions and submit their own transaction with a higher gas price to execute before the original transaction. This can potentially cause a user's migration to be invalidated or delayed.
p73_2	1	migrateDelegator, migrateUnbondingLocks, migrateSender	Reentrancy	These functions do not use the reentrancy guard, and they make external calls with sendTxToL2(), which may lead to reentrancy attacks.
p70_3	1	claimAll	Reentrancy	The 'claimAll' function deletes the user's locks array before transferring the tokens, but it may allow for a reentrancy attack in the 'vader.transfer()' and '_transfer()' calls.
p70_3	2	mint	Overflow	The multiplication in the line 'uAmount = (vPrice * vAmount) / 1e18;' may result in an overflow when 'vPrice' and 'vAmount' are large values.
p70_3	3	burn	Overflow	The multiplication in the line 'vAmount = (uPrice * uAmount) / 1e18;' may result in an overflow when 'uPrice' and 'uAmount' are large values.
p70_3	1	reimburseImpermanentLoss	Front-running	The reimburseImpermanentLoss function calculates the amount of VADER to reimburse based on the current prices fetched from the LBT. This opens up the possibility of front-running attacks.
p70_3	2	grant	Reentrancy	The 'grant' function calls the external 'vader.safeTransfer()' function after emitting the 'GrantDistributed' event. This may expose the contract to reentrancy attacks.
p70_3	1	getVaderPrice, getUSDVPrice	Front-running vulnerability	The functions getVaderPrice and getUSDVPrice return updated prices for Vader and USDV, but since they are publicly accessible, an attacker can front-run transactions to manipulate the price.
p70_3	2	_updateVaderPrice, _updateUSDVPrice	Unchecked arithmetic	The functions _updateVaderPrice and _updateUSDVPrice use unchecked arithmetic, which can lead to integer overflows or underflows, causing incorrect price calculations.
p70_3	3	setupVader, setupUSDV, addVaderPair, addUSDVPair, _addVaderPair, _addUSDVPair	Missing input validation	Functions that initialize and add new pairs lack input validation, allowing zero addresses or improper configuration of pairs and oracles, leading to incorrect price calculations.
p70_3	1	propose	Reentrancy	The 'propose' function makes an external call to the xVader contract with 'transferFrom' before updating the state. This opens the contract up to a reentrancy attack, where an attacker could call 'propose' again before the state is updated.
p70_3	2	setTimelock	No proper access control	The 'setTimelock' function allows any address with the guardian role to change the timelock address. This could allow a malicious actor with the guardian role to change the timelock address, possibly compromising the governance process.
p70_3	1	mul	Integer Overflow and Underflow	The 'mul' function is not checking for potential underflows when the value of 'y' is 0, causing the returned result to be incorrect.
p70_3	2	muli	Integer Overflow	The 'muli' function does not handle the case where the result of the multiplication is the maximum negative value of an int256, which would cause an overflow when negated.
p70_3	1	burnSynth	Reentrancy	The 'burnSynth' function is marked as nonReentrant, which is supposed to prevent reentrancy attacks. However, it calls the 'synth.burn(synthAmount)' function before updating the reserves, potentially allowing for reentrancy if the 'synth.burn' function can call back into the contract.
p70_3	1	rescue	Reentrancy	The `rescue` function can be called by any user to withdraw unaccounted tokens from the contract. This can be exploited by an attacker to drain the contract's balance, leading to asset loss.
p70_3	2	_supportedToken	Unrestricted Access	The `_supportedToken` function uses the `require` statement to validate if a token is supported or not. However, this is not a modifier, and is not used to restrict access to any functions. This can lead to potential misuse of functions by unsupported tokens.
p70_3	1	calculateSlipAdjustment	Division by zero	In the calculateSlipAdjustment function, the 'denominator' can be zero if both vaderDeposited and vaderBalance are zero, or both assetDeposited and assetBalance are zero. This can lead to a division by zero error.
p70_3	2	calculateSwapReverse	Insufficient validation	In the calculateSwapReverse function, if the reserveOut equals exactly four times the amountOut, the subtraction (reserveOut - y4) will result in zero, which will cause the root function to return zero. This will lead to incorrect calculations.
p71_2	1	createMarket	Reentrancy	The function createMarket calls the external function market.initialize before emitting the event MarketCreated, which can potentially be exploited in a reentrancy attack.
p71_2	1	withdrawValue	Reentrancy	The function withdrawValue transfers tokens to the caller before updating the balance, which can lead to reentrancy attacks.
p71_2	2	repayDebt	Reentrancy	The function repayDebt updates the state variables after transferring tokens, which can lead to reentrancy attacks.
p71_2	3	_withdrawAttribution	Reentrancy	The function _withdrawAttribution transfers tokens to the caller before updating the balance, which can lead to reentrancy attacks.
p71_2	1	withdraw	Reentrancy	The 'withdraw' function calls an external contract (vault.withdrawValue) before updating the state, which can potentially allow reentrancy attacks.
p71_2	2	deposit	Integer Overflow	The 'deposit' function can cause an integer overflow while calculating '_mintAmount' when '_supply > 0 && _totalLiquidity == 0'.
p71_2	3	withdraw	Integer Underflow	In the 'withdraw' function, there is a potential integer underflow when updating 'withdrawalReq[msg.sender].amount' if '_amount' is greater than the current value.
p71_2	1	deposit	Reentrancy	The 'deposit' function calls an external contract, 'vault.addValue', before updating the internal state. This could allow a reentrancy attack, where an attacker could repeatedly call the 'deposit' function before the state is updated, resulting in a loss of funds.
p71_2	2	withdraw	Reentrancy	The 'withdraw' function calls an external contract, 'vault.withdrawValue', before updating the internal state. This could allow a reentrancy attack, where an attacker could repeatedly call the 'withdraw' function before the state is updated, resulting in a loss of funds.
p71_2	3	insure	Reentrancy	The 'insure' function calls external contracts 'vault.addValueBatch' and 'vault.transferAttribution' before updating the internal state. This could allow a reentrancy attack, where an attacker could repeatedly call the 'insure' function before the state is updated, resulting in a loss of funds.
p70_2	1	rescue()	Reentrancy	The 'rescue()' function allows an attacker to steal tokens from the pool by recursively calling the function before the state is updated.
p70_2	2	rescue()	Access Control	The 'rescue()' function can be called by anyone, potentially allowing an attacker to withdraw unaccounted tokens.
p70_2	3	_update()	Front-running vulnerability	The '_update()' function updates the reserve values based on the current balances, making it vulnerable to front-running attacks when the reserves are not updated atomically.
p70_2	1	calculateSwap	Integer Overflow	In the function calculateSwap, the multiplication of amountIn, reserveIn, and reserveOut can cause an integer overflow if the numbers are large enough.
p70_2	2	calculateLoss	Division by Zero	In the function calculateLoss, there is a possibility of a division by zero error while calculating originalValue, as releasedAsset can be zero.
p70_2	3	calculateSwapReverse	Division by Zero	In the function calculateSwapReverse, there is a possibility of a division by zero error while calculating amountIn, as denominator (y2) can be zero if amountOut is zero.
p70_2	1	burnSynth	Reentrancy Vulnerability	The burnSynth function allows for potential reentrancy attacks because it calls the external function synth.burn() before updating the state (reserveNative and reserveForeign) of the contract. An attacker could exploit this to drain the contract's assets.
p70_2	2	burnFungible	Reentrancy Vulnerability	The burnFungible function is vulnerable to reentrancy attacks because it calls the external functions lp.burn() and nativeAsset.safeTransfer() before updating the state (reserveNative and reserveForeign) of the contract. An attacker could exploit this to drain the contract's assets.
p70_2	0	N/A	None	The provided Solidity smart contract does not have any high-risk bugs that can cause asset loss or are exploitable.
p70_2	1	propose	Reentrancy	The propose function has a reentrancy vulnerability due to the xVader.transferFrom() call before updating the proposal state. An attacker can exploit this vulnerability by calling the propose function recursively using a malicious token contract.
p70_2	2	_castVote	Integer Overflow	In the _castVote function, proposal.forVotes and proposal.againstVotes are calculated without checking for integer overflows. An attacker can exploit this vulnerability by casting votes with a malicious token contract to manipulate the voting results.
p70_2	1	getVaderPrice, getUSDVPrice	Front-running attack	The getVaderPrice and getUSDVPrice functions are vulnerable to front-running attacks. Since the functions return the updated price, a malicious user can monitor the pending transactions, and if they see an update in the price, they can perform their transaction by front-running the original transaction.
p70_2	2	syncVaderPrice, syncUSDVPrice	Reentrancy attack	The syncVaderPrice and syncUSDVPrice functions update the state variables (pairData.pastLiquidityEvaluation, totalLiquidityWeight) before external calls to getChainlinkPrice. These external calls can potentially invoke a malicious contract that re-enters the functions, causing a reentrancy attack.
p70_2	null
p70_2	null
p69_1	1	addLiquidity721ETHTo, addLiquidity1155ETHTo, addLiquidity721To, addLiquidity1155To	Reentrancy	These functions are marked as nonReentrant, however, they call other internal functions that make external calls to third-party contracts, such as sushiRouter.addLiquidity() and lpStaking.timelockDepositFor(). An attacker could potentially call these functions in a reentrant manner while the external calls are being executed.
p69_1	1	addLiquidity721ETHTo, addLiquidity1155ETHTo	Reentrancy	These functions make an external call to a contract using the `nonReentrant` modifier, but they are still vulnerable to reentrancy attacks since they make another external call after updating the state.
p69_1	2	provideInventory721, provideInventory1155	Integer Overflow	In both functions, the calculations for `xTokensMinted` and `newBal` may lead to integer overflow errors, as there is no check for overflow or safe math operations.
p69_1	3	setLPLockTime, setInventoryLockTime	Lack of input validation	These functions allow the owner to set lock times without checking for minimum values, which could lead to unexpected behavior or asset loss.
p69_1	1	mintAndSell721	Reentrancy vulnerability	The function mintAndSell721 is vulnerable to reentrancy attacks because it makes an external call to _sellVaultTokenETH before updating the state.
p69_1	2	mintAndSell721WETH	Reentrancy vulnerability	The function mintAndSell721WETH is vulnerable to reentrancy attacks because it makes an external call to _sellVaultTokenWETH before updating the state.
p69_1	3	buyAndSwap721	Reentrancy vulnerability	The function buyAndSwap721 is vulnerable to reentrancy attacks because it makes an external call to _buyVaultToken before updating the state.
p69_1	4	buyAndSwap721WETH	Reentrancy vulnerability	The function buyAndSwap721WETH is vulnerable to reentrancy attacks because it makes an external call to _buyVaultToken before updating the state.
p69_1	5	mintAndSell1155	Reentrancy vulnerability	The function mintAndSell1155 is vulnerable to reentrancy attacks because it makes an external call to _sellVaultTokenETH before updating the state.
p69_1	6	mintAndSell1155WETH	Reentrancy vulnerability	The function mintAndSell1155WETH is vulnerable to reentrancy attacks because it makes an external call to _sellVaultTokenWETH before updating the state.
p68_1	null
p68_1	1	joinTokenSingle	Front-running attack	The function joinTokenSingle allows a front-running attack to occur since it is using block.timestamp as the deadline for the token swaps. An attacker can observe the transactions in the mempool and submit their own transaction with a higher gas price to execute before the victim's transaction.
p68_1	2	_joinTokenSingle	Reentrancy attack	The function _joinTokenSingle is vulnerable to reentrancy attacks. The function performs token transfers and external calls to the Pangolin Router and the Basket Facet which can be exploited by a malicious contract to re-enter the function and manipulate the state.
p67_1	1	finishRedeemStable	Reentrancy	The finishRedeemStable function calls the external _swapUstToUnderlying function after super.finishRedeemStable, which can potentially make external calls, making the contract vulnerable to reentrancy attacks.
p67_1	2	_swapUnderlyingToUst and _swapUstToUnderlying	Front-running	The functions _swapUnderlyingToUst and _swapUstToUnderlying allow for a minimum output amount of 0, making the contract susceptible to front-running attacks where an attacker can manipulate the price before the transactions are executed.
p66_1	1	_buyBack	Reentrancy	The `_buyBack` function calls the external contract `IsYETIRouter`'s `swap` function, which might cause reentrancy attacks.
p66_1	2	publicBuyBack	Overflow	The `publicBuyBack` function calculates 5% of the YUSD balance using `YUSDBalance.mul(5)`, which can cause an overflow.
p61_3	0	N/A	None	There are no high-risk bugs present in the provided smart contract which can lead to asset loss or are exploitable.
p61_3	1	_depositToYield	Reentrancy Vulnerability	The `_depositToYield` function does not use the ReentrancyGuard modifier, which allows potential reentrancy attacks when calling the `lockTokens` function of the `_strategy` contract.
p61_3	1	_depositToYield	Reentrancy	The '_depositToYield' function calls the external contract 'IYield(_strategy).lockTokens' while sending ETH value which can lead to reentrancy attacks.
p61_3	2	deposit	No validation for zero address strategy	The 'deposit' function does not validate if the provided strategy is a non-zero address, which can lead to unexpected behavior and potential loss of assets.
p61_3	1	withdrawFromSavingsAccount	Reentrancy	The function withdrawFromSavingsAccount calls _savingsAccount.withdraw or _savingsAccount.withdrawFrom, which might include external calls to untrusted contracts, leading to potential reentrancy attacks.
p61_3	1	emergencyWithdraw	Reentrancy	The emergencyWithdraw function is vulnerable to reentrancy attacks as it directly transfers tokens to a user-controlled wallet address without using ReentrancyGuard.
p61_3	2	getSharesForTokens	Integer Overflow	The getSharesForTokens function uses multiplication and division without proper overflow checks, which can lead to unexpected results.
p61_3	1	lockTokens	Reentrancy	The function `lockTokens` is marked as nonReentrant, but it still contains a possible reentrancy issue due to the use of the `safeTransferFrom` function.
p61_3	2	unlockTokens	Reentrancy	The function `unlockTokens` is marked as nonReentrant, but it still contains a possible reentrancy issue due to the use of the `safeTransfer` function.
p61_3	1	emergencyWithdraw	Reentrancy	The function transfers the token balance to the `_wallet` address before updating the local variable `received`. This can lead to a reentrancy attack, allowing the attacker to withdraw more tokens than intended.
p61_3	1	emergencyWithdraw	Reentrancy	The emergencyWithdraw function is marked as nonReentrant, but it contains a call to an external contract which can potentially call back into the contract before the state is updated, allowing an attacker to repeatedly withdraw funds.
p61_3	2	lockTokens	Reentrancy	The lockTokens function is marked as nonReentrant, but it contains a call to an external contract (safeTransferFrom) which can potentially call back into the contract before the state is updated, allowing an attacker to repeatedly lock tokens.
p61_3	3	unlockTokens	Reentrancy	The unlockTokens function is marked as nonReentrant, but it contains a call to an external contract (safeTransfer) which can potentially call back into the contract before the state is updated, allowing an attacker to repeatedly unlock tokens.
p61_3	4	unlockShares	Reentrancy	The unlockShares function is marked as nonReentrant, but it contains a call to an external contract (safeTransfer) which can potentially call back into the contract before the state is updated, allowing an attacker to repeatedly unlock shares.
p65_1	1	mintTo	Reentrancy	The `mintTo` function can be exploited by a malicious ERC20 token to reenter the contract and mint an arbitrary number of tokens.
p65_1	2	burn	Reentrancy	The `burn` function can be exploited by a malicious ERC20 token to reenter the contract and burn tokens from other users.
p65_1	3	auctionBurn	Reentrancy	The `auctionBurn` function can be exploited by a malicious ERC20 token to reenter the contract and burn tokens from other users.
p64_1	1	claimRewards	Reentrancy	This function transfers tokens to a user before updating their claimed epochs. This could allow for a reentrancy attack if the token has a custom implementation that makes a callback to claimRewards.
p61_1	1	emergencyWithdraw	Reentrancy	Although the contract uses ReentrancyGuard, the 'nonReentrant' modifier is not applied to the 'emergencyWithdraw' function. This can lead to potential reentrancy attacks and asset loss.
p61_1	1	emergencyWithdraw	Reentrancy	The function allows the contract owner to withdraw all tokens of a specific type without considering the locked tokens of other users, which can lead to asset loss.
p61_1	2	emergencyWithdraw	Asset Loss due to wrong variable	The function uses the variable 'received' instead of 'amount' when transferring tokens, which results in transferring an uninitialized value, potentially causing asset loss.
p61_1	1	lockTokens	Reentrancy	The function lockTokens is using the nonReentrant modifier from the ReentrancyGuard contract, which should prevent reentrancy attacks. However, since the nonReentrant modifier is used after the transfer of funds (msg.value) in the function, an attacker could potentially make a reentrant call before the nonReentrant state is set, leading to a reentrancy vulnerability.
p61_1	1	emergencyWithdraw	Reentrancy	The emergencyWithdraw function could be exploited by a reentrancy attack, as it sends tokens to the _wallet address before updating the internal balance of the contract. An attacker could use a fallback function on the _wallet address to call emergencyWithdraw again before the contract's balance is updated, draining the funds.
p61_1	1	withdrawFromSavingsAccount	Reentrancy	The `withdrawFromSavingsAccount` function is prone to reentrancy attacks as it calls an external contract `_savingsAccount.withdraw()` or `_savingsAccount.withdrawFrom()` before updating the state. An attacker can use a malicious contract to call back into `withdrawFromSavingsAccount` and drain the contract's assets.
p61_1	2	transferTokens	Insufficient validation	The `transferTokens` function does not check if the `_to` address is a valid non-zero address. If the function is called with a zero address, it could result in an accidental loss of funds.
p61_1	1	_depositToYield	Reentrancy	The function _depositToYield does not use the `nonReentrant` modifier, which could lead to reentrancy attacks if an attacker is able to call this function multiple times in a row before the state is updated.
p61_1	2	_depositToYield	Missing input validation	The function _depositToYield does not check if the `_strategy` parameter is a non-zero address. If it's a zero address, it may result in unexpected behavior or asset loss.
p61_1	1	getChainlinkLatestPrice	Integer Overflow	When calculating the price in the getChainlinkLatestPrice function, there is a possibility of integer overflow as SafeMath is not used for all arithmetic operations.
p92_2	1	boost	Reentrancy	The 'boost' function is vulnerable to a reentrancy attack because it transfers FEI tokens to the vault before updating the contract's state.
p92_2	2	less	Reentrancy	The 'less' function is vulnerable to a reentrancy attack because it transfers tokens to the vault before updating the contract's state.
p92_2	3	slurp	Reentrancy	The 'slurp' function is vulnerable to a reentrancy attack because it transfers tokens to the master contract before updating the contract's state.
p92_2	4	sweep	Reentrancy	The 'sweep' function is vulnerable to a reentrancy attack because it transfers tokens to the specified address before emitting the 'TokenSweeped' event.
p92_2	5	gib	Reentrancy	The 'gib' function is vulnerable to a reentrancy attack because it transfers tokens to the specified address before emitting the 'SafeGibbed' event.
p83_3	1	deposit	Reentrancy	The 'deposit' function updates the state after transferring tokens, which might allow attackers to exploit the reentrancy vulnerability.
p83_3	2	withdraw	Reentrancy	The 'withdraw' function updates the state after transferring tokens, which might allow attackers to exploit the reentrancy vulnerability.
p83_3	3	deposit	Integer Overflow and Underflow	The '+=' and '-=' operations in 'deposit' function can lead to integer overflow and underflow issues.
p83_3	4	withdraw	Integer Overflow and Underflow	The '+=' and '-=' operations in 'withdraw' function can lead to integer overflow and underflow issues.
p83_3	1	withdraw	Reentrancy	The 'withdraw' function updates the state after transferring tokens, which might allow attackers to exploit the reentrancy vulnerability.
p83_3	2	donate	Integer Overflow and Underflow	The '+=' operation in 'donate' function can lead to integer overflow issues.
p83_3	3	withdraw	Missing validation	The 'withdraw' function does not check if the user has already claimed their tokens, allowing them to withdraw multiple times.
p83_3	1	deposit, withdraw	Front-Running	Users can front-run deposit and withdraw transactions to gain an advantage in getting rewards, potentially leading to asset loss for other users.
p83_3	2	add	Missing Validation	The 'add' function does not validate the value of '_depositFee', which could lead to unexpectedly high fees or overflows.
p83_3	null
p90_2	1	mint	Reentrancy	The mint function calls an external contract (vToken.mint()) within a loop, which may allow an attacker to perform a reentrancy attack if the external contract has malicious code.
p90_2	2	burn	Reentrancy	The burn function calls an external contract (vToken.burn(_recipient)) within a loop, which may allow an attacker to perform a reentrancy attack if the external contract has malicious code.
p83_2	1	deposit()	Reentrancy	Reentrancy vulnerability exists in deposit() function due to the use of external calls before the state updates. The external call to masterChef.deposit() can allow an attacker to re-enter the deposit() function and manipulate the state.
p83_2	1	deposit	Reentrancy	The 'deposit' function is vulnerable to reentrancy attacks due to the external call to 'safeConcurTransfer' before updating the user's state.
p83_2	2	withdraw	Reentrancy	The 'withdraw' function is vulnerable to reentrancy attacks due to the external call to 'safeConcurTransfer' before updating the user's state.
p83_2	1	donate	Integer Overflow	The 'donate' function is vulnerable to integer overflow when updating 'savedTokens' without using SafeMath for addition.
p83_2	2	withdraw	Integer Overflow	The 'withdraw' function is vulnerable to integer overflow when calculating 'amount' without using SafeMath for multiplication and division.
p83_2	1	deposit	Integer Overflow/Underflow	The 'deposit' function is vulnerable to integer overflow when updating 'total' and 'user' liquidity without using SafeMath for addition.
p83_2	2	withdraw	Integer Overflow/Underflow	The 'withdraw' function is vulnerable to integer underflow when updating 'total' and 'user' liquidity without using SafeMath for subtraction.
p81_3	1	claimCOMPAndTransfer	Reentrancy	The function claimCOMPAndTransfer is vulnerable to reentrancy attack as it calls an external contract (COMP.safeTransfer) after updating the state (COMPTROLLER.claimComp).
p81_3	2	setReserveBuffer	Denial of Service	The function setReserveBuffer can be called by the owner with an arbitrary high bufferAmount, effectively locking the reserve balance, making it unharvestable, and causing a Denial of Service.
p81_3	1	redeem	Reentrancy	The redeem function is not protected against reentrancy attacks, even though it's marked as nonReentrant. The issue is that the `_burn` function is called before the `safeTransfer` function, which makes the contract susceptible to reentrancy.
p81_3	1	getVotingPower	Integer Overflow	The getVotingPower function is susceptible to integer overflow when calculating the `noteAmount`. If the `bptPrice`, `notePrice`, and `bptBalance` are large enough, the multiplication can result in an overflow.
p81_2	1	claimCOMPAndTransfer	Reentrancy	The function claimCOMPAndTransfer is not protected against reentrancy attacks, which could lead to potential asset loss.
p81_2	2	transferReserveToTreasury	Reentrancy	The function transferReserveToTreasury is not protected against reentrancy attacks, which could lead to potential asset loss.
p81_2	null
p80_2	1	_calcCvxIntegral	Reentrancy	The _calcCvxIntegral function contains a reentrancy vulnerability because it transfers tokens to an external address while the contract state is not yet finalized, allowing for potential reentrancy attacks.
p80_2	2	_calcRewardIntegral	Reentrancy	The _calcRewardIntegral function contains a reentrancy vulnerability because it transfers tokens to an external address while the contract state is not yet finalized, allowing for potential reentrancy attacks.
p80_2	1	wrap	Reentrancy	The `wrap` function contains a reentrancy vulnerability, as it updates the user balance after calling an external contract (`IRewardStaking(convexPool).stake(amount_);`). If the `convexPool` contract contains malicious code, it may call back into the `wrap` function and manipulate the user's balance.
p80_2	2	unwrap	Reentrancy	The `unwrap` function contains a reentrancy vulnerability, as it updates the user balance after calling an external contract (`IRewardStaking(convexPool).withdraw(amount_, false);`). If the `convexPool` contract contains malicious code, it may call back into the `unwrap` function and manipulate the user's balance.
p78_3	1	purchasePyroFlan	Reentrancy	The purchasePyroFlan function contains multiple external calls (transferFrom, mint, and transfer) which may enable reentrancy attacks, allowing an attacker to manipulate the state of the contract.
p78_3	2	getMagnitude	Integer Overflow	The getMagnitude function calculates 10**places, which may lead to integer overflow if places is a large value.
p78_3	3	normalize	Integer Overflow	The normalize function calculates amount * bump, which may lead to integer overflow if amount or bump is a large value.
p78_3	null
p78_3	1	transferAndCall	Reentrancy	The transferAndCall function may be vulnerable to reentrancy attacks since it performs a state-changing external call to the contractFallback function, which calls the onTokenTransfer function of the receiver contract.
p78_3	2	transferAndCall	Double Transfer	The transferAndCall function calls super.transfer and _transfer functions, causing the token transfer to be executed twice, resulting in incorrect token balances.
p78_3	1	setEnforcement	Missing access control	The setEnforcement function allows anyone to call it and change the enforcement status, which should be restricted to only the contract owner or a successful proposal.
p78_3	2	withdrawGovernanceAsset	Reentrancy	The withdrawGovernanceAsset function is vulnerable to reentrancy attacks as it performs a state-changing external call (IERC20 transfer) before deleting the pendingFlashDecision mapping.
p78_3	3	enforceToleranceInt	Integer Overflow and Underflow	The enforceToleranceInt function is not properly handling possible integer overflow and underflow while converting int256 to uint256.
p78_3	1	setEYEBasedAssetStake	Reentrancy	In the setEYEBasedAssetStake function, the ERC20NetTransfer is called after updating the user's fatePerDay, which allows for a reentrancy attack through the token transfer.
p78_3	2	burnAsset	Missing validation	The burnAsset function does not check if the amount of asset to be burnt is greater than 0, which could lead to unexpected behavior.
p79_2	1	withdrawAVAX()	Reentrancy	The withdrawAVAX function first updates the state and then performs a transfer. If the recipient is a contract, it can call back into the function before the transfer is complete, allowing the attacker to drain the contract's balance.
p79_2	2	depositAVAX()	Front-running	The depositAVAX function is vulnerable to front-running attacks, where an attacker can monitor pending transactions and submit a transaction with a higher gas price to have their transaction executed first, manipulating the outcome.
p79_2	3	emergencyWithdraw()	Denial of Service (DoS)	In emergencyWithdraw, if the user has a large amount of tokens, the transfer function could run out of gas, causing the transaction to fail and making the funds inaccessible.
p79_2	4	initialize()	No input validation	The initialize function does not have proper input validation, which could lead to unexpected outcomes or unintended behavior.
p79_2	5	createPair()	Price manipulation	The createPair function relies on an external router and factory to create the liquidity pool. An attacker with control over the router or factory can manipulate the price of the token.
p78_2	1	purchasePyroFlan	Price Manipulation Vulnerability	The purchasePyroFlan function checks if the tilted price is less than the acceptable highest price to prevent price manipulation. However, this check can be bypassed by manipulating the prices within the acceptable range, which could lead to potential asset loss.
p78_2	2	purchasePyroFlan	Reentrancy Vulnerability	The purchasePyroFlan function has multiple external contract calls, such as FlanLike.mint(), PyroTokenLike.mint(), and IERC20.transferFrom(), which could potentially be exploited through a reentrancy attack, leading to asset loss.
p78_2	1	setEnforcement	Missing Access Control	The setEnforcement function is missing an access control mechanism, allowing any external address to call it and change the enforcement status, which could lead to unintended consequences and potential asset loss.
p78_2	1	transferAndCall	Duplicate Token Transfer	The transferAndCall function calls both super.transfer() and _transfer() which results in duplicate token transfers, causing an incorrect token transfer amount and potential asset loss.
p78_2	1	withdrawGovernanceAsset	Reentrancy	The function withdrawGovernanceAsset allows a user to withdraw their collateral asset after the lock window. However, it doesn't have reentrancy protection, making it potentially vulnerable to a reentrancy attack.
p78_2	1	setEYEBasedAssetStake	Reentrancy	The function `setEYEBasedAssetStake` updates the user's fate balance and asset clout before calling an external contract (ERC20NetTransfer). This can lead to reentrancy attacks.
p78_2	2	burnAsset	Reentrancy	The function `burnAsset` updates the user's fate balance before calling an external contract (transferFrom and burn). This can lead to reentrancy attacks.
p77_2	1	swapBaseTokenForQuoteToken, swapQuoteTokenForBaseToken	Reentrancy	Although the contract uses ReentrancyGuard, it can be bypassed as the SafeERC20 library is used. SafeERC20.safeTransfer and safeTransferFrom use a fixed gas limit for token transfers, allowing for potential reentrancy attacks.
p77_2	1	wDiv	Integer Division	The wDiv function divides the numbers using integer division, which can lead to rounding errors and imprecise results.
p77_2	2	calculateBaseTokenQty, calculateQuoteTokenQty, calculateAddLiquidityQuantities, calculateAddTokenPairLiquidityQuantities, calculateAddBaseTokenLiquidityQuantities, calculateAddQuoteTokenLiquidityQuantities	Reentrancy	The mentioned functions modify the state of the contract (InternalBalances) after performing external calls, which makes them vulnerable to reentrancy attacks.
p74_3	1	mint, burn, lend, withdraw, borrow, pay	Reentrancy	The contract uses a custom reentrancy guard instead of the OpenZeppelin's ReentrancyGuard, which is less secure and not recommended.
p74_3	1	receive()	Reentrancy	The receive() function is payable and does not contain any logic. This leaves the contract open to potential reentrancy attacks when interacting with other contracts or callbacks.
p74_1	1	migrateETH	Reentrancy	The function `migrateETH` withdraws ETH from `IBridgeMinter` and then calls `sendTxToL2` function which is an external contract call. This could potentially allow a reentrancy attack if the external contract is malicious.
p74_1	2	migrateLPT	Reentrancy	The function `migrateLPT` withdraws LPT from `IBridgeMinter`, approves the transfer to `l1LPTGatewayAddr`, and then calls the `outboundTransfer` function of an external contract. This could potentially allow a reentrancy attack if the external contract is malicious.
p74_1	1	receive()	Reentrancy	The receive() function is defined as payable but does not include any logic. This could lead to reentrancy attacks, where an attacker repeatedly calls the contract to drain its funds.
p74_1	2	timeswapMintCallback(), timeswapLendCallback(), timeswapBorrowCallback()	Lack of input validation	These functions are not validating the input data. An attacker could exploit this to perform malicious actions.
p74_1	3	deployNative()	Missing access controls	The deployNative() function does not have any access controls in place, allowing anyone to call the function and potentially deploy malicious native contracts.
p74_1	1	mint, burn, lend, withdraw, borrow, pay	Reentrancy Vulnerability	The `lock` modifier is intended to prevent reentrancy attacks but its implementation is flawed. The `locked` variable is set to 0 after the function execution, allowing reentrancy.
p71_3	1	approveTemplate	Missing input validation	The function does not validate if the template is already approved or not. If the template is already approved and has markets created based on it, changing the approval, openness or duplicity may cause unexpected behavior in the contract.
p71_3	2	createMarket	Missing input validation	The function does not validate if the given template address is valid or not. Creating a market with an incorrect template address may lead to unexpected behavior or loss of assets.
p71_3	1	withdrawValue	Reentrancy Vulnerability	The function transfers tokens before updating the contract's state, which can lead to a reentrancy attack.
p71_3	1	withdraw	Reentrancy	The 'withdraw' function calls an external contract (vault.withdrawValue) before updating the state (withdrawalReq), making it vulnerable to reentrancy attacks.
p71_3	2	adjustAlloc	Lack of access control	The 'adjustAlloc' function is public and can be called by anyone, potentially leading to unintended behavior or denial of service.
p71_3	1	deposit	Reentrancy	The 'deposit' function allows a potential reentrancy attack because it calls an external contract 'vault.addValue()' before emitting the Deposit event and updating the user's balance.
p71_3	2	withdraw	Reentrancy	The 'withdraw' function is vulnerable to a reentrancy attack as it calls an external contract 'vault.withdrawValue()' before emitting the Withdraw event and updating the user's balance.
p71_3	3	insure	Reentrancy	The 'insure' function is vulnerable to a reentrancy attack as it calls an external contract 'vault.addValueBatch()' before updating the Insurance struct and the 'allInsuranceCount' variable.
p71_1	1	createMarket	Reentrancy	The function creates a new market and calls the external `initialize` function on the newly created market. An attacker may create a malicious market contract and exploit the reentrancy vulnerability during the `initialize` call, manipulating the state before the `MarketCreated` event is emitted.
p71_1	2	createMarket	Missing input validation	The function does not validate that the `_references` and `_conditions` arrays have the same length, which may lead to unexpected behavior.
p71_1	1	withdrawValue	Reentrancy Vulnerability	The `withdrawValue` function transfers tokens to the `_to` address before updating the `balance`. This allows for reentrancy attacks where the attacker can repeatedly call this function and drain the contract's balance.
p71_1	2	_withdrawAttribution	Reentrancy Vulnerability	The `_withdrawAttribution` function transfers tokens to the `_to` address before updating the `balance`. This allows for reentrancy attacks where the attacker can repeatedly call this function and drain the contract's balance.
p71_1	3	repayDebt	Reentrancy Vulnerability	The `repayDebt` function transfers tokens from the sender to the contract before updating the `debts` and `totalDebt`. This allows for reentrancy attacks where the attacker can repeatedly call this function and manipulate the contract's state.
p71_1	1	withdraw	Reentrancy	The withdraw function allows a user to withdraw their funds, but it doesn't have a reentrancy guard. An attacker can exploit this vulnerability by creating a malicious contract that calls the withdraw function in its fallback function, causing a reentrant call.
p71_1	2	deposit	Integer Overflow/Underflow	The deposit function calculates the mint amount based on the user's deposit and the total supply. However, it does not check for potential integer overflow/underflow issues, which could lead to incorrect token minting.
p71_1	3	adjustAlloc	Missing access control	The adjustAlloc function allows anyone to change the allocation of credit among pools. An attacker can manipulate the allocation of credit, affecting the risk and leverage of the index.
p71_1	1	withdraw	Reentrancy	The 'withdraw' function calls an external contract (vault.withdrawValue) before updating the withdrawal request state, which might allow reentrancy attacks.
p71_1	2	allocateCredit	Integer Overflow	The '_index.rewardDebt' calculation could cause an integer overflow if '_index.credit' and 'rewardPerCredit' are very large values.
p70_1	1	rescue	Reentrancy	The `rescue` function allows the contract owner to transfer unaccounted tokens to their address. This could potentially result in an exploitable reentrancy attack, where the contract state is manipulated during the token transfer.
p70_1	2	rescue	Unsafe Token Transfers	The `rescue` function is transferring tokens without checking for a return value. This is unsafe when dealing with non-standard ERC20 tokens that don't return a boolean value for their transfer function.
p70_1	1	calculateLiquidityUnits	Integer Division Rounding Error	When calculating the `poolUnitFactor` and `denominator`, integer division is used, which may result in rounding errors and imprecise calculations.
p70_1	2	calculateSlipAdjustment	Division by Zero	If both `vaderDeposited` and `vaderBalance` are 0, `denominator` would be 0, leading to a division by zero error when calculating the slip adjustment.
p70_1	3	calculateSwap	Division by Zero	If `amountIn + reserveIn` is 0, then `denominator` would be 0, leading to a division by zero error when calculating the swap amount.
p70_1	4	calculateSwapReverse	Division by Zero	If `y2` is 0, then `denominator` would be 0, leading to a division by zero error when calculating the swap amount in reverse.
p70_1	1	mintSynth	Reentrancy	The function mintSynth transfers the native asset before updating the reserves, allowing for a reentrancy attack to exploit the outdated reserves in another function call.
p70_1	2	burnSynth	Reentrancy	The function burnSynth burns the synth tokens and then transfers the native asset without updating the reserves, allowing for a reentrancy attack to exploit the outdated reserves in another function call.
p70_1	1	mul	Integer Overflow	In the 'mul' function, there is a possibility of an integer overflow when multiplying 'self._x' by 'y'.
p70_1	2	muli	Integer Overflow	In the 'muli' function, there is a possibility of an integer overflow when multiplying 'self._x' by 'y' using FullMath.mulDiv().
p70_1	3	muluq	Integer Overflow	In the 'muluq' function, there is a possibility of integer overflow when performing the multiplication of the partial products (upper, lower, uppers_lowero, uppero_lowers).
p70_1	4	divuq	Integer Overflow	In the 'divuq' function, there is a possibility of integer overflow when dividing 'self._x' by 'other._x'.
p70_1	5	fraction	Integer Overflow	In the 'fraction' function, there is a possibility of integer overflow when multiplying 'numerator' by 'Q112' or when dividing the result by 'denominator'.
p70_1	1	constructor	No check for the Timelock address in the constructor	The GovernorAlpha contract's constructor does not check whether the Timelock address is set to a non-zero address, making it possible for the Timelock to be uninitialized, leading to potential asset loss.
p70_1	2	setTimelock	No check for the zero address when calling setTimelock	The setTimelock function allows the guardian to change the Timelock address, but it does not check whether the provided address is the zero address, which could lead to loss of control over the contract.
p70_1	1	syncVaderPrice, syncUSDVPrice	Reentrancy	Both functions can lead to reentrancy attacks because they call external contracts (UniswapV2OracleLibrary and IAggregatorV3) while the contract state is being updated. This can cause unexpected behavior and potentially asset loss.
p70_1	1	reimburseImpermanentLoss	Reentrancy	The `reimburseImpermanentLoss` function contains a reentrancy vulnerability due to the external call to `vader.safeTransfer` before updating the state. An attacker could exploit this vulnerability to drain the contract's assets.
p70_1	1	claim	Reentrancy	The `claim` function contains a reentrancy vulnerability due to the external call to `_transfer` and `vader.transfer` before removing the lock from the `locks` mapping. An attacker could exploit this vulnerability to claim locked funds multiple times.
p69_3	1	provideInventory721, provideInventory1155, addLiquidity721ETH, addLiquidity1155ETH, addLiquidity721, addLiquidity1155	Front-Running Attack	The functions do not use any price oracles or mechanisms to prevent front-running attacks. Attackers can manipulate the transactions to gain an unfair advantage by observing pending transactions and executing their own with higher gas prices.
p69_3	1	buyAndSwap721	Reentrancy	The buyAndSwap721 function is potentially vulnerable to a reentrancy attack due to the use of the 'nonReentrant' modifier while also interacting with an external contract (sushiRouter) before updating its state.
p69_3	2	buyAndSwap721WETH	Reentrancy	The buyAndSwap721WETH function is potentially vulnerable to a reentrancy attack due to the use of the 'nonReentrant' modifier while also interacting with an external contract (sushiRouter) before updating its state.
p69_3	3	buyAndSwap1155	Reentrancy	The buyAndSwap1155 function is potentially vulnerable to a reentrancy attack due to the use of the 'nonReentrant' modifier while also interacting with an external contract (sushiRouter) before updating its state.
p69_3	4	buyAndSwap1155WETH	Reentrancy	The buyAndSwap1155WETH function is potentially vulnerable to a reentrancy attack due to the use of the 'nonReentrant' modifier while also interacting with an external contract (sushiRouter) before updating its state.
p69_3	5	buyAndRedeem	Reentrancy	The buyAndRedeem function is potentially vulnerable to a reentrancy attack due to the use of the 'nonReentrant' modifier while also interacting with an external contract (sushiRouter) before updating its state.
p69_3	6	buyAndRedeemWETH	Reentrancy	The buyAndRedeemWETH function is potentially vulnerable to a reentrancy attack due to the use of the 'nonReentrant' modifier while also interacting with an external contract (sushiRouter) before updating its state.
p68_3	null
p68_3	1	joinTokenSingle	Reentrancy	The `joinTokenSingle` function is vulnerable to reentrancy attacks. An attacker could call this function repeatedly before the state is updated, potentially draining tokens.
p68_3	2	_joinTokenSingle	Front-running	The `_joinTokenSingle` function is vulnerable to front-running attacks because it uses `block.timestamp` for the deadline. Attackers could front-run a transaction and manipulate the outcome.
p68_3	3	_maxApprove	Integer Overflow	The `_maxApprove` function uses `uint256(-1)` for approving the maximum token amount. This can result in an integer overflow.
p69_2	1	addLiquidity721ETHTo	Reentrancy	The function addLiquidity721ETHTo is vulnerable to a reentrancy attack since it makes a transfer of ETH to the address 'to' after calling the internal function _addLiquidity721WETH which has external interactions with the Uniswap router (sushiRouter). An attacker could use a malicious contract as the 'to' address to reenter the function and manipulate the state.
p69_2	2	addLiquidity1155ETHTo	Reentrancy	The function addLiquidity1155ETHTo is vulnerable to a reentrancy attack since it makes a transfer of ETH to the address 'to' after calling the internal function _addLiquidity1155WETH which has external interactions with the Uniswap router (sushiRouter). An attacker could use a malicious contract as the 'to' address to reenter the function and manipulate the state.
p69_2	1	buyAndSwap721	Reentrancy	The function buyAndSwap721 is marked as nonReentrant, but it has a nested external call before the state is updated. This can be exploited to reenter the function before the state changes, leading to potential asset loss.
p69_2	2	buyAndSwap721WETH	Reentrancy	The function buyAndSwap721WETH is marked as nonReentrant, but it has a nested external call before the state is updated. This can be exploited to reenter the function before the state changes, leading to potential asset loss.
p69_2	3	buyAndSwap1155	Reentrancy	The function buyAndSwap1155 is marked as nonReentrant, but it has a nested external call before the state is updated. This can be exploited to reenter the function before the state changes, leading to potential asset loss.
p69_2	4	buyAndSwap1155WETH	Reentrancy	The function buyAndSwap1155WETH is marked as nonReentrant, but it has a nested external call before the state is updated. This can be exploited to reenter the function before the state changes, leading to potential asset loss.
p69_2	5	buyAndRedeem	Reentrancy	The function buyAndRedeem is marked as nonReentrant, but it has a nested external call before the state is updated. This can be exploited to reenter the function before the state changes, leading to potential asset loss.
p69_2	6	buyAndRedeemWETH	Reentrancy	The function buyAndRedeemWETH is marked as nonReentrant, but it has a nested external call before the state is updated. This can be exploited to reenter the function before the state changes, leading to potential asset loss.
p68_2	1	joinPool	Reentrancy	joinPool function is vulnerable to reentrancy attacks due to the use of the 'noReentry' modifier which can be bypassed. The function allows transferring of tokens from the user to the contract which can be exploited by an attacker in a recursive call.
p68_2	2	exitPool	Reentrancy	exitPool function is vulnerable to reentrancy attacks due to the use of the 'noReentry' modifier which can be bypassed. The function allows transferring of tokens from the contract to the user which can be exploited by an attacker in a recursive call.
p68_2	1	joinTokenSingle	Reentrancy	The joinTokenSingle function allows for reentrancy since it sends tokens to the msg.sender (the user) after calling the internal function _joinTokenSingle. A malicious user can create a contract that calls joinTokenSingle again during the transfer, which could cause unexpected behavior.
p68_2	2	_joinTokenSingle	Front-running	The _joinTokenSingle function is vulnerable to front-running attacks because it uses block.timestamp for the deadline of swapExactTokensForTokens. Miners can manipulate the timestamp, enabling them to front-run transactions and manipulate prices.
p67_3	1	_swapUnderlyingToUst	Front-running	A malicious actor can front-run the transaction to manipulate the token price, leading to less UST received in the swap.
p67_3	2	_swapUstToUnderlying	Front-running	A malicious actor can front-run the transaction to manipulate the token price, leading to less underlying tokens received in the swap.
p66_3	1	mint	Reentrancy Attack	The mint function calls the external function 'yetiToken.sendToSYETI' before updating the internal state 'effectiveYetiTokenBalance', which allows for potential reentrancy attacks.
p66_3	2	mint	Integer Overflow	The mint function calculates 'shares' without proper overflow checks, which could lead to integer overflow when multiplying 'amount' and 'totalSupply'.
p66_3	3	_buyBack	Unchecked External Call	The '_buyBack' function makes an external call to 'IsYETIRouter(_routerAddress).swap' without checking the return value, which could allow an attacker to control the execution flow of the contract.
p66_3	4	_burn	Reentrancy Attack	The '_burn' function calls the external function 'yetiToken.transfer' before updating the internal state 'effectiveYetiTokenBalance', which allows for potential reentrancy attacks.
p67_2	1	finishRedeemStable	Reentrancy	The function `finishRedeemStable` is called before the UST is swapped back to the underlying token, which can lead to potential reentrancy attacks.
p67_2	2	_swapUnderlyingToUst	Front-running	The function `_swapUnderlyingToUst` is vulnerable to front-running attacks as it uses a zero minimum amount of tokens to receive in the swap.
p67_2	3	_swapUstToUnderlying	Front-running	The function `_swapUstToUnderlying` is vulnerable to front-running attacks as it uses a zero minimum amount of tokens to receive in the swap.
p66_2	1	mint	Reentrancy	The `mint` function allows a user to stake YETI tokens but calls the `yetiToken.sendToSYETI` function before updating the user's balance and effectiveYetiTokenBalance. If the `sendToSYETI` function is maliciously implemented, it could lead to reentrancy attacks causing multiple stakes before the balances are updated.
p66_2	2	setAddresses	Uninitialized variables	The `setAddresses` function allows the owner to set the addresses for the YETI and yUSD tokens, but it can only be called once. If the owner forgets to set the addresses, the contract could become unusable.
p66_2	3	publicBuyBack	Reentrancy	The `publicBuyBack` function allows anyone to initiate a buyback, but it calls the `_buyBack` function which has the potential to interact with untrusted external contracts (IsYETIRouter). This can lead to reentrancy attacks if the router's swap function is maliciously implemented.
p64_3	null
p65_3	1	mintTo	Reentrancy	The function `mintTo` is not reentrant, but the `nonReentrant` modifier is not applied to it. This can cause reentrancy issues if a malicious actor calls the function while it is still executing.
p65_3	2	handleFees	Timestamp Manipulation	The function `handleFees` uses `block.timestamp` to calculate the time difference for license fees. Miners can manipulate the block timestamp to some extent, which could lead to inaccuracies in fee calculation.
p65_3	3	pushUnderlying	Integer Overflow/Underflow	The function `pushUnderlying` calculates `tokenAmount` by multiplying three values without checking for overflow. An overflow could result in an incorrect token amount being transferred.
p65_3	4	pullUnderlying	Integer Overflow/Underflow	The function `pullUnderlying` calculates `tokenAmount` by multiplying three values without checking for overflow. An overflow could result in an incorrect token amount being transferred.
p65_2	1	mintTo()	Reentrancy vulnerability	The 'mintTo()' function is marked as nonReentrant, but it calls the external function 'pullUnderlying()' which contains 'IERC20.safeTransferFrom()', which might cause a reentrancy attack.
p65_2	2	burn()	Reentrancy vulnerability	The 'burn()' function is marked as nonReentrant, but it calls the external function 'pushUnderlying()' which contains 'IERC20.safeTransfer()', which might cause a reentrancy attack.
p64_2	1	claimRewards	Reentrancy	The `claimRewards` function calls an external contract (`_promotion.token.safeTransfer`) before updating the state (`_claimedEpochs[_promotionId][_user]`). This can allow reentrancy attacks to claim rewards multiple times.
p64_2	2	extendPromotion	Integer Overflow	When calculating the `_extendedNumberOfEpochs`, there is no check for integer overflow. It may result in an unexpected value for `_promotions[_promotionId].numberOfEpochs`.
p61_2	1	emergencyWithdraw	Reentrancy	The emergencyWithdraw function is vulnerable to reentrancy attacks since it is marked as nonReentrant, but it makes external calls to the _wallet address with a non-zero amount of ETH or ERC20 tokens before updating the balance of the contract.
p61_2	2	receive	Incorrect Access Control	The receive function accepts any incoming funds, but it does not have any access control. This allows any external account to send funds to the contract.
p61_2	1	emergencyWithdraw	Reentrancy	The emergencyWithdraw function does not implement the nonReentrant modifier, making it vulnerable to reentrancy attacks.
p61_2	1	emergencyWithdraw	Reentrancy	The emergencyWithdraw function calls external functions (IERC20.safeTransfer and _wallet.call) with the contract's balance, which may enable a reentrancy attack.
p61_2	2	lockTokens	Reentrancy	The lockTokens function calls external functions (IERC20.safeTransferFrom and _depositETH/_depositERC20) with the contract's balance, which may enable a reentrancy attack.
p61_2	3	unlockTokens	Reentrancy	The unlockTokens function calls external functions (IERC20.safeTransfer and savingsAccount.call) with the contract's balance, which may enable a reentrancy attack.
p61_2	4	unlockShares	Reentrancy	The unlockShares function calls an external function (IERC20.safeTransfer) with the contract's balance, which may enable a reentrancy attack.
p61_2	1	emergencyWithdraw	Reentrancy	The emergencyWithdraw function lacks the nonReentrant modifier, which can allow reentrancy attacks. 
p61_2	2	receive	Reentrancy	The receive function lacks the nonReentrant modifier, which can allow reentrancy attacks.
p61_2	null
p61_2	1	_depositToYield	Reentrancy vulnerability	The _depositToYield function calls the lockTokens function of the IYield interface, which might contain external calls that can cause a reentrancy attack.
p61_2	2	switchStrategy	Reentrancy vulnerability	The switchStrategy function calls the lockTokens and unlockTokens functions of the IYield interface, which might contain external calls that can cause a reentrancy attack.
p61_2	3	_withdraw	Reentrancy vulnerability	The _withdraw function calls the unlockShares and unlockTokens functions of the IYield interface, which might contain external calls that can cause a reentrancy attack.
p61_2	1	getChainlinkLatestPrice	Integer Overflow	In getChainlinkLatestPrice, when calculating the price, there is a potential for integer overflow due to multiple multiplications without checking for overflow.
p193_3	1	sell()	Reentrancy	The 'sell()' function allows for potential reentrancy attacks because it transfers the base token to the user before updating the internal state.
p193_3	2	remove()	Reentrancy	The 'remove()' function allows for potential reentrancy attacks because it transfers the base token to the user before updating the internal state.
p193_3	3	nftRemove()	Reentrancy	The 'nftRemove()' function allows for potential reentrancy attacks because it transfers the base token to the user before updating the internal state.
p193_1	1	buy	Reentrancy	The buy function is vulnerable to reentrancy attacks, as it transfers funds (ETH or baseToken) to the user before updating the token balance in the contract.
p193_1	2	wrap	Missing input validation	The wrap function does not check for duplicate tokenIds in the input array, allowing users to mint multiple fractional tokens for the same NFT.
p193_1	3	addQuote	Integer Overflow	In addQuote, multiplication before division can cause an integer overflow and result in an incorrect lpTokenAmount calculation.
p192_1	1	_closePosition	Reentrancy	The _closePosition function can be exploited by reentrancy, as it modifies the state after executing an external call, making the contract vulnerable to reentrancy attacks.
p192_1	2	_checkGas	Front-running	The _checkGas function can be exploited by front-running attacks, as it checks the gas price of a transaction and can be bypassed by a malicious actor that submits a transaction with a higher gas price.
p192_1	1	deposit	Integer Overflow and Underflow	The deposit function is vulnerable to integer overflow and underflow issues due to the unsafe arithmetic operations when calculating the amount to mint.
p192_1	2	withdraw	Front-running	The withdraw function is vulnerable to front-running attacks, as an attacker can observe a pending transaction and then submit their own transaction with a higher gas price to withdraw before the victim.
p192_1	1	executeLimitOrder	Reentrancy	The 'executeLimitOrder' function interacts with an external contract through '_safeMint' before making important state changes, which might lead to reentrancy attacks.
p192_1	2	addToPosition	Integer Overflow/Underflow	The 'addToPosition' function can be susceptible to integer overflow when calculating 'int256(_newMargin*_trades[_id].leverage/1e18)'.
p192_1	3	setAccInterest	Integer Overflow/Underflow	The 'setAccInterest' function can be susceptible to integer overflow when calculating '_trades[_id].accInterest = trades(_id).accInterest'.
p192_1	4	reducePosition	Integer Overflow/Underflow	The 'reducePosition' function can be susceptible to integer underflow when calculating '_trades[_id].accInterest -= _trades[_id].accInterest*int256(_percent)/int256(DIVISION_CONSTANT)'.
p192_1	1	claim	Reentrancy	The 'claim' function is vulnerable to a reentrancy attack because it calls an external contract (IERC20.transfer) after updating the state (calling bondNFT.claim).
p192_1	2	claimDebt	Reentrancy	The 'claimDebt' function is vulnerable to a reentrancy attack because it calls an external contract (IERC20.transfer) after updating the state (calling bondNFT.claimDebt).
p192_1	3	release	Reentrancy	The 'release' function is vulnerable to a reentrancy attack because it calls an external contract (IERC20.transfer) after updating the state (calling bondNFT.release).
p192_1	1	release	Reentrancy	The 'release' function transfers tokens to the manager before burning the bond, which allows for reentrancy attacks where an attacker can repeatedly call the 'release' function before the bond is burned.
p192_1	2	setManager	Insecure access control	The 'setManager' function allows the contract owner to change the manager address at any time, which can lead to unauthorized access if the owner account is compromised.
p191_3	1	winnerClaimNFT	Reentrancy	The winnerClaimNFT function does not use the Checks-Effects-Interactions pattern, which might lead to potential reentrancy attacks.
p145_3	1	wrapETH2LD	Reentrancy	Reentrancy vulnerability occurs when external calls are made before updating the state. In this case, the contract calls 'registrar.transferFrom()' and 'registrar.reclaim()' before updating the state.
p145_3	2	unwrapETH2LD	Reentrancy	Reentrancy vulnerability occurs when external calls are made before updating the state. In this case, the contract calls 'registrar.transferFrom()' before updating the state.
p145_3	3	upgradeETH2LD	Reentrancy	Reentrancy vulnerability occurs when external calls are made before updating the state. In this case, the contract calls 'upgradeContract.wrapETH2LD()' before updating the state.
p145_3	4	upgrade	Reentrancy	Reentrancy vulnerability occurs when external calls are made before updating the state. In this case, the contract calls 'upgradeContract.setSubnodeRecord()' before updating the state.
p145_3	1	setSubnodeOwner	Missing input validation	The function setSubnodeOwner allows anyone to claim any unclaimed subnode, regardless of whether they have permission to do so.
p145_3	2	setRecord, setSubnodeRecord	Reentrancy	The functions setRecord and setSubnodeRecord are vulnerable to reentrancy attacks, as they call external contracts (resolvers) before updating the state.
p191_1	1	winnerClaimNFT()	Reentrancy Vulnerability	The `winnerClaimNFT()` function transfers the NFT to the winner before emitting the `WinnerSentNFT` event. If the NFT contract has a malicious implementation, it could call back into the `winnerClaimNFT()` function, allowing for reentrancy attacks and potentially stealing more NFTs.
p191_1	2	winnerClaimNFT()	Unsafe External Calls	The `winnerClaimNFT()` function transfers the NFT to the winner, which involves an external call to the NFT contract. If the NFT contract has a malicious implementation, it could cause unexpected behavior or allow for attacks.
p145_1	null
p145_1	1	wrapETH2LD	Reentrancy	The function wrapETH2LD does not follow the Checks-Effects-Interactions pattern, which makes it vulnerable to a reentrancy attack. The transfer of tokens (registrar.transferFrom) happens before the state change (_wrapETH2LD).
p143_1	1	claimFor	Reentrancy	The `claimFor` function updates the unclaimed balances first and then calls the `_token.mint()` function, which could potentially make external calls. This may expose the function to reentrancy attacks, allowing an attacker to call `claimFor` multiple times in a single transaction and claim more tokens than intended.
p143_1	2	mintFor	Integer Overflow	The `mintFor` function does not check for integer overflow when updating the unclaimed balances. An attacker can exploit this to create a large number of tokens, leading to incorrect token balances.
p143_1	3	burnFrom	Integer Overflow	The `burnFrom` function does not check for integer underflow when updating the unclaimed balances. An attacker can exploit this to burn a large number of tokens, leading to incorrect token balances.
p143_1	1	recordPaymentFrom	Reentrancy vulnerability	The function recordPaymentFrom is marked as nonReentrant which prevents reentrancy attacks, however, it calls an external contract (IJBFundingCycleDataSource) through the payParams function, which may lead to possible reentrancy attacks if an attacker creates a malicious IJBFundingCycleDataSource contract.
p143_1	null
p143_1	1	currentPrice	Integer Overflow	The function currentPrice does not check for integer overflow when adjusting decimals for the returned price.
p190_3	1	hook	Incorrect user-specific period reset	The hook function incorrectly uses a single global variable `lastUserPeriodReset` for all users, which leads to incorrect user-specific period reset and can cause incorrect withdrawal limits.
p190_3	2	setTreasury, setTokenSender	Unprotected function calls	Functions setTreasury and setTokenSender are public, making them callable by any address, potentially causing unauthorized changes.
p131_3	null
p190_2	1	hook	Reentrancy	The hook function is vulnerable to reentrancy attacks because it updates the state of userToAmountWithdrawnThisPeriod and globalAmountWithdrawnThisPeriod after executing external contract calls (collateral.getBaseToken().transferFrom and _tokenSender.send), which can be potentially malicious.
p190_2	2	hook	Integer Overflow	The hook function does not check for integer overflows in the expressions "globalAmountWithdrawnThisPeriod + _amountBeforeFee" and "userToAmountWithdrawnThisPeriod[_sender] + _amountBeforeFee", which may lead to unexpected behavior.
p131_2	1	mint	Reentrancy	The mint function can be potentially exploited through a reentrancy attack since the '_executeInflationRateUpdate()' function is called after 'token.mint()' function. The '_executeInflationRateUpdate()' function has an external call to 'controller.inflationManager().checkpointAllGauges()', which can potentially call back into the 'mint' function.
p125_3	1	withdrawCollateral	Reentrancy	The 'withdrawCollateral' function can potentially be exploited through a reentrancy attack, since external calls are made before updating the state.
p125_3	2	withdrawCollateral	Integer Overflow	The calculation of '_amount' can lead to integer overflow if 'uint256' is maxed out when the function is called. This could result in an incorrect amount being withdrawn.
p125_3	1	_withdrawFromYieldPool	Reentrancy	There is no reentrancy guard in the _withdrawFromYieldPool function, which may lead to a reentrancy attack when calling external contracts, such as the CurveswapAdapter.
p125_3	2	processYield	Integer Underflow	The subtraction of treasuryStETH from yieldStETH can lead to an integer underflow if treasuryStETH is greater than yieldStETH.
p125_3	3	_depositToYieldPool	Inadequate Checks	The function does not validate if the _amount is greater than 0, which can lead to unintended behavior.
p122_3	1	withdraw	Reentrancy	The `withdraw` function is vulnerable to reentrancy attacks due to the `harvest` function being called before the asset transfer. An attacker could exploit this vulnerability by creating a malicious contract that calls back into the `withdraw` function before the asset transfer is complete, allowing them to drain the contract's assets.
p113_3	1	lend	Reentrancy	The 'lend' function transfers the asset to the borrower before updating the state of the loan, which can potentially allow for reentrancy attacks.
p113_3	2	repay	Reentrancy	The 'repay' function transfers the asset to the lender before deleting the state of the loan, which can potentially allow for reentrancy attacks.
p125_2	1	processYield	Reentrancy	The processYield function contains external calls to untrusted contracts (CurveswapAdapter, IWETH) before updating the state. This can lead to reentrancy attacks.
p125_2	2	_depositToYieldPool	Integer Overflow	The function does not check for integer overflows when adding assetAmount to msg.value, which may result in incorrect calculations.
p125_2	3	_withdrawFromYieldPool	Front-running	The function uses a hardcoded slippage value (200) when calling the CurveswapAdapter, making it vulnerable to front-running attacks.
p125_2	1	withdrawCollateral	Reentrancy	The withdrawCollateral function can potentially be exploited through a reentrancy attack since external calls are made to untrusted contracts before state updates.
p123_2	1	_addReward	Reentrancy	The '_addReward' function is marked as nonReentrant, but it contains a call to an external contract via the `IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);`. This could potentially lead to a reentrancy attack.
p123_2	2	_claimableRewards	Integer Overflow	In the '_claimableRewards' function, the calculation `(balance * rewardData[_token][_epoch]) / 1e20` can potentially cause integer overflow if the balance or rewardData values are very large.
p122_2	1	withdraw	Reentrancy	The withdraw function first calls the harvest function, which sends Ether to msg.sender, and then it transfers tokens from the contract to msg.sender. This allows for reentrancy attacks where an attacker can call back into the contract to withdraw tokens multiple times before the state is updated.
p122_2	2	createVault	Insecure randomness	The vaultIndex is incremented by 2 for each new Vault, making it predictable. An attacker could predict the next vaultId, potentially allowing them to front-run other users.
p122_2	3	buyOption	Unchecked return value	The forceTransfer call in the buyOption function does not check the return value. If the transfer fails, the option will not be transferred, but the rest of the buyOption function will still execute.
p115_2	1	executeOperation	Reentrancy	The function calls external contracts (lendingPool and router.call(dexTxData)) before transferring the funds, which might allow an attacker to re-enter the function and manipulate the state.
p115_2	2	depositToVault, depositETHToVault, depositAndBorrowFromVault, depositETHAndBorrowFromVault	Lack of input validation	The functions do not validate if the depositAmount or msg.value is greater than zero, allowing users to deposit zero amounts and potentially causing unexpected behavior.
p115_2	3	leverageSwap	Unbounded token approval	The function approves the maximum possible token amount (2**256 - 1) for a.core(), potentially allowing malicious contracts to drain the user's tokens.
p115_2	1	executeOperation	Reentrancy Vulnerability	The function is not protected against reentrancy attacks, which can be exploited by an attacker to manipulate state variables and drain funds.
p115_2	2	leverageSwap	Unbounded Approval	The function approves an unlimited token allowance (2**256 - 1) to the core, which can be exploited by malicious contracts to drain tokens.
p115_2	3	aggregatorSwap	Unsafe External Calls	The function uses a low-level call (router.call(dexTxData)) without checking the return value, allowing an attacker to manipulate the execution flow.
p113_2	1	repay	Reentrancy vulnerability	The repay function allows an attacker to perform a reentrancy attack due to the incorrect order of operations, such as transferring the collateral to the borrower before updating the state variables.
p113_2	2	_call	Unchecked return value	The _call function does not check the return value of the external call. This can lead to unexpected behavior and potential asset loss if the external call fails.
p112_3	1	unstakeFor	Reentrancy	The `unstakeFor` function is vulnerable to reentrancy attacks because it transfers the unstaked tokens to the destination address before updating the state variables (balances and _poolTotalStaked or strategiesTotalStaked).
p109_3	1	swap	Reentrancy	The 'swap' function is vulnerable to a reentrancy attack because it transfers tokens to an external contract (recipient) after performing state changes but before updating the contract's balance.
p109_3	2	swap	Lack of input validation	The 'swap' function does not validate the 'amount' parameter, allowing users to input zero or negative values. This could lead to undesired behavior or token loss.
p109_3	3	swap	Arbitrary token conversion rate	The 'swap' function uses a fixed conversion rate (2:1 or 1:2) for token swaps, which may not accurately represent the market value of the tokens. This can lead to exploitation and arbitrage opportunities.
p109_3	1	_burnTokenFrom	Reentrancy	The `_burnTokenFrom` function is vulnerable to reentrancy attacks because it calls external contracts (through `_callERC20Token`) before updating the internal state. An attacker can potentially exploit this by causing the external call to re-enter the contract and perform malicious actions.
p109_3	2	_mintToken	Reentrancy	The `_mintToken` function is vulnerable to reentrancy attacks because it calls external contracts (through `_callERC20Token`) before updating the internal state. An attacker can potentially exploit this by causing the external call to re-enter the contract and perform malicious actions.
p109_3	3	_burnToken	Reentrancy	The `_burnToken` function is vulnerable to reentrancy attacks because it calls external contracts (through `depositHandler.execute`) before updating the internal state. An attacker can potentially exploit this by causing the external call to re-enter the contract and perform malicious actions.
p112_2	1	unstakeFor	Reentrancy	The `unstakeFor` function transfers tokens to the destination address before updating the balances, which may lead to reentrancy attacks.
p112_2	2	addStrategy	Missing access control	The `addStrategy` function is missing access control, allowing anyone to register a strategy.
p110_2	1	reportAdditionalToken	Reentrancy	The function `reportAdditionalToken` is not safe against reentrancy attacks since it transfers tokens before updating the internal state. An attacker can call the function recursively to drain the contract's funds.
p110_2	2	earn	Unauthorized Access	The `earn` function can be called by anyone, allowing them to transfer the available tokens to the strategy. This can lead to unauthorized token transfers and potentially loss of funds.
p110_2	3	getPricePerFullShare	Overflow	The function `getPricePerFullShare` can potentially cause an overflow when multiplying `balance()` and `ONE_ETH`. This could lead to incorrect share price calculations and loss of funds.
p109_2	1	sendToken	Reentrancy	The 'sendToken' function burns tokens and emits an event in a single transaction, opening up the possibility of reentrancy attacks. An attacker can exploit this by using a malicious contract to call the function recursively.
p109_2	2	_approveContractCall	Missing input validation	The '_approveContractCall' function does not check if the contract call is already approved or executed, which allows an attacker to approve a call multiple times or change the payload hash of a previously approved call.
p109_2	1	swap	Reentrancy	The `swap` function is vulnerable to a reentrancy attack. After transferring the input tokens to the contract, it immediately sends the converted tokens to the recipient. If the recipient is a malicious contract, it can call the `swap` function again before the first call is completed, leading to unexpected behavior and potentially asset loss.
p107_2	1	unlock	Reentrancy	The `unlock` function is marked as `nonReentrant`, but it uses `SafeERC20.safeTransfer()` which can call into external contracts, potentially causing reentrancy attacks.
p104_3	1	transferSplitAsset	Reentrancy	The transferSplitAsset function calls IERC20.transfer(), which might allow the recipient to attempt a limited reentrancy attack when interacting with a malicious token contract.
p104_3	2	attemptETHTransfer	Reentrancy	The attemptETHTransfer function makes a call to the recipient address with a higher gas limit, which might allow the recipient to attempt a reentrancy attack.
p104_3	1	withdraw()	Reentrancy	The `withdraw()` function allows the contract owner to withdraw the funds generated by token sales. However, the `payableToken.transferFrom()` function could potentially make a call to an untrusted contract, which might perform reentrant attacks.
p104_2	1	withdraw()	Reentrancy	The `withdraw()` function is vulnerable to a reentrancy attack because it calls an external contract (`payableToken.transferFrom`) before updating the contract state.
p104_2	2	batchMint()	No max limit on the batch minting	The `batchMint()` function allows for a large number of tokens to be minted at once, which could cause high gas costs or even run out of gas if `_amount` is too large.
p104_2	1	attemptETHTransfer	Reentrancy	The function attemptETHTransfer has a comment warning about potential reentrancy attacks. An attacker could exploit this by creating a malicious contract that calls back into the vulnerable contract, draining funds.
p103_2	1	swapTokensGeneric	Reentrancy	The `swapTokensGeneric` function is vulnerable to reentrancy attacks as it performs external calls (transferAsset) after updating the contract's state (postSwapBalance calculation) but before the function is completed. An attacker can call back into the contract and manipulate its state during execution, potentially causing asset loss.
p103_2	1	swap	Reentrancy	The `swap` function is vulnerable to reentrancy attacks as it performs a low-level call (`_swapData.callTo.call{ value: msg.value }(_swapData.callData)`) that could potentially call back into the contract and manipulate its state during execution, causing asset loss.
p100_3	null
p102_2	1	fulfill	Reentrancy	The 'fulfill' function allows the oracle to update the CPI data. However, there is a potential risk of reentrancy attack as there is no mutex or reentrancy guard in place.
p102_2	2	requestCPIData	Incorrect Access Control	The 'requestCPIData' function is callable by anyone, which may lead to spam or malicious requests, increasing the costs for the contract owner.
p100_2	1	deposit	Integer Overflow	In the deposit function, the calculation of the minting fee, `_fee`, can potentially result in an integer overflow if `_amountToDeposit` is large enough.
p100_2	2	withdraw	Integer Overflow	In the withdraw function, the calculation of the redemption fee, `_fee`, can potentially result in an integer overflow if `_amountWithdrawn` is large enough.
p97_3	1	withdraw	Reentrancy	The `withdraw` function is vulnerable to reentrancy due to the use of the `lpToken.safeTransferFrom` function before updating the state.
p97_3	2	reclaimTokens	Reentrancy	The `reclaimTokens` function is vulnerable to reentrancy due to the use of the `IERC20Upgradeable(_token).safeTransfer` function before the `nonReentrant` modifier.
p97_3	1	sendFundsToUser	Reentrancy	The sendFundsToUser function is vulnerable to reentrancy attacks. Even though the contract is using ReentrancyGuard, this function is not protected with the nonReentrant modifier. An attacker could use a fallback function in a malicious contract to call the sendFundsToUser function again before the state is updated, allowing multiple withdrawals with only one deposit.
p97_3	2	depositErc20, depositNative	Front-Running	The depositErc20 and depositNative functions are vulnerable to front-running attacks. An attacker can monitor the transaction pool and submit their transaction with a higher gas price, causing their transaction to be executed before the original transaction. This can lead to asset loss or manipulation of token prices.
p98_3	1	executeMetaTransaction	Reentrancy	The `executeMetaTransaction` function is vulnerable to reentrancy attacks because it makes an external call using `address(this).call()` before updating the nonce and emitting an event. A malicious contract can potentially use this vulnerability to execute multiple meta transactions with the same nonce.
p98_3	null
p98_2	null
p98_2	1	executeMetaTransaction	Reentrancy	The `executeMetaTransaction` function is susceptible to reentrancy attacks since it makes an external call to `address(this).call` before updating the nonce, allowing an attacker to recursively call the same function with the same nonce.
p97_2	1	reclaimTokens	Reentrancy	The function `reclaimTokens` can lead to reentrancy attacks when called with the `_token` parameter set to NATIVE. This is because it performs an external call to transfer tokens to the specified `_to` address, and then performs state changes.
p97_2	2	_sendRewardsForNft	Reentrancy	The function `_sendRewardsForNft` can lead to reentrancy attacks when the reward token is NATIVE. This is because it performs an external call to transfer the reward to the specified `_to` address, and then performs state changes.
p97_2	3	deposit	Reentrancy	The function `deposit` can lead to reentrancy attacks due to an external call to the `safeTransferFrom` function. An attacker can create a malicious contract that triggers a callback to the HyphenLiquidityFarming contract when `safeTransferFrom` is called.
p97_2	4	withdraw	Reentrancy	The function `withdraw` can lead to reentrancy attacks due to an external call to the `safeTransferFrom` function. An attacker can create a malicious contract that triggers a callback to the HyphenLiquidityFarming contract when `safeTransferFrom` is called.
p97_2	5	extractRewards	Reentrancy	The function `extractRewards` can lead to reentrancy attacks due to an external call to `_sendRewardsForNft`. An attacker can create a malicious contract that triggers a callback to the HyphenLiquidityFarming contract when `_sendRewardsForNft` is called.
p97_2	1	sendFundsToUser	Reentrancy	The sendFundsToUser function is vulnerable to reentrancy attacks. The function updates the state variables after executing external calls (transfer of funds), which can be exploited by an attacker.
p97_2	2	depositErc20	Reentrancy	The depositErc20 function is vulnerable to reentrancy attacks. The function updates the state variables after executing external calls (transfer of tokens), which can be exploited by an attacker.
p96_2	1	mint, burn, lend, withdraw, borrow, pay, collectProtocolFee	Reentrancy vulnerability	The functions use the 'lock' modifier, which is intended to prevent reentrancy attacks. However, the 'Callback' functions called within these functions can potentially call back into the contract, leading to a reentrancy vulnerability.
p94_2	null
p94_2	1	_distributeFunds	Reentrancy	The _distributeFunds function is vulnerable to reentrancy attacks because it updates the _nftContractToTokenIdToFirstSaleCompleted mapping after transferring the funds. If any of the recipients are malicious contracts, they can call back into the contract before the state is updated, causing asset loss.
p94_2	1	placeBidOf	Reentrancy	The 'placeBidOf' function is vulnerable to reentrancy attacks as it first updates the contract state (auction amount and bidder) and then performs external calls (_sendValueWithFallbackWithdraw) without using a mutex or a check to prevent reentrancy.
p94_2	2	finalizeReserveAuction	Reentrancy	The '_finalizeReserveAuction' function is vulnerable to reentrancy attacks due to the external call to '_distributeFunds' which makes a transfer of funds, while the contract state (deletion of auction mappings) is not fully updated.
p39swivel_3	1	withdraw	Reentrancy	The 'withdraw' function allows the admin to withdraw tokens from the contract. However, it does not implement a reentrancy guard, which may result in potential reentrancy attacks.
p39swivel_3	2	initiateVaultFillingZcTokenInitiate, initiateZcTokenFillingVaultInitiate, initiateZcTokenFillingZcTokenExit, initiateVaultFillingVaultExit, exitZcTokenFillingZcTokenInitiate, exitVaultFillingVaultInitiate, exitVaultFillingZcTokenExit, exitZcTokenFillingVaultExit, splitUnderlying, combineTokens, redeemZcToken	Unchecked return values	In multiple functions, the contract relies on external contract calls like 'transferFrom', 'approve', and 'mint' without checking their return values, which can lead to unexpected behavior or token loss if the called functions fail.
p39swivel_2	1	withdraw	Reentrancy	The withdraw function allows the admin to withdraw tokens from the contract, but it doesn't have proper protection against reentrancy attacks. An attacker can potentially create a malicious token contract that calls back into the withdraw function, enabling them to drain the contract's funds.
p39_3	1	transferNotionalFrom	Reentrancy	This function is vulnerable to a reentrancy attack, where a malicious contract could call back into the function before the state is updated, allowing the attacker to drain the vault.
p39_3	2	addNotional	Integer Overflow	The calculation of interest in addNotional function may lead to integer overflow when calculating yield and interest.
p39_3	3	transferNotionalFee	Integer Underflow	The subtraction of notional amount in transferNotionalFee function may lead to integer underflow if the amount is larger than the notional balance of the owner.
p39swivel_1	1	withdraw	Reentrancy	The `withdraw` function transfers tokens to the admin before setting the withdrawal state to zero, making it susceptible to a reentrancy attack where the admin could call the function multiple times before the state is updated.
p39swivel_1	2	initiateVaultFillingZcTokenInitiate, initiateZcTokenFillingVaultInitiate, initiateZcTokenFillingZcTokenExit, initiateVaultFillingVaultExit, exitZcTokenFillingZcTokenInitiate, exitVaultFillingVaultInitiate, exitVaultFillingZcTokenExit, exitZcTokenFillingVaultExit	Integer Overflow	The functions calculate principalFilled, premiumFilled, and fee using unchecked multiplication and division operations, which can lead to integer overflow or underflow.
p39swivel_1	3	initiate, exit	Front-Running	The `initiate` and `exit` functions process multiple orders in a loop, which can be exploited by a front-runner to manipulate the order in which transactions are executed, impacting the prices and fees paid by users.
p39_2	1	transferNotionalFrom	Reentrancy Vulnerability	The transferNotionalFrom function updates the vault states after external calls to CErc20(cTokenAddr).exchangeRateCurrent(), which can potentially lead to reentrancy attacks if the CErc20 contract is malicious.
p39_2	2	transferNotionalFee	Reentrancy Vulnerability	The transferNotionalFee function updates the vault states after external calls to CErc20(cTokenAddr).exchangeRateCurrent(), which can potentially lead to reentrancy attacks if the CErc20 contract is malicious.
p39_1	1	transferNotionalFrom	Reentrancy	The function transferNotionalFrom updates the sender's vault before the recipient's vault, making it vulnerable to reentrancy attacks.
p39_1	2	transferNotionalFee	Integer Underflow	transferNotionalFee subtracts the amount directly from the owner's vault without checking if the owner has enough balance, which can lead to integer underflow.
p39_1	3	removeNotional	Integer Underflow	removeNotional subtracts the amount directly from the user's vault without checking if the user has enough balance, which can lead to integer underflow.
p38_3	1	tipMiner	Reentrancy	The `tipMiner` function uses `executeCall` which calls external contracts (the miner in this case) and sends ETH to them. This creates a potential reentrancy vulnerability.
p38_3	2	setAddrPrivilege	Access Control	The `setAddrPrivilege` function allows an attacker to downgrade their own privileges after performing malicious actions, avoiding the anti-bricking mechanism.
p38_3	3	execute	Signature Validation	In the `execute` function, the signature recovery is using `recoverAddrImpl` from `SignatureValidator`. This might allow signature malleability attacks if the validation is not done correctly.
p38_3	1	send()	Reentrancy	Reentrancy attack can be performed by calling `identity.executeBySender(txns)` when one of the transactions in the `txns` array calls back into the `QuickAccManager` contract.
p38_3	2	execScheduled()	Reentrancy	Reentrancy attack can be performed by calling `identity.executeBySender(txns)` when one of the transactions in the `txns` array calls back into the `QuickAccManager` contract.
p38_3	3	sendTransfer()	Reentrancy	Reentrancy attack can be performed by calling `identity.executeBySender(txns)` when one of the transactions in the `txns` array calls back into the `QuickAccManager` contract.
p38_3	4	sendTxns()	Reentrancy	Reentrancy attack can be performed by calling `identity.executeBySender(identityTxns)` when one of the transactions in the `identityTxns` array calls back into the `QuickAccManager` contract.
p37_3	1	swap	No slippage protection in swap function	The swap function does not include any slippage protection, which means that users could be subject to front-running attacks or unfavorable exchange rates.
p36_3	1	mint, mintTo, burn, auctionBurn	Reentrancy	The mint, mintTo, burn, and auctionBurn functions call handleFees() which performs a token transfer, making the contract vulnerable to reentrancy attacks.
p36_3	2	handleFees	Integer Overflow	The fee calculation in the handleFees function can potentially cause an integer overflow as no safe math is being used.
p35_3	1	claimReward	Reentrancy Vulnerability	The `claimReward` function is vulnerable to reentrancy attacks because it calls an external contract `_transfer` before updating the state variables `incentive.rewardsUnclaimed`, `incentive.secondsClaimed`, and `stake.secondsInsideLast`.
p35_3	2	subscribe, claimReward, getReward	Incorrect Mapping Key	The functions `subscribe`, `claimReward`, and `getReward` incorrectly use `positionId` as the key for `incentives` mapping. It should use `incentiveId` instead.
p35_3	null
p34_3	1	calculate	Reentrancy	The calculate function retrieves data from external contracts, like drawBuffer.getDraws, prizeDistributionBuffer.getPrizeDistributions, and ticket.getAverageBalancesBetween, which may call untrusted contracts. This can cause a reentrancy vulnerability if any of these external calls have fallback functions that re-enter the calculate function.
p38_2	1	tipMiner	Reentrancy	The tipMiner function can be exploited by a malicious miner to drain the contract's balance by recursively calling the function via a fallback function in a malicious contract set as the coinbase address.
p38_2	2	execute	Incorrect access control	The execute function allows a signer to potentially downgrade their own privileges during a batch transaction by calling setAddrPrivilege, which can lead to accidental privilege loss.
p38_2	3	executeBySender	Incorrect access control	Similar to the execute function, the executeBySender function allows a sender to potentially downgrade their own privileges during a batch transaction by calling setAddrPrivilege, which can lead to accidental privilege loss.
p38_2	1	send	Reentrancy vulnerability	The send() function calls identity.executeBySender() which can execute arbitrary contract calls, allowing for reentrancy attacks.
p38_2	2	sendTransfer, sendTxns	Front-running vulnerability	The sendTransfer() and sendTxns() functions update the nonce after the identity.executeBySender() call, allowing front-runners to exploit the gap between the nonce check and update.
p37_2	1	depositYieldBearing	Reentrancy	The depositYieldBearing function is marked as nonReentrant, but it does not prevent reentrancy attacks as it uses the untrustedTransferFrom function from the UntrustedERC20 library, which allows a malicious token contract to execute arbitrary code during the transfer.
p37_2	2	depositBacking	Reentrancy	The depositBacking function is marked as nonReentrant, but it does not prevent reentrancy attacks as it uses the untrustedTransferFrom function from the UntrustedERC20 library, which allows a malicious token contract to execute arbitrary code during the transfer.
p36_2	1	mint, mintTo, burn, auctionBurn	Reentrancy	The functions 'mint', 'mintTo', 'burn', and 'auctionBurn' call 'handleFees' which transfers tokens to external addresses. An attacker may use this for a reentrancy attack by implementing a malicious ERC20 contract.
p36_2	2	handleFees	Integer Overflow	In 'handleFees', the calculation of 'feePct' may overflow if 'timeDiff' and 'licenseFee' are large values.
p35_2	1	claimReward	Reentrancy	The claimReward function updates the state after transferring tokens, which could allow for reentrancy attacks if the token contract has malicious code.
p35_2	2	subscribe	Incorrect mapping access	The subscribe function uses positionId instead of incentiveId to access the incentive mapping, which could result in incorrect behavior.
p35_2	3	claimReward	Incorrect mapping access	The claimReward function uses positionId instead of incentiveId to access the incentive mapping, which could result in incorrect behavior.
p35_2	4	getReward	Incorrect mapping access	The getReward function uses positionId instead of incentiveId to access the incentive mapping, which could result in incorrect behavior.
p35_2	null
p34_2	1	calculate	Reentrancy	The function 'calculate' allows external calls to 'getDraws', 'getPrizeDistributions', and 'getAverageBalancesBetween' which can cause potential reentrancy attacks if the called contracts are malicious.
p34_2	2	_calculateNumberOfUserPicks	Integer Overflow	The function '_calculateNumberOfUserPicks' has a multiplication operation that may lead to integer overflow if '_normalizedUserBalance' and '_prizeDistribution.numberOfPicks' are large values.
p38_1	1	tipMiner	Reentrancy	The `tipMiner` function does not have a reentrancy guard, and although it mentions that the contract is generally reentrancy proof due to nonce, the nonce is not used in this function, which might make it vulnerable to reentrancy attacks.
p38_1	2	execute	Front-running	The `execute` function is vulnerable to front-running attacks as an attacker can observe the transaction and submit their own transaction with a higher gas price, potentially changing the state of the contract before the original transaction is executed.
p38_1	1	send	Front-running	In the send function, if only one signer is required for scheduling a transaction, the transaction's details are publicly visible on the blockchain before it is executed. A malicious miner or an attacker can front-run the transaction by submitting their own transaction with a higher gas price, potentially causing asset loss.
p38_1	2	execScheduled	Reentrancy	The execScheduled function calls the external contract function executeBySender, which can potentially call back into the QuickAccManager contract, leading to a reentrancy attack. This can result in unexpected behavior and potential asset loss.
p37_1	null
p36_1	1	mint, mintTo, burn, auctionBurn, changePublisher, changeLicenseFee, publishNewIndex, setNewWeights, deleteNewIndex	Reentrancy	The contract lacks reentrancy protection on functions that make external calls or transfer tokens which can result in potential reentrancy attacks.
p36_1	2	handleFees	Integer Overflow	The fee calculation in the handleFees function is vulnerable to integer overflow when multiplying large values.
p35_1	1	subscribe	Incorrect mapping index usage	The `incentive` variable is incorrectly indexed by `positionId` instead of `incentiveId` in the `subscribe` function, which may lead to incorrect incentives being subscribed to.
p35_1	2	claimReward	Incorrect mapping index usage	The `incentive` variable is incorrectly indexed by `positionId` instead of `incentiveId` in the `claimReward` function, which may lead to incorrect incentives being claimed.
p35_1	3	getReward	Incorrect mapping index usage	The `incentive` variable is incorrectly indexed by `positionId` instead of `incentiveId` in the `getReward` function, which may lead to incorrect rewards being calculated.
p35_1	null
p34_1	1	_calculatePrizesAwardable	Reentrancy	The function _calculatePrizesAwardable calculates the prizes awardable for a user but does not employ proper reentrancy protection. This can lead to a reentrancy attack, where an attacker can repeatedly call the function to drain funds.
p60_3	1	debitAccount	Integer Overflow and Underflow	The function debitAccount is vulnerable to integer underflow if the amount to be debited is greater than the current balance of the account.
p60_3	2	settleAccount	Integer Overflow and Underflow	The function settleAccount is vulnerable to integer overflow when adding the amount to the newBalance variable and underflow when subtracting the shortfall.
p60_3	3	debit	Integer Overflow and Underflow	The function debit is vulnerable to integer underflow if the amount to be debited is greater than the current total balance.
p60_3	4	resolve	Integer Overflow and Underflow	The function resolve is vulnerable to integer underflow when subtracting the amount from the shortfall and overflow when adding the amount to the total.
p60_3	1	liquidate	Reentrancy	The liquidate function allows for potential reentrancy attacks because it transfers the fee to the attacker before emitting the Liquidation event.
p60_3	2	withdrawTo	Underflow	The debitAccount function used in withdrawTo can lead to underflow errors when the amount to be withdrawn is greater than the account balance.
p60_1	1	liquidate	Reentrancy	The liquidate function has a nonReentrant modifier, but it calls an external function `product.settle()` before the nonReentrant modifier. An attacker may manipulate the external call to re-enter the liquidate function before the state is updated.
p60_1	null
p59_3	1	exitEarly	Reentrancy	The exitEarly function allows users to exit auctions early, but it has a reentrancy vulnerability due to the ERC20 transfer at the end of the function. A malicious token contract could trigger unexpected behavior by calling back into the contract.
p59_3	2	exitEarly	Front-running	The exitEarly function uses the notSameBlock modifier to prevent same-block attacks. However, this only mitigates the risk partially. Front-runners can still exploit the function by observing pending transactions and placing their own transactions with higher gas prices to execute before the original ones.
p59_3	3	earlyExitReturn	Unbounded Loop	The earlyExitReturn function has a potential unbounded loop issue due to the use of the SafeMath library. This could cause high gas usage, making the function expensive to call and potentially exceeding the block gas limit.
p59_3	1	buyMalt	Reentrancy	The buyMalt function interacts with an external contract (router.swapExactTokensForTokens) after modifying the contract state (updating the rewardToken balance).
p59_3	2	sellMalt	Reentrancy	The sellMalt function interacts with an external contract (router.swapExactTokensForTokens) after modifying the contract state (updating the malt balance).
p59_3	3	addLiquidity	Reentrancy	The addLiquidity function interacts with an external contract (router.addLiquidity) after modifying the contract state (updating malt and rewardToken balances).
p59_3	4	removeLiquidity	Reentrancy	The removeLiquidity function interacts with an external contract (router.removeLiquidity) after modifying the contract state (updating lpToken balance).
p59_3	null
p59_3	null
p59_1	1	getAverageParticipation	Integer Overflow	When adding up the commitments and maxCommitments in the for loop, the variables can potentially overflow.
p59_1	2	getRealBurnBudget	Integer Underflow	When subtracting premiumExcess from maxBurnSpend, there is a possibility of underflow.
p59_1	null
p59_1	1	buyMalt, sellMalt, addLiquidity, removeLiquidity	Front-running	The functions buyMalt, sellMalt, addLiquidity, and removeLiquidity use 'now' as the deadline for the swaps and liquidity interactions. This could make the contract vulnerable to front-running attacks, where an attacker can see the pending transaction and manipulate the prices to their advantage.
p59_1	1	exitEarly	Reentrancy	The `exitEarly` function calls an external contract (`dexHandler.sellMalt()`) before transferring the tokens to the user. This could potentially allow for a reentrancy attack.
p58_1	1	_pull	Reentrancy	The '_pull' function calls the external 'withdraw' function from the Aave Lending Pool, which might trigger the 'to' address to call back into the AaveVault contract before updating the '_tvls' variable.
p58_1	2	_allowTokenIfNecessary	Integer Overflow	The function checks if the allowance is less than 'type(uint256).max / 2', which might cause an overflow when calculating the allowance.
p58_1	0	N/A	None	No high-risk bugs were found in the provided Solidity smart contract code that would cause asset loss or make it exploitable.
p58_1	1	deployVault	Reentrancy	deployVault function is vulnerable to reentrancy attacks due to external calls to untrusted contracts (ILpIssuer and registry.safeTransferFrom).
p58_1	1	collectEarnings	Reentrancy	The collectEarnings function is susceptible to reentrancy attacks since it transfers the collected earnings to the recipient before emitting the CollectedEarnings event.
p56_2	1	update	Reentrancy	The 'update' function modifies the state of the CDP.Data struct without taking reentrancy into consideration, potentially allowing a malicious contract to reenter the function and change the state before the previous call has completed.
p56_1	1	update	Reentrancy	The `update` function updates the state of the CDP by calculating the earned yield and adjusting the total debt and total credit without any reentrancy guard. This can potentially lead to reentrancy attacks if a malicious contract is called within the same transaction.
p56_1	2	getEarnedYield	Integer Overflow	The `getEarnedYield` function calculates the earned yield by subtracting the last accumulated yield weight from the current accumulated yield weight and multiplying the result with the total deposited amount. This can potentially lead to an integer overflow if the multiplication result is greater than the maximum value of a uint256.
p54_1	1	recordKeyPurchase	Reentrancy	The function allows for external calls to `udtOracle.updateAndConsult()` and `IMintableERC20(udt).transfer()`, which could be exploited by a malicious contract to re-enter the `recordKeyPurchase()` function and potentially cause asset loss.
p54_1	2	recordKeyPurchase	Arithmetic Overflow/Underflow	There are multiple arithmetic operations in the function, such as `valueInETH = _value;` and `grossNetworkProduct = grossNetworkProduct + valueInETH;`, which can result in overflow or underflow.
p54_1	3	setOracle	Missing input validation	The function allows setting the oracle address without checking if the provided address is a valid contract or not. This could lead to unexpected behavior and potential asset loss.
p54_1	4	recordKeyPurchase	Unchecked external call return values	The function calls `IMintableERC20(udt).transfer()` and `IMintableERC20(udt).mint()` without checking their return values, which could lead to undetected failures and potential asset loss.
p54_1	1	setKeyManagerOf	Missing input validation	The function setKeyManagerOf allows an attacker to set the key manager to any address, including the zero address.
p54_1	2	_timeMachine	Reentrancy	The function _timeMachine emits an event before updating the key's expirationTimestamp, which can lead to a reentrancy attack if an external contract relies on this event.
p54_1	1	purchase	Reentrancy	The `purchase` function is vulnerable to reentrancy attacks since it calls external contracts (token transfer and onKeyPurchaseHook) before updating the state. An attacker can potentially exploit this to recursively call the `purchase` function and drain the contract's funds.
p54_1	2	purchase	Front-Running	The `purchase` function is vulnerable to front-running attacks, as an attacker can monitor pending transactions and submit a transaction with a higher gas price to get their transaction executed first. This can lead to the attacker purchasing a key at a lower price before the price is updated.
p54_1	1	shareKey	Reentrancy	The `shareKey` function is vulnerable to reentrancy attacks due to external calls to untrusted contracts via the `require(_checkOnERC721Received(keyOwner, _to, _tokenId, ''), 'NON_COMPLIANT_ERC721_RECEIVER');` statement.
p54_1	2	transferFrom	Reentrancy	The `transferFrom` function is vulnerable to reentrancy attacks due to external calls to untrusted contracts via the `emit Transfer(_from, _recipient, _tokenId);` statement.
p54_1	3	safeTransferFrom (with 3 arguments)	Reentrancy	The `safeTransferFrom` function is vulnerable to reentrancy attacks due to external calls to untrusted contracts via the `safeTransferFrom(_from, _to, _tokenId, '');` statement.
p54_1	4	safeTransferFrom (with 4 arguments)	Reentrancy	The `safeTransferFrom` function is vulnerable to reentrancy attacks due to external calls to untrusted contracts via the `require(_checkOnERC721Received(_from, _to, _tokenId, _data), 'NON_COMPLIANT_ERC721_RECEIVER');` statement.
p54_1	1	_cancelAndRefund	Reentrancy	The _cancelAndRefund function can be exploited by a malicious onKeyCancelHook contract to cause a reentrancy attack, as the _transfer function call is made before the hook is called.
p53_3	1	mint	Front-Running Attack	The mint function is called by mintWithMetadata, and it creates new tokens with sequential tokenIds. An attacker can monitor pending transactions and front-run a legitimate mint transaction, potentially getting the tokenId that was intended for the victim.
p53_3	1	releaseToken	Reentrancy	Although ReentrancyGuard is used, it only protects nonReentrant functions. A potential reentrancy vulnerability exists in the releaseToken function as it calls the external _token.safeTransfer function before emitting the PaymentReleased event.
p53_3	1	receive()	Reentrancy	The receive() function allows an attacker to re-enter the contract and potentially withdraw assets multiple times before the balance is updated.
p53_3	2	_submitOrder()	Unchecked return values	The return values of the external calls made using callOperator() are not checked, which may lead to unexpected results.
p53_3	3	increaseLockTimestamp()	Lack of input validation	The function does not check if the new timestamp is greater than the current one, allowing a user to potentially decrease the lock time.
p53_2	1	receive()	Reentrancy	The receive() function is unprotected and allows anyone to send Ether to the contract. If the contract's Ether balance is used in any way, this might cause unexpected behavior or be exploited by an attacker.
p53_2	2	increaseLockTimestamp()	Lack of input validation	The function increaseLockTimestamp() can be called by the NFT owner to increase the lock timestamp. However, there is no validation to ensure the new timestamp is greater than the current one, allowing the owner to decrease the lock time.
p53_2	3	unlockTokens()	Unprotected Ether withdrawal	The function unlockTokens() allows the owner to withdraw any ERC20 tokens from the contract without restrictions. This could potentially be exploited by the contract owner to drain the contract's assets.
p53_2	1	burn	Access Control	The `burn` function is missing a check to ensure that only the original owner of an asset can burn it. An attacker could potentially burn assets of other users by calling the function with a supported factory.
p53_2	null
p53_1	null
p53_1	1	mint, mintWithMetadata	Front-Running	An attacker can observe a pending transaction to mint a new NFT and front-run it by submitting a similar transaction with a higher gas price. This can allow the attacker to obtain NFTs with desired token IDs before the original user.
p53_1	1	receive()	Reentrancy	The receive() function allows anyone to send Ether directly to the contract without any conditions. An attacker could potentially use this to create a reentrancy attack by sending Ether to the contract before calling a function, leading to a loss of assets.
p53_1	2	increaseLockTimestamp(uint256 _nftId, uint256 _timestamp)	No input validation	The increaseLockTimestamp function allows the owner of an NFT to increase its lock timestamp, but it doesn't check if the new timestamp is greater than the current timestamp. This can lead to an incorrect lock timestamp update and unintended consequences.
p52_2	1	calculateSlipAdjustment	Division by Zero	The function can cause a division by zero error when both `vaderDeposited` and `vaderBalance` are zero, or both `assetDeposited` and `assetBalance` are zero.
p52_2	2	calculateSwap	Division by Zero	The function can cause a division by zero error when the sum of `amountIn` and `reserveIn` is zero.
p52_2	3	calculateSwapReverse	Division by Zero	The function can cause a division by zero error when `amountOut` is zero.
p52_2	1	mint	Reentrancy	The 'mint' function does not update the reserves before transferring tokens, allowing for a reentrancy attack to exploit this vulnerability.
p52_2	2	_burn	Reentrancy	The '_burn' function does not update the reserves before transferring tokens, allowing for a reentrancy attack to exploit this vulnerability.
p52_2	3	swap	Reentrancy	The 'swap' function does not update the reserves before transferring tokens, allowing for a reentrancy attack to exploit this vulnerability.
p52_2	1	removeLiquidity	Reentrancy	The 'removeLiquidity' function is prone to reentrancy attacks because it calls 'reserve.reimburseImpermanentLoss()' before updating the state of the user's balances.
p52_2	2	addLiquidity	Function Visibility	There are two 'addLiquidity' functions with different parameter sets, but they have the same name and one of them is marked 'public', making it callable externally which can cause confusion.
p52_2	1	mintSynth	Reentrancy	The 'mintSynth' function transfers native asset before updating the reserves which can be exploited using reentrancy attack.
p52_2	2	burnSynth	Reentrancy	The 'burnSynth' function transfers native asset before updating the reserves which can be exploited using reentrancy attack.
p52_2	3	mintFungible	Reentrancy	The 'mintFungible' function transfers native and foreign assets before updating the reserves which can be exploited using reentrancy attack.
p52_2	4	burnFungible	Reentrancy	The 'burnFungible' function transfers native and foreign assets before updating the reserves which can be exploited using reentrancy attack.
p52_2	1	rescue	Reentrancy	The `rescue` function transfers tokens without considering the ReentrancyGuard. This might lead to reentrancy attacks where an attacker can repeatedly call the function and drain the contract's balance.
p52_2	null
p52_2	1	setTimelock	Missing Input Validation	The 'setTimelock' function can be called multiple times by the guardian, allowing the timelock address to be changed after initialization.
p52_2	2	propose	Reentrancy	The 'propose' function does not protect against reentrancy attacks, since it makes an external call to the xVader token before updating the state.
p52_2	1	grant	Reentrancy	The grant function transfers VADER tokens to the recipient and then emits an event. This ordering of operations makes it susceptible to a reentrancy attack if the recipient is a malicious smart contract.
p52_2	1	claim	Reentrancy	The claim function transfers VADER tokens to the user and then emits an event. This ordering of operations makes it susceptible to a reentrancy attack if the user is a malicious smart contract.
p52_2	2	claimConverted	Reentrancy	The claimConverted function transfers VADER tokens to the user and then emits an event. This ordering of operations makes it susceptible to a reentrancy attack if the user is a malicious smart contract.
p52_2	null
p52_2	null
p51_2	1	claim	Reentrancy Attack	Although the contract uses the ReentrancyGuard, the `_claimableAmount` function called within the `claim` function alters the state, which may allow an attacker to re-enter the `claim` function and drain funds.
p51_2	1	distributeTokens	Reentrancy	The function distributeTokens is vulnerable to reentrancy attacks. The function allows users to withdraw tokens, but it doesn't update the withdrawal status before the actual token transfer. This means an attacker can recursively call the function and drain the contract's balance.
p49_3	1	fetchPricePoint	Reentrancy	The fetchPricePoint function makes external calls to the IUniswapV3Pool(ovlFeed).observe and IUniswapV3Pool(marketFeed).observe functions before completing its internal state update. This leaves the contract vulnerable to reentrancy attacks.
p49_3	2	computeDepth	Integer Overflow	The computeDepth function might suffer from integer overflow when calculating ((_marketLiquidity * 1e18) / _ovlPrice).mulUp(lmbda), as the multiplication can exceed the maximum value of uint256.
p49_3	3	fetchPricePoint	Typecasting Inaccuracy	The fetchPricePoint function has a potential for typecasting inaccuracy when casting int values to uint32, which might result in unintended behavior.
p49_2	1	fetchPricePoint	Reentrancy	The function fetchPricePoint calls IUniswapV3Pool(marketFeed).observe and IUniswapV3Pool(ovlFeed).observe, which are external contracts. These calls can be exploited by an attacker who manipulates the external contract to call back into the OverlayV1UniswapV3Market contract before the initial call finishes, leading to unexpected behavior and potential asset loss.
p49_2	2	computeDepth	Integer Overflow and Underflow	In the computeDepth function, the multiplication of _marketLiquidity and 1e18 may result in an integer overflow. Similarly, the division by _ovlPrice may result in an integer underflow if _ovlPrice is zero.
p51_1	1	revoke	Reentrancy	The `revoke()` function is vulnerable to reentrancy attacks as it calls external contracts (`vestingToken.safeTransfer()`) after updating the state variables, but before finalizing the state changes.
p51_1	2	_claimableAmount	Integer Overflow	The `_claimableAmount()` function is vulnerable to integer overflow in the calculation of `claimable`. An attacker could manipulate the input values to cause an overflow and exploit the function.
p51_1	1	withdrawTokens	Reentrancy	The 'withdrawTokens' function is vulnerable to a reentrancy attack since it sends tokens before updating the user's balance.
p49_1	1	fetchPricePoint	Reentrancy	The `fetchPricePoint` function calls external contracts (IUniswapV3Pool) using the `observe` function, which may lead to reentrancy attacks if the external contract is compromised or malicious.
p49_1	2	computeDepth	Integer Overflow	In the `computeDepth` function, the multiplication of `_marketLiquidity * 1e18` could cause an integer overflow, leading to incorrect calculations and potential loss of assets.
p47_2	1	burn	Reentrancy	The burn function is susceptible to a reentrancy attack because it first modifies the user's balance (_burn) and then transfers the tokens (ibbtc.transfer). An attacker can exploit this by calling the burn function again within the same transaction before the transfer is executed, resulting in multiple withdrawals.
p47_2	1	burn	Reentrancy	The burn function is susceptible to a reentrancy attack because it first modifies the user's balance (_burn) and then transfers the tokens (ibbtc.transfer). An attacker can exploit this by calling the burn function again within the same transaction before the transfer is executed, resulting in multiple withdrawals.
p45_3	null
p45_2	1	getLockedAmount	Integer Overflow	In the 'getLockedAmount' function, when calculating the 'newLockedAmount', there is no check for integer overflow. This can cause the 'newLockedAmount' to wrap around and become smaller than expected, leading to incorrect locked amounts.
p45_2	2	_findMedian	Denial of Service (DoS)	The '_findMedian' function uses a nested loop to sort the input array, making it vulnerable to DoS attacks when given a large input. A malicious user can purposely send a large array to consume excessive gas and make the function unusable.
p44_2	1	swapByQuote	Front-running vulnerability	The swapByQuote function does not prevent front-running, meaning that an attacker can monitor pending transactions and submit their own transactions with higher gas prices to exploit price differences.
p44_2	2	swapByQuote	Unsafe approval	The swapByQuote function increases the allowance of zrxAllowanceTarget without first setting it to zero, which can cause issues if the allowance was already set.
p42_3	0	N/A	None	The provided smart contract does not contain any high-risk bugs that can cause asset loss or are exploitable. It is a contract primarily for managing configurations related to the MochiEngine. It uses the 'onlyGov' modifier for functions that change the contract's state, ensuring that only the governance address can modify the contract.
p42_3	1	withdraw	Reentrancy	The function updates the state after transferring tokens, which allows for reentrancy attacks.
p42_3	2	mint	Missing access control	The mint function can be called by anyone, which allows unauthorized users to create new vaults.
p42_3	1	registerAsset	Reentrancy	The `registerAsset` function calls the external function `engine.cssr().getLiquidity(_asset)` before updating the state. This external call can be exploited in a reentrancy attack.
p42_3	2	registerAssetByGov	Reentrancy	The `registerAssetByGov` function calls the external function `engine.vaultFactory().deployVault(_asset[i])` inside a loop, which can be exploited in a reentrancy attack.
p42_3	1	distributeMochi	Front-running	The `distributeMochi()` function is vulnerable to front-running attacks because it uses Uniswap's `swapExactTokensForTokens()` to swap tokens. Attackers can monitor the mempool for such transactions and front-run them to make a profit.
p42_3	2	_buyMochi	No slippage protection	The `_buyMochi()` function does not set a minimum amount of tokens to be received from the swap, effectively setting the slippage to infinite. This allows a malicious actor to manipulate the price and drain funds.
p42_3	1	claimRewardAsMochi	No slippage protection	The `claimRewardAsMochi()` function does not set a minimum amount of tokens to be received from the swap, effectively setting the slippage to infinite. This allows a malicious actor to manipulate the price and drain funds.
p42_3	2	claimRewardAsMochi	Front-running	The `claimRewardAsMochi()` function is vulnerable to front-running attacks because it uses Uniswap's `swapExactTokensForTokens()` to swap tokens. Attackers can monitor the mempool for such transactions and front-run them to make a profit.
p42_3	1	_buyCRV	No slippage protection	The `_buyCRV()` function does not set a minimum amount of tokens to be received from the swap, effectively setting the slippage to infinite. This allows a malicious actor to manipulate the price and drain funds.
p42_3	2	_buyCRV	Front-running	The `_buyCRV()` function is vulnerable to front-running attacks because it uses Uniswap's `swapExactTokensForTokens()` to swap tokens. Attackers can monitor the mempool for such transactions and front-run them to make a profit.
p42_3	3	withdrawCRV, withdrawLock, toggleLocking	No timelock on governance actions	There is no timelock or delay on governance actions like `withdrawCRV()`, `withdrawLock()`, and `toggleLocking()`. This allows the governance to execute these actions immediately, potentially leading to malicious actions or exploits.
p42_3	1	forceClaim	Integer Division	The `forceClaim` function divides `_amount` by 2 using integer division, which can lead to a loss of 1 unit of `mochi` due to rounding down. This can cause a discrepancy between the claimed and expected amounts.
p42_3	2	vest	No access control	The `vest` function has no access control, which allows anyone to call it. This can lead to unexpected behavior or manipulation of vesting amounts.
p42_3	3	lock	No input validation	The `lock` function does not validate the `_amount` parameter, which allows a user to lock an arbitrary amount of tokens, potentially leading to undesired behavior or manipulation of the vesting process.
p42_2	null
p42_2	1	withdraw	Reentrancy	The function withdraw updates the state variables before performing the asset transfer, but since it uses the `cheapTransfer` function from the CheapERC20 library, it is vulnerable to reentrancy attacks.
p42_2	2	liquidate	Reentrancy	The function liquidate is also vulnerable to reentrancy attacks, as it updates state variables before performing the asset transfer.
p42_2	3	flashLoan	Reentrancy	The function flashLoan is vulnerable to reentrancy attacks, as it updates state variables before performing the asset transfers and checking the return value of the callback.
p42_2	1	calculateFeeIndex	Integer Overflow	The calculation in calculateFeeIndex function can lead to an integer overflow when multiplying _currentIndex by feeAccumulated.
p42_2	2	registerAssetByGov	Unbounded Loop	The function registerAssetByGov has a for loop that iterates over arrays _asset and _classes, which can lead to high gas costs or even block gas limit issues if these arrays are too large.
p42_2	1	distributeMochi	Reentrancy	The distributeMochi function calls external contracts (Uniswap) before updating the internal state, which might lead to reentrancy attacks.
p42_2	2	updateReserve	Integer Overflow	When calculating the new reserve, the function might overflow if the contract balance is extremely high.
p42_2	3	changeTreasuryRatio, changevMochiRatio	Lack of input validation	There's no input validation when updating ratios, which might lead to incorrect or malicious ratio values.
p42_2	1	claimRewardAsMochi	Reentrancy	The claimRewardAsMochi function calls external contracts (Uniswap) before updating the internal state, which might lead to reentrancy attacks.
p42_2	2	addReward	Integer Overflow	When calculating the new reward, the function might overflow if the contract balance is extremely high.
p42_2	3	claimRewardAsMochi	Token Draining	The claimRewardAsMochi function transfers the entire balance of Mochi tokens instead of the user's claimed reward, allowing users to drain the contract.
p42_2	1	vest	Integer Overflow	The calculation of 'weightedEnd' can overflow if the values of vested, ends, and amount are extremely high.
p42_2	2	claim	Reentrancy	The claim function transfers tokens to the sender before updating the internal state, which might lead to reentrancy attacks.
p42_2	3	lock	Reentrancy	The lock function calls an external contract (vMochi) before updating the internal state, which might lead to reentrancy attacks.
p42_2	4	forceClaim	Reentrancy	The forceClaim function transfers tokens to the sender and an external contract (vMochi) before updating the internal state, which might lead to reentrancy attacks.
p42_2	1	claimOperationCost	Reentrancy	The claimOperationCost function transfers tokens to the operationWallet before updating the internal state, which might lead to reentrancy attacks.
p42_2	2	updateFee	Integer Overflow	The calculation of 'updatedFee' can overflow if the balance of USDM is extremely high.
p42_2	3	veCRVlock	Reentrancy	The veCRVlock function calls external contracts (_buyCRV and _lockCRV) before updating the internal state, which might lead to reentrancy attacks.
p41_2	1	settleAuction	Reentrancy	The `settleAuction` function allows an attacker to re-enter by calling a malicious ERC20 contract during the token transfers, enabling them to drain the contract's funds.
p41_2	2	settleAuction	Integer Overflow	Calculation of the `newRatio` variable in the `settleAuction` function can cause an integer overflow or underflow, leading to incorrect token amounts being transferred.
p41_2	3	withdrawBounty	Unchecked External Call	The `withdrawBounty` function doesn't check the return value of the `safeTransfer` call. A malicious ERC20 token may return false without reverting, causing a user's tokens to be locked.
p60_2	1	liquidate	Reentrancy	The `liquidate` function uses `token.push` to transfer the liquidation fee to the caller without using a reentrancy guard. This could allow an attacker to re-enter the function before the state is updated, causing multiple liquidations and asset loss.
p60_2	null
p58_3	1	_pull	Reentrancy	The _pull function allows withdrawals from the Aave Lending Pool and updates the TVL right after. This can lead to reentrancy attacks since external calls are made before updating the state.
p58_3	2	_allowTokenIfNecessary	Integer Overflow	The _allowTokenIfNecessary function checks if the allowance is less than `type(uint256).max / 2` which can lead to integer overflow if the allowance is greater than `type(uint256).max / 2`.
p58_3	3	_push	Missing Input Validation	The _push function takes user-provided input (options) and directly decodes it to the referral code without validation. An attacker can supply malicious input to cause unexpected behavior.
p58_3	null
p58_3	null
p58_3	1	collectEarnings	Reentrancy	The collectEarnings function is susceptible to a reentrancy attack since it allows external calls before the state is updated.
p58_3	2	_parseOptions	Front-running	The _parseOptions function uses block.timestamp for setting the deadline, which can be manipulated by miners and front-runners.
p59_2	null
p59_2	null
p59_2	1	buyMalt	Reentrancy	The `buyMalt()` function makes an external call to `router.swapExactTokensForTokens()` before transferring purchased MALT tokens to the sender, making the function vulnerable to a reentrancy attack.
p59_2	2	sellMalt	Reentrancy	The `sellMalt()` function makes an external call to `router.swapExactTokensForTokens()` before transferring rewards to the sender, making the function vulnerable to a reentrancy attack.
p59_2	3	addLiquidity	Reentrancy	The `addLiquidity()` function makes an external call to `router.addLiquidity()` before transferring unused tokens to the sender, making the function vulnerable to a reentrancy attack.
p59_2	4	removeLiquidity	Reentrancy	The `removeLiquidity()` function makes an external call to `router.removeLiquidity()` before transferring broken LP tokens to the sender, making the function vulnerable to a reentrancy attack.
p59_2	1	exitEarly	Reentrancy	The 'exitEarly' function is vulnerable to reentrancy attacks because it sends tokens to the user before updating the state variables. A malicious contract can call 'exitEarly' recursively to withdraw more tokens than it should.
p58_2	1	_pull	Reentrancy	The `_pull` function calls the external contract `_lendingPool()` and then updates the state variable `_tvls`. This can lead to reentrancy attacks if the called contract is malicious.
p58_2	2	_allowTokenIfNecessary	Integer Overflow	The allowance check in `_allowTokenIfNecessary` compares the allowance with `type(uint256).max / 2`, which may cause integer overflow if the allowance is very large.
p58_2	1	deposit	Reentrancy	The deposit function allows for reentrancy due to the IERC20(token).safeTransferFrom and IERC20(token).safeTransfer calls, which can call external contracts.
p58_2	2	withdraw	Reentrancy	The withdraw function allows for reentrancy due to the IERC20(token).safeTransfer call, which can call external contracts.
p58_2	1	deployVault	Reentrancy	The function deployVault calls the external contract 'registry' with registry.safeTransferFrom before completing the function execution. This can lead to reentrancy attacks.
p58_2	2	deployVault	Missing access control	The deployVault function can be called by anyone, which may lead to unauthorized deployment of vaults.
p58_2	1	collectEarnings	Reentrancy	The collectEarnings function calls an external contract (_positionManager().collect()) before updating the state. This can potentially lead to a reentrancy attack.
p56_3	1	update	Reentrancy	The `update` function calls the internal function `getEarnedYield`, which can be potentially manipulated by external contracts, leading to reentrancy attacks.
p56_3	2	update	Integer Overflow	The `update` function does not validate if the `_earnedYield` variable overflows or underflows, which may lead to unintended asset loss.
p54_3	1	recordKeyPurchase	Reentrancy	The `recordKeyPurchase` function is potentially vulnerable to reentrancy attacks due to the call to the external contract (IMintableERC20) after updating the state variables (grossNetworkProduct and locks[msg.sender].totalSales).
p54_3	2	recordKeyPurchase	Integer Overflow	The `recordKeyPurchase` function contains calculations without checking for integer overflows, e.g., `grossNetworkProduct = grossNetworkProduct + valueInETH;`. This may lead to incorrect values and manipulation of contract logic.
p54_3	3	_deployProxyAdmin	Incorrect Access Control	The `_deployProxyAdmin` function is marked private but is called within the `initialize` function, which is public. This allows anyone to deploy a new proxy admin contract and potentially manipulate the upgrade process.
p54_3	1	_timeMachine	Reentrancy	The function `_timeMachine` can be called by external functions which may lead to a reentrancy attack. An attacker could potentially re-enter the function and modify the key's expirationTimestamp multiple times during the same transaction.
p54_3	2	_timeMachine	Overflow and Underflow	Arithmetic operations in the `_timeMachine` function can result in overflow and underflow issues. An attacker could exploit this to manipulate the key's expirationTimestamp.
p54_3	1	purchase	Reentrancy	The `purchase` function can be vulnerable to reentrancy attacks since it performs token transfers before updating the internal state, and the contract does not use a mutex.
p54_3	2	purchase	Integer Overflow	An integer overflow can happen when calculating `newTimeStamp` if `expirationDuration` is large enough.
p54_3	3	purchase	Unchecked return value	The return value of the `token.transferFrom` function is not checked, which could lead to a false sense of successful token transfers.
p54_3	1	shareKey	Reentrancy	The `shareKey` function calls an external contract `_checkOnERC721Received` at the end, which could lead to a reentrancy attack if the called contract's `onERC721Received` function has malicious code.
p54_3	2	transferFrom	Reentrancy	The `transferFrom` function emits the `Transfer` event before all state changes are done, which could lead to a reentrancy attack if an external contract is listening to this event and calls back into the contract.
p54_3	1	_cancelAndRefund	Reentrancy	The _cancelAndRefund function transfers the refund amount to the _keyOwner before the onKeyCancelHook is executed. If the _keyOwner is a malicious contract, it can call back into the contract during the transfer, which could lead to reentrancy issues.
p54_2	1	recordKeyPurchase	Reentrancy	The function calls external contracts (IMintableERC20) which allows potential reentrancy attacks.
p54_2	2	recordKeyPurchase	Integer Overflow	The grossNetworkProduct variable might overflow when adding valueInETH.
p54_2	3	recordKeyPurchase	Integer Underflow	The balance calculation may underflow if the balance is smaller than tokensToDistribute.
p54_2	1	setApprovalForAll	Reentrancy	The function setApprovalForAll may be subject to a reentrancy attack if the '_to' address is a malicious contract that calls back into this contract during the emit ApprovalForAll event.
p54_2	2	_timeMachine	Integer Underflow	In the _timeMachine function, when _addTime is false, key.expirationTimestamp may underflow if _deltaT is larger than formerTimestamp.
p54_2	1	purchase	Reentrancy	The 'purchase' function is vulnerable to reentrancy attacks since it transfers tokens to the contract address before updating the contract state. If the token contract calls back into the 'purchase' function, an attacker may be able to purchase keys with incorrect values.
p54_2	1	shareKey	Front-Running Attack	The shareKey function is vulnerable to a front-running attack since it uses block.timestamp for time calculations. A malicious miner could manipulate the timestamp to gain an unfair advantage.
p54_2	2	shareKey	Reentrancy Attack	The shareKey function is vulnerable to reentrancy attacks as it calls an external contract _checkOnERC721Received without using a reentrancy guard.
p54_2	3	transfer	Integer Overflow	In the transfer function, the maxTimeToSend calculation can overflow if _value * expirationDuration is greater than uint256's maximum value.
p54_2	1	_cancelAndRefund	Reentrancy	The function _cancelAndRefund calls the external contract (onKeyCancelHook) after updating the state variables but before transferring the refund to the key owner. This may lead to a reentrancy attack if the called contract maliciously calls back into the _cancelAndRefund function.
p52_3	1	calculateSwap	Integer Division	The function calculateSwap may produce inaccurate results due to integer division, leading to potential losses when swapping tokens.
p52_3	2	calculateSwapReverse	Division by Zero	The calculateSwapReverse function can cause a division by zero error if amountOut is zero. This will result in an undefined behavior and may compromise the smart contract's security.
p52_3	1	mint	Reentrancy	The `mint` function is susceptible to a reentrancy attack due to calling the `_update` function before setting the position mapping. The `_update` function has an `emit Sync` event that can be intercepted by a malicious contract.
p52_3	2	_burn	Reentrancy	The `_burn` function is susceptible to a reentrancy attack as it calls the `safeTransfer` functions before updating the state. A malicious contract can intercept the token transfers and re-enter the `_burn` function.
p52_3	3	swap	Reentrancy	The `swap` function is susceptible to a reentrancy attack as it calls the `safeTransfer` functions before updating the state. A malicious contract can intercept the token transfers and re-enter the `swap` function.
p52_3	1	addLiquidity	Function signature collision	There are two functions with the same name and signature, causing a function signature collision. This can lead to confusion and unintended behavior.
p52_3	2	removeLiquidity	Reentrancy vulnerability	The 'reserve.reimburseImpermanentLoss()' function call is susceptible to reentrancy attacks, as external contract code execution is allowed before the function state is finalized.
p52_3	1	rescue	Asset Loss due to Unrestricted Token Rescue	The 'rescue' function can be called by anyone, and it transfers the difference between the foreignAsset's balance and reserveForeign to the caller. This can lead to a potential exploit where an attacker can drain unaccounted tokens.
p52_3	null
p52_3	1	removeLiquidity	Reentrancy	The function calls 'reserve.reimburseImpermanentLoss' after transferring tokens, which could be vulnerable to reentrancy attacks.
p52_3	1	propose	Reentrancy	In the propose function, xVader.transferFrom is called before updating the latestProposalIds mapping, which can lead to a reentrancy attack where an attacker can create multiple proposals while only paying the fee once.
p52_3	2	setTimelock	Missing input validation	There is no validation to ensure that the setTimelock function is only called once. If it is called multiple times, it can overwrite the existing timelock contract address.
p52_3	1	reimburseImpermanentLoss	Reentrancy Attack	The function `reimburseImpermanentLoss` allows the Router to withdraw funds from the contract, and the token transfer may potentially call a malicious contract that could re-enter the function before the `LossCovered` event is emitted.
p52_3	null
p52_3	null
p52_3	null
p52_1	1	calculateSwapReverse	Reentrancy Attack	The 'calculateSwapReverse' function has a 'require' statement that throws an error when 'y4 < reserveOut' is false, which can lead to a reentrancy attack when an external contract is called before the state is updated.
p52_1	1	swap	Front-running vulnerability	The swap function can be front-run by other transactions in the same block, leading to potential arbitrage opportunities and losses for honest users.
p52_1	2	mint, _burn	Impermanent Loss	The current implementation of the mint and _burn functions can lead to impermanent loss for liquidity providers due to the constant product market maker model.
p52_1	3	_burn	Reentrancy vulnerability	The _burn function is marked as nonReentrant, but it contains external calls before state updates, which could lead to reentrancy vulnerabilities.
p52_1	1	removeLiquidity	Reentrancy	The `removeLiquidity` function calls an external contract (`reserve.reimburseImpermanentLoss`) after updating the user's balance, which allows for potential reentrancy attacks.
p52_1	2	addLiquidity	Function Visibility	The `addLiquidity` function is defined twice, with one being external and one being public. This is not only confusing but may also lead to unintended behavior.
p52_1	1	mintSynth	Reentrancy	The 'mintSynth' function is vulnerable to reentrancy attack due to the external 'synth.mint' call followed by state-changing operations. A malicious 'synth' contract can re-enter the 'mintSynth' function and manipulate the state.
p52_1	2	burnSynth	Reentrancy	The 'burnSynth' function is vulnerable to reentrancy attack due to the external 'synth.burn' call followed by state-changing operations. A malicious 'synth' contract can re-enter the 'burnSynth' function and manipulate the state.
p52_1	3	mintFungible	Reentrancy	The 'mintFungible' function is vulnerable to reentrancy attack due to the external 'lp.mint' call followed by state-changing operations. A malicious 'lp' contract can re-enter the 'mintFungible' function and manipulate the state.
p52_1	4	burnFungible	Reentrancy	The 'burnFungible' function is vulnerable to reentrancy attack due to the external 'lp.burn' call followed by state-changing operations. A malicious 'lp' contract can re-enter the 'burnFungible' function and manipulate the state.
p52_1	1	rescue()	Missing input validation	The `rescue()` function allows anyone to call it, potentially leading to unintended token withdrawals. Attackers could exploit this to drain tokens from the contract that are not accounted for in the reserves.
p52_1	2	swap(), doubleSwap()	Front-running attacks	The `swap()` and `doubleSwap()` functions are vulnerable to front-running attacks. Attackers can observe pending transactions and submit their own transactions with higher gas prices to benefit from arbitrage opportunities.
p52_1	1	removeLiquidity	Reentrancy	The function `removeLiquidity` calls an external contract `reserve.reimburseImpermanentLoss` at the end, which can lead to reentrancy attacks.
p52_1	1	execute	Re-entrancy vulnerability	The `execute` function allows for the execution of arbitrary code before marking the proposal as executed, opening the possibility for reentrancy attacks.
p52_1	2	setTimelock	Access control vulnerability	The `setTimelock` function can be called by the `guardian` at any time, allowing the `guardian` to change the timelock contract address without restrictions.
p52_1	1	grant	Reentrancy	The grant function transfers VADER tokens to the recipient without updating the lastGrant state variable beforehand, which can potentially allow for reentrancy attacks.
p52_1	2	reimburseImpermanentLoss	Reentrancy	The reimburseImpermanentLoss function transfers VADER tokens to the recipient without proper reentrancy protection, making it potentially vulnerable to reentrancy attacks.
p52_1	null
p52_1	1	consult	Stale Oracle Data	The `consult` function doesn't check if the Chainlink price is stale, which could cause the oracle to provide outdated and incorrect price data.
p52_1	2	consult	No Liquidity Check	The `consult` function doesn't check if the pairs have sufficient liquidity before calculating the result, which can lead to incorrect price data or manipulation.
p52_1	1	enter	Reentrancy	The 'enter' function is marked as 'nonReentrant' which prevents reentrancy attacks by using a mutex, but it does not handle an edge case where the external call to vader.transferFrom occurs after the xVADER tokens are minted, which allows an attacker to potentially manipulate the totalSupply and receive more xVADER tokens than they should.
p52_1	2	leave	Reentrancy	The 'leave' function is marked as 'nonReentrant' which prevents reentrancy attacks by using a mutex, but it does not handle an edge case where the external call to vader.transfer occurs after the xVADER tokens are burned, which allows an attacker to potentially manipulate the totalSupply and receive more VADER tokens than they should.
p51_3	1	claim	Reentrancy	Although the contract is using the ReentrancyGuard, there is still a potential reentrancy issue in the claim function. The balance of the beneficiary is updated after the transfer, which could be exploited by a malicious smart contract to repeatedly call the claim function before the balance update.
p51_3	2	_claimableAmount	Integer Overflow	The _claimableAmount function calculates claimable tokens in a manner that can lead to integer overflow. The multiplication of the difference between the current timestamp and iTimeStamp with the timelock amount is done before the division, which can cause an overflow.
p51_3	1	not present	Reentrancy	Although the contract inherits from ReentrancyGuard, it does not seem to contain any custom functions that transfer value or make external calls. This means we cannot identify specific functions that may be vulnerable to reentrancy attacks. However, if new functions are added in the future, the contract will be protected from reentrancy attacks due to the inheritance of ReentrancyGuard.
p47_3	1	mint	Reentrancy	The mint function allows a user to deposit ibBTC tokens and mint wibBTC tokens. However, the function is susceptible to reentrancy attacks, as the external call to ibbtc.transferFrom() is executed before the wibBTC tokens are minted.
p47_3	2	burn	Reentrancy	The burn function allows a user to redeem wibBTC tokens for ibBTC tokens. However, the function is also susceptible to reentrancy attacks, as the external call to ibbtc.transfer() is executed after the wibBTC tokens are burnt.
p47_3	1	mint	Reentrancy	The mint function allows a user to deposit ibBTC tokens and mint wibBTC tokens. However, the function is susceptible to reentrancy attacks, as the external call to ibbtc.transferFrom() is executed before the wibBTC tokens are minted.
p47_3	2	burn	Reentrancy	The burn function allows a user to redeem wibBTC tokens for ibBTC tokens. However, the function is also susceptible to reentrancy attacks, as the external call to ibbtc.transfer() is executed after the wibBTC tokens are burnt.
p47_1	1	mint	Reentrancy	The mint function allows users to deposit ibBTC and receive wibBTC shares in return. The ERC20 `transferFrom` function is called before updating the user's balance, which may lead to potential reentrancy attacks.
p47_1	2	burn	Reentrancy	The burn function allows users to redeem wibBTC for ibBTC. The ERC20 `transfer` function is called after updating the user's balance, which may lead to potential reentrancy attacks.
p47_1	3	updatePricePerShare	Front-running	The updatePricePerShare function is public and permissionless, allowing anyone to update the pricePerShare at any time. This can lead to front-running attacks where users observe pending transactions and manipulate the price for their benefit.
p47_1	1	mint	Reentrancy	The mint function allows users to deposit ibBTC and receive wibBTC shares in return. The ERC20 `transferFrom` function is called before updating the user's balance, which may lead to potential reentrancy attacks.
p47_1	2	burn	Reentrancy	The burn function allows users to redeem wibBTC for ibBTC. The ERC20 `transfer` function is called after updating the user's balance, which may lead to potential reentrancy attacks.
p45_1	1	_sortArray	Denial of Service	The implementation of the sorting algorithm in the `_sortArray` function is inefficient, using nested for-loops with a worst-case time complexity of O(n^2). This can lead to gas limit issues and potential Denial of Service attacks when processing large arrays.
p44_3	1	swapByQuote	Front-running attack	The swapByQuote function lacks protection against front-running attacks. Attackers can observe pending transactions and attempt to exploit this vulnerability by placing their own transactions with higher gas prices. This could lead to unfavorable exchange rates for the user, as the attacker's transaction gets executed before the user's transaction.
p44_1	1	sweepFees	Reentrancy	The `sweepFees` function is vulnerable to reentrancy attack since it makes external calls to untrusted contracts (IERC20.safeTransfer) before updating the contract state.
p41_3	1	settleAuction	Reentrancy	The `withdrawBounty()` function inside `settleAuction()` is called after updating the state variables `auctionOngoing` and `hasBonded`, potentially allowing for reentrancy attacks.
p41_3	2	bondForRebalance	Front-Running	The first user to call `bondForRebalance()` sets the `auctionBonder` variable, which can be front-run by malicious users.
p42_1	null
p42_1	1	flashLoan	Reentrancy	The `flashLoan` function can be exploited by an attacker to re-enter the function before the expected callback returns, allowing the attacker to drain the assets.
p42_1	2	increase	Reentrancy	The `increase` function is susceptible to reentrancy attacks when calling `deposit` and `borrow` functions. An attacker may exploit this vulnerability to drain the assets.
p42_1	3	decrease	Reentrancy	The `decrease` function is susceptible to reentrancy attacks when calling `repay` and `withdraw` functions. An attacker may exploit this vulnerability to drain the assets.
p42_1	1	registerAsset	Reentrancy	The `registerAsset` function calls the `engine.cssr().getLiquidity(_asset)` external function before updating the state, making it vulnerable to reentrancy attacks.
p42_1	2	registerAssetByGov	Reentrancy	The `registerAssetByGov` function calls the `engine.vaultFactory().deployVault(_asset[i])` external function within a loop, making it vulnerable to reentrancy attacks.
p42_1	1	distributeMochi	Reentrancy	The external call to uniswapRouter.swapExactTokensForTokens in the _buyMochi function can potentially be exploited through a reentrancy attack.
p42_1	2	updateReserve	Integer Overflow	The newReserve calculation could lead to an integer overflow when updating the treasuryShare and mochiShare.
p42_1	3	distributeMochi	Missing Access Control	The distributeMochi function can be called by anyone, leading to potential manipulation and abuse of the distribution process.
p42_1	1	claimRewardAsMochi	Reentrancy	The external call to uniswapRouter.swapExactTokensForTokens can potentially be exploited through a reentrancy attack.
p42_1	2	addReward	Missing Access Control	The addReward function can be called by anyone, leading to potential manipulation and abuse of the reward distribution process.
p42_1	3	addReward	Integer Overflow	The newReward calculation could lead to an integer overflow when updating the reward mapping and rewards state variable.
p42_1	1	vest	Missing Access Control	The vest function can be called by anyone, allowing unauthorized users to manipulate vesting rewards.
p42_1	2	claim	Reentrancy	The claim function's external call to mochi.transfer could potentially be exploited through a reentrancy attack.
p42_1	3	lock	Reentrancy	The lock function's external call to vMochi.depositFor could potentially be exploited through a reentrancy attack.
p42_1	4	forceClaim	Reentrancy	The forceClaim function's external call to mochi.transfer could potentially be exploited through a reentrancy attack.
p42_1	1	veCRVInitialize	Missing Access Control	The veCRVInitialize function can be called by anyone, which allows unauthorized users to control the veCRV initialization process.
p42_1	2	veCRVlock	Missing Access Control	The veCRVlock function can be called by anyone, which allows unauthorized users to lock CRV tokens.
p42_1	3	claimOperationCost	Reentrancy	The claimOperationCost function's external call to engine.usdm().transfer could potentially be exploited through a reentrancy attack.
p42_1	4	_buyCRV	Reentrancy	The _buyCRV function's external call to uniswapRouter.swapExactTokensForTokens could potentially be exploited through a reentrancy attack.
p42_1	5	_lockCRV	Reentrancy	The _lockCRV function's external call to veCrv.increase_amount and veCrv.increase_unlock_time could potentially be exploited through a reentrancy attack.
p41_1	1	settleAuction	Reentrancy	The function `settleAuction` withdraws bounties after transferring funds, which can lead to reentrancy attacks since the contract state is not updated before external calls.
p41_1	2	addBounty	Missing input validation	The `addBounty` function does not check if the input token address is a valid ERC20 token, which can lead to adding invalid bounties.
p41_1	3	settleAuction	No upper bound checks	The for loops iterating over `inputTokens`, `outputTokens`, and `pendingWeights` arrays do not have an upper bound check, which may lead to denial of service attacks or out of gas exceptions.
p31ve_3	1	prepareWithdrawAll	Reentrancy	The function prepareWithdrawAll() is vulnerable to reentrancy attacks as it calls an external contract (CVX_VAULT) before updating the state.
p31ve_3	2	_withdrawSome	Price Manipulation	The function _withdrawSome() uses the value of bCVXToCVX as a safety check, which can be manipulated by external actors through flash loan attacks.
p31ve_3	3	_swapcvxCRVToWant	Front Running	The function _swapcvxCRVToWant() uses the "now" variable in the swapExactTokensForTokens function, allowing front-running attacks.
p31ve_3	4	manualRebalance	Price Manipulation	The manualRebalance function relies on on-chain data to calculate ratios, which can be manipulated by external actors through flash loan attacks.
p30_3	1	withdraw	Reentrancy	The `withdraw` function calls external contract `IController _controller` to withdraw funds before transferring the assets to the user. This might allow reentrancy attacks where a malicious contract can exploit the function to steal funds from the vault.
p30_3	2	_normalizeDecimals	Integer Overflow	The `_normalizeDecimals` function calculates `_amount = _amount.mul(10**(18-_decimals))`, which can lead to an integer overflow if the `_decimals` variable has a value larger than 18.
p30_3	1	withdraw	Reentrancy	The `withdraw` function contains a potential reentrancy attack, as external contract calls are made before state updates. If the called contract is malicious, it can re-enter the `withdraw` function and cause unexpected behavior.
p30_3	2	inCaseStrategyGetStuck, inCaseTokensGetStuck	Lack of access control	These functions allow the strategist to withdraw any tokens from the contract. If the strategist's account is compromised, an attacker could drain tokens from the Controller.
p30_3	3	N/A	Centralization risks	The contract relies heavily on a single strategist, which poses centralization risks. If the strategist's account is compromised, the contract may be at risk.
p29_3	1	flashSwap	Reentrancy	The function `flashSwap` is vulnerable to a reentrancy attack. The contract's state is not updated before calling an external contract `ITridentCallee(msg.sender).tridentSwapCallback(context);`. An attacker could exploit this vulnerability by implementing a malicious TridentCallee contract to re-enter the `flashSwap` function and drain the pool's funds.
p29_3	1	flashSwap	Reentrancy	flashSwap function is vulnerable to reentrancy attacks as it executes external contract calls (tridentSwapCallback) after updating the reserves but before transferring the fee to barFeeTo.
p29_3	1	mint, burn, burnSingle, swap, flashSwap	Reentrancy	All of these functions are using a custom reentrancy guard (lock modifier) which is based on the `unlocked` variable. However, the lock modifier can be bypassed if an attacker is able to manipulate the `unlocked` variable to make it always equal to 1.
p31ve_2	0	N/A	No High-Risk Bugs	Upon analyzing the given Solidity smart contract, no high-risk bugs were found that could lead to asset loss or be exploitable.
p30_2	null
p30_2	1	withdraw	Reentrancy vulnerability	The `withdraw` function updates the vault's balance after transferring the tokens, which can allow an attacker to exploit the reentrancy vulnerability.
p30_2	2	setCap	Unchecked token balance after conversion	The `setCap` function does not check whether the token balance after conversion is sufficient to be transferred to the vault, which can cause asset loss if not enough tokens are received after conversion.
p29_2	1	flashSwap	Reentrancy	The `flashSwap` function allows the caller to borrow tokens from the pool and perform any arbitrary action in the `tridentSwapCallback` function. This can lead to potential reentrancy attacks if the callee contract interacts with the pool again before the state is updated in the `flashSwap` function.
p29_2	1	flashSwap	Reentrancy	In the flashSwap function, the callback tridentSwapCallback is called before the reserves are updated, which can cause reentrancy attacks where an attacker can repeatedly call flashSwap and drain the pool.
p29_2	1	mint, burn, burnSingle, swap, flashSwap	Reentrancy	The lock modifier is used in the mentioned functions to prevent reentrancy attacks, but it doesn't completely prevent it. The reason is that the modifier doesn't revert the transaction when it's in a locked state (unlocked == 2), allowing for possible nested calls that could lead to reentrancy.
p31ve_1	null
p30_1	1	withdraw()	Reentrancy	The withdraw() function is susceptible to reentrancy attacks since it first updates the user's internal balance by calling _burn() and then transfers the tokens to the user. An attacker can exploit this by calling back into the withdraw() function before the transfer is completed, causing a double withdrawal.
p30_1	1	withdraw	Reentrancy Vulnerability	The `withdraw` function allows tokens to be withdrawn from the Controller, but it does not prevent reentrancy attacks. An attacker could exploit this vulnerability by calling the `withdraw` function repeatedly before the state is updated, causing a loss of assets.
p30_1	2	inCaseStrategyGetStuck	Lack of Access Control	The `inCaseStrategyGetStuck` function allows the strategist to withdraw tokens from the strategy and transfer them to the treasury. However, it does not validate if the `_token` address is actually a token managed by the strategy, which might result in loss of assets.
p30_1	3	inCaseTokensGetStuck	Lack of Access Control	The `inCaseTokensGetStuck` function allows the strategist to transfer tokens from the Controller to the treasury. However, it does not validate if the `_token` address is actually a token managed by the Controller, which might result in loss of assets.
p29_1	1	flashSwap	Reentrancy	In the `flashSwap` function, the callback to the `tridentSwapCallback` function is done before updating the reserves, which allows the callee to call `flashSwap` again, leading to a reentrancy attack.
p29_1	1	flashSwap	Reentrancy	The flashSwap function allows for a reentrancy vulnerability, as it calls an external contract (ITridentCallee) before updating the balance. This can potentially lead to an attacker re-entering the contract and draining the pool's funds.
p29_1	1	flashSwap	Reentrancy	The flashSwap function allows a caller to execute a swap without providing the required input amount, making the contract vulnerable to reentrancy attacks.
p29_1	2	_getAmountOut	Integer Overflow	The _getAmountOut function multiplies amountIn by token0PrecisionMultiplier or token1PrecisionMultiplier without checking for potential overflows.
p25_3	1	setSources	Reentrancy	The 'setSources' function iterates over the input arrays and calls '_setSource' for each element. An attacker can potentially use a malicious contract as one of the sources to execute a reentrancy attack when '_setSource' is called.
p25_3	1	setSources	Reentrancy	The 'setSources' function iterates over the input arrays and calls '_setSource' for each element. An attacker can potentially use a malicious contract as one of the sources to execute a reentrancy attack when '_setSource' is called.
p25_3	2	_peek, _get	Integer Overflow and Underflow	In both '_peek' and '_get' functions, price calculations can cause integer overflow or underflow when rawPrice or source.decimals are too large or too small.
p25_3	1	claim	Reentrancy	The 'claim' function allows an external call to 'rewardsToken.transfer', which can potentially enable a reentrancy attack if the rewardsToken is a malicious contract.
p25_3	2	_updateRewardsPerToken, _updateUserRewards	Integer Overflow and Underflow	In '_updateRewardsPerToken' and '_updateUserRewards', arithmetic operations are performed without using SafeMath, which can lead to integer overflow or underflow if the values are too large or too small.
p24_3	1	supplyTokenTo	Reentrancy	The function `supplyTokenTo` is susceptible to reentrancy attacks because it first transfers tokens to this contract and then mints shares without checking if the balances are correctly updated.
p28_3	1	initToken	No access control on `initToken`	The `initToken` function can be called by anyone, allowing for potential abuse of token minting and unauthorized role assignment.
p28_3	2	mint	Reentrancy	The `mint` function is not reentrancy-safe, as it interacts with an external contract (`_moveDelegates`) after updating the state, which can be exploited by a malicious contract.
p28_3	3	delegateBySig	Signature replay attack	The `delegateBySig` function does not check if the signature has already been used, allowing for replay attacks.
p28_3	1	finalize	Reentrancy	The finalize function is vulnerable to reentrancy attacks because it calls external contracts (market.finalize() and IWETH(weth).deposit{value : launcherBalance}();) before updating the launcherInfo.launched state.
p28_3	2	depositToken1, depositToken2	Front-Running	The depositToken1 and depositToken2 functions are vulnerable to front-running attacks because they allow the sender to deposit tokens before the auction ends, which could result in different amounts than intended.
p28_3	3	initAuctionLauncher	Lack of input validation	In the initAuctionLauncher function, there is no validation to ensure that token1 and token2 are distinct tokens, which may cause unexpected behavior.
p28_3	1	commitEth	Reentrancy	The function commitEth allows users to commit ETH to the crowdsale. However, the function makes an external call to transfer the refunded ETH back to the sender before updating the commitmentsTotal. This creates a potential reentrancy vulnerability.
p28_3	2	commitTokensFrom	Reentrancy	The function commitTokensFrom allows users to commit tokens to the crowdsale. However, the function makes an external call to transfer tokens before updating the commitmentsTotal. This creates a potential reentrancy vulnerability.
p28_2	1	commitEth	Reentrancy	The function allows users to commit ETH to the crowdsale, but it doesn't properly protect against reentrancy attacks, which may result in double withdrawals or other unintended behavior.
p28_2	2	commitTokensFrom	Reentrancy	Similar to the commitEth function, the commitTokensFrom function allows users to commit tokens to the crowdsale but does not properly protect against reentrancy attacks.
p28_2	1	finalize	Reentrancy	The `finalize` function is marked as nonReentrant, but it calls the external `market.finalize()` function before setting `launcherInfo.launched` to true, which may potentially introduce reentrancy risks.
p28_2	2	initAuctionLauncher	Lack of input validation	The `initAuctionLauncher` function does not check if the `_market` and `_factory` addresses are valid, i.e., non-zero addresses. Failing to validate these inputs may lead to unexpected behavior or loss of assets.
p28_2	0	N/A	None	There are no high-risk bugs in the provided Solidity smart contract that can cause asset loss or are exploitable.
p25_2	1	setSource, setSources	Reentrancy	These functions change the state of the contract after external calls, which can potentially lead to reentrancy attacks if the `auth` modifier does not properly protect against reentrant calls.
p25_2	2	peek, get	Integer Division Precision Loss	The calculation `price * amount / 1e18` may lead to precision loss when dealing with small values. This can result in inaccurate pricing.
p25_2	3	_peek	Front-Running	The `_peek` function uses the `block.timestamp` for the update time. Miners can manipulate the block timestamp within a certain range, allowing them to front-run transactions with better oracle data.
p25_2	1	setSource, setSources	Reentrancy	These functions change the state of the contract after external calls, which can potentially lead to reentrancy attacks if the `auth` modifier does not properly protect against reentrant calls.
p25_2	2	peek, get	Integer Division Precision Loss	The calculation `price * amount / 1e18` may lead to precision loss when dealing with small values. This can result in inaccurate pricing.
p25_2	3	_peek, _get	Front-Running	The `_peek` and `_get` functions use the `block.timestamp` for the update time. Miners can manipulate the block timestamp within a certain range, allowing them to front-run transactions with better oracle data.
p25_2	1	_updateUserRewards	Integer Overflow and Underflow	The multiplication `_balanceOf[user] * (rewardsPerToken_.accumulated - userRewards_.checkpoint)` may cause overflow. It also lacks checks for potential underflow of the subtraction `rewardsPerToken_.accumulated - userRewards_.checkpoint`.
p25_2	2	claim	Reentrancy	The `claim` function makes an external call to `rewardsToken.transfer` before setting the user's rewards to zero. This could potentially lead to a reentrancy attack if the `rewardsToken` contract is not secure.
p24_2	null
p28_1	1	initToken	No Access Control on initToken function	The initToken function is public, allowing anyone to initialize the token and set the owner and initial supply. This could lead to asset loss if a malicious user reinitializes the token and claims ownership.
p28_1	2	initToken	Multiple Initialization	The initToken function can be called multiple times, leading to potential re-initialization attacks and asset loss.
p28_1	1	finalize	Reentrancy	The finalize function is vulnerable to a reentrancy attack since it allows external calls before updating its state. An attacker can exploit this by calling the finalize function recursively and drain the contract's funds.
p28_1	1	commitEth	Reentrancy vulnerability	The `commitEth` function is vulnerable to reentrancy attacks as it performs external calls using the `transfer()` function before updating the state. The external call allows an attacker to re-enter the function and manipulate the contract state, potentially causing asset loss.
p25_1	1	claim	Reentrancy	The claim function updates rewards and transfers tokens to the user. It is vulnerable to reentrancy attacks because an attacker can call the function recursively through a malicious contract's fallback function, draining the rewardsToken balance.
p25_1	null
p25_1	null
p24_1	1	redeemToken	Reentrancy	The redeemToken function is susceptible to a reentrancy attack as it updates the internal state after external calls.
p24_1	2	supplyTokenTo	Reentrancy	The supplyTokenTo function is susceptible to a reentrancy attack as it updates the internal state after external calls.
p23_3	1	enableWBTC	Missing input validation	The enableWBTC function can be called by any external address, potentially causing the approval state to change unexpectedly.
p23_3	2	notionalCallback	Reentrancy	The notionalCallback function interacts with external contracts through NotionalV1Erc1155.batchOperationWithdraw, WETH.withdraw, and NotionalV2.depositUnderlyingToken. This could potentially allow for reentrancy attacks, especially when calling NotionalV1Erc1155.batchOperationWithdraw.
p23_3	1	transferFrom	Re-entrancy vulnerability	The 'transferFrom' function emits 'Transfer' and 'Approval' events before the actual transfer is completed, which could lead to a re-entrancy attack. An attacker could use these emitted events to re-enter the function and manipulate the state before the actual transfer is completed.
p23_3	1	enableToken	Missing access control	The 'enableToken' function is missing an access control modifier, which allows anyone to call the function and approve the spender for the given token. This can lead to a loss of assets if an attacker takes advantage of this vulnerability.
p23_3	1	nTokenTransferApproveAll	Reentrancy	The 'nTokenTransferApproveAll' function emits an 'Approval' event before updating the state. An attacker could exploit this by creating a malicious contract that listens to this event and then calls the function again, causing a reentrant call.
p23_3	2	nTokenClaimIncentives	Integer Overflow	The 'nTokenClaimIncentives' function uses 'totalIncentivesClaimed.add()' without checking for integer overflow, which may lead to incorrect token balances.
p23_3	1	getDiscountFactor	Integer Overflow	The multiplication `oracleRate.mul(timeToMaturity)` can cause an integer overflow since there is no upper bound check.
p23_3	2	getRiskAdjustedPresentValue	Integer Underflow	The subtraction `oracleRate - debtBuffer` can cause an integer underflow since there is no lower bound check.
p21_3	1	strategyWithdraw	Reentrancy	The function allows for withdrawing assets from the strategy but updates the stake balance after the withdrawal. This can lead to a reentrancy attack if the strategy contract calls back into the PoolStrategy contract during the withdrawal.
p21_3	2	strategyUpdate	Missing access control	The function allows updating the strategy without any access control, which could enable an attacker to set a malicious strategy.
p21_3	1	stake	Missing access control	The stake function is missing access control, allowing anyone to stake tokens on behalf of another address. This could lead to unexpected token transfers or unapproved stakes.
p21_3	1	unstake	Reentrancy	The 'unstake' function is vulnerable to reentrancy attacks because it first transfers the tokens to the recipient and then updates the stake balance and unstake entry.
p20_3	1	calcLiquidityUnits	Integer Overflow	The multiplication operation in the calculation of units might result in an integer overflow when the input values are large enough.
p20_3	2	getSlipAdustment	Integer Overflow	The multiplication operation in the calculation of the slip adjustment might result in an integer overflow when the input values are large enough.
p20_3	3	calcSwapOutput	Integer Overflow	The multiplication operation in the calculation of swap output might result in an integer overflow when the input values are large enough.
p20_3	4	calcSwapFee	Integer Overflow	The multiplication operation in the calculation of swap fee might result in an integer overflow when the input values are large enough.
p20_3	1	depositForMember	Reentrancy	The 'depositForMember' function calls the external '_deposit' function after the token transfer. The '_deposit' function emits an event which might allow reentrancy attacks.
p20_3	2	harvestSingle	Integer Overflow	The '_secondsSinceClaim' value in 'calcCurrentReward' function can overflow if a user has not claimed rewards for a long time, causing incorrect reward calculations.
p20_3	1	burnSynth()	Reentrancy	The burnSynth() function calls an external contract (Pool) without implementing a reentrancy guard. This could potentially allow a reentrancy attack.
p20_3	2	decreaseAllowance()	Arithmetic Overflow/Underflow	When calculating the decreased allowance, if the subtractedValue is greater than the current allowance, it would result in an underflow.
p20_3	3	_handleTransferIn()	Arithmetic Overflow/Underflow	The _handleTransferIn() function calculates the actual received amount by subtracting the start balance from the final balance, which could potentially result in an underflow.
p20_3	1	swapTo	Reentrancy	The swapTo function in the Router contract is vulnerable to reentrancy attacks because it performs external calls to other contracts (buyTo and sellTo) before updating the contract's state.
p20_3	2	buyTo, sellTo	No function access control	The buyTo and sellTo functions in the Router contract are missing access controls, allowing anyone to call them directly, bypassing the intended access control of the swapTo function.
p20_3	1	removeForMember	Reentrancy	The removeForMember function transfers the funds to the member before updating the pool balances, allowing potential reentrancy attacks.
p20_3	2	addForMember	No access control	The addForMember function is public and can be called by anyone, allowing unauthorized users to add liquidity on behalf of other users.
p20_2	1	transfer	Reentrancy	The `transfer` function can be exploited by a reentrancy attack since it updates the balances after emitting the Transfer event. If the recipient is a malicious contract, it can call back into the `transfer` function, causing unexpected behavior.
p20_2	2	addForMember	No Input Validation	The `addForMember` function does not validate if the input token and base amounts are non-zero, which can lead to potential issues when calculating the liquidity units and updating the pool balances.
p20_2	3	removeForMember	No Input Validation	The `removeForMember` function does not validate if the pool balance is sufficient before processing the removal, which can lead to underflow errors and incorrect pool balance updates.
p20_2	1	buyTo, sellTo	Reentrancy	The buyTo and sellTo functions are prone to reentrancy attacks because they transfer funds to the recipient before updating the state (in getsDividend function). An attacker can exploit this by making a recursive call to the function before the state is updated.
p20_2	1	mintSynth	Reentrancy	The mintSynth function is vulnerable to reentrancy attacks due to the external call to _mint() before updating the state variables mapSynth_LPDebt and mapSynth_LPBalance.
p20_2	2	burnSynth	Reentrancy	The burnSynth function is vulnerable to reentrancy attacks due to the external call to Pool(msg.sender).burn(_amountUnits) before updating the state variables mapSynth_LPDebt and mapSynth_LPBalance.
p20_2	3	realise	Reentrancy	The realise function is vulnerable to reentrancy attacks due to the external call to Pool(pool).burn(premiumLP) before updating the state variable mapSynth_LPBalance.
p20_2	1	harvestSingle	Reentrancy	The `harvestSingle` function calls an external contract (`iPOOL(_poolOUT).mintSynth`) before updating the user's state, which opens the function to reentrancy attacks.
p20_2	2	_addVaultMetrics	Integer Overflow	The `_addVaultMetrics` function adds the `_fee` to `map30DVaultRevenue` without checking for integer overflow, which can cause the value to wrap around.
p20_2	1	calcShare	Integer Overflow	An integer overflow may occur when multiplying 'amount' and 'part', which can lead to incorrect calculations.
p20_2	2	calcLiquidityHoldings	Reentrancy	The 'calcLiquidityHoldings' function calls external contracts, which might introduce reentrancy vulnerabilities if not properly handled.
p21_2	1	unstake	Reentrancy	The 'unstake' function allows for a reentrancy attack by calling the '_token.safeTransfer' function before updating the user's lock and stake balances, allowing the attacker to repeatedly call the function and withdraw more tokens than they should be able to.
p21_2	1	_stake	Reentrancy Attack	This contract is vulnerable to a reentrancy attack because it transfers tokens before updating the state (i.e., updating the user's stake). An attacker can potentially exploit this vulnerability to drain the contract of its funds.
p21_2	2	stake	Front-Running Attack	The stake function is vulnerable to a front-running attack. Attackers can monitor the pending transactions and submit their own transactions with a higher gas price to ensure their transactions are executed first. This can cause issues for honest users who might have their transactions stuck or skipped.
p21_2	1	strategyUpdate	Front-Running Attack	The strategyUpdate function is vulnerable to a front-running attack. An attacker can monitor the pending transactions and front-run the strategy update with their own malicious strategy, causing potential asset loss.
p21_2	2	strategyDeposit, strategyWithdraw, strategyWithdrawAll	Unsafe External Calls	The functions make external calls to the strategy contract which may be malicious, causing potential asset loss or manipulation of the pool's state.
p23_2	1	_transfer	Reentrancy	The _transfer function updates balances and claims incentives without using any reentrancy guard. This could potentially allow a malicious contract to exploit the function during an external call, leading to asset loss.
p23_2	1	migrateBorrowFromCompound	Reentrancy	The function calls NotionalV2.batchBalanceAndTradeActionWithCallback, which can call notionalCallback, potentially leading to reentrancy if a malicious NotionalProxy is used.
p23_2	2	enableToken	Missing Access Control	The function allows the owner to set an unlimited allowance on the CTokenInterface token for any spender, which might be abused by malicious actors.
p23_2	1	migrateDaiEther, migrateUSDCEther, migrateDaiWBTC, migrateUSDCWBTC	Reentrancy	The functions call NotionalV2.batchBalanceAndTradeActionWithCallback, which can call notionalCallback, potentially leading to reentrancy if a malicious NotionalProxy is used.
p23_2	2	enableWBTC	Missing Access Control	The function allows any user to set an unlimited allowance for NotionalV2 to spend WBTC tokens held by the contract, which could be abused by malicious actors.
p23_2	1	approve	Unhandled Return Values	The function does not check the return value of proxy.nTokenTransferApprove, which may return false, indicating failure.
p23_2	2	transfer	Unhandled Return Values	The function does not check the return value of proxy.nTokenTransfer, which may return false, indicating failure.
p23_2	3	transferFrom	Unhandled Return Values	The function does not check the return value of proxy.nTokenTransferFrom, which may return false, indicating failure.
p23_2	1	getSettlementDate	Integer Overflow	The function getSettlementDate is vulnerable to integer overflow when adding Constants.QUARTER to the result of asset.maturity.sub(marketLength).
p23_1	1	getDiscountFactor	Integer Overflow	The multiplication of oracleRate and timeToMaturity can cause an integer overflow.
p23_1	2	getSettlementDate	Integer Underflow	The subtraction of marketLength from asset.maturity can cause an integer underflow.
p23_1	3	getRiskAdjustedPresentValue	Integer Underflow	The subtraction of oracleRate and debtBuffer can cause an integer underflow.
p23_1	4	_calcToken	Integer Overflow	The multiplication of numerator, tokens, and haircut can cause an integer overflow.
p23_1	1	constructor	Missing input validation	The constructor does not validate the input parameters, which could lead to a misconfigured contract.
p23_1	2	transfer	Re-entrancy	The function emits the Transfer event before calling the nTokenTransfer function, which may lead to re-entrancy attacks.
p23_1	3	transferFrom	Re-entrancy	The function emits the Transfer and Approval events before calling the nTokenTransferFrom function, which may lead to re-entrancy attacks.
p23_1	1	notionalCallback	Reentrancy	notionalCallback performs external calls to NotionalV1Erc1155.batchOperationWithdraw() and NotionalV2.depositUnderlyingToken() which may potentially introduce reentrancy risks.
p23_1	2	notionalCallback	Missing access control	notionalCallback lacks access control and can be called by anyone, potentially allowing unauthorized actions or manipulation.
p23_1	3	enableWBTC	Improper ERC20 token handling	enableWBTC approves an unlimited amount of WBTC tokens to NotionalV2 without checking if the approval was successful or not.
p23_1	1	notionalCallback	Reentrancy	notionalCallback performs external calls to CErc20Interface.repayBorrowBehalf() and NotionalV2.depositAssetToken() which may potentially introduce reentrancy risks.
p23_1	2	notionalCallback	Missing access control	notionalCallback lacks access control and can be called by anyone, potentially allowing unauthorized actions or manipulation.
p23_1	3	enableToken	Missing access control	enableToken allows the owner to set an infinite approval for any token, potentially causing asset loss if a malicious spender is set.
p23_1	1	_transfer	Reentrancy	The `_transfer` function may be vulnerable to a reentrancy attack, as external calls (through `senderBalance.finalize` and `recipientBalance.finalize`) are made before the state is updated. An attacker may exploit this vulnerability to repeatedly call the `_transfer` function and drain the funds.
p21_1	1	unstake	Reentrancy	The 'unstake' function is vulnerable to reentrancy attacks because it calls an external contract '_token.safeTransfer' after modifying the state variables 'ps.stakeBalance' and 'ps.unstakeEntries[msg.sender][_id]'.
p21_1	2	setCooldownFee	No data validation	The 'setCooldownFee' function does not validate the input '_fee' value, allowing a high fee to be set which could make staking and unstaking too costly for users.
p21_1	1	stake	Reentrancy	The `stake` function is vulnerable to a reentrancy attack because it first transfers the funds (calling an external contract `_token.safeTransferFrom`) and then updates the state (`lock = LibPool.stake(ps, _amount, _receiver);`). A malicious token contract could exploit this to call `stake` again before the state is updated, leading to potential asset loss.
p21_1	2	baseData	Uninitialized Storage Pointer	The function `baseData()` does not properly return the storage pointer for `PoolStorage.Base storage ps`. The function returns without an explicit return statement, causing the uninitialized storage pointer to be returned, which could result in unpredictable behavior.
p21_1	1	strategyDeposit	Reentrancy	The `strategyDeposit` function is vulnerable to a reentrancy attack because it first transfers the funds (calling an external contract `_token.safeTransfer`) and then updates the state (`ps.strategy.deposit();`). A malicious strategy contract could exploit this to call `strategyDeposit` again before the state is updated, leading to potential asset loss.
p21_1	2	strategyWithdraw	Reentrancy	The `strategyWithdraw` function is vulnerable to a reentrancy attack because it first calls an external contract `ps.strategy.withdraw(_amount)` and then updates the state (`ps.stakeBalance = ps.stakeBalance.add(_amount);`). A malicious strategy contract could exploit this to call `strategyWithdraw` again before the state is updated, leading to potential asset loss.
p21_1	3	baseData	Uninitialized Storage Pointer	The function `baseData()` does not properly return the storage pointer for `PoolStorage.Base storage ps`. The function returns without an explicit return statement, causing the uninitialized storage pointer to be returned, which could result in unpredictable behavior.
p20_1	1	calcAsymmetricValueToken	Reentrancy	The calcAsymmetricValueToken function is exposed to a reentrancy attack since it calls the calcSwapValueInTokenWithPool function which in turn may call an external contract (iPOOL(pool)) and the state is not updated before the call.
p20_1	2	calcLiquidityUnits	Integer Overflow	In the calcLiquidityUnits function, the calculation "uint part1 = t*(B);" and "uint part2 = T*(b);" can cause integer overflow if the values of t, B, T, and b are large enough.
p20_1	3	getSlipAdustment	Integer Underflow	In the getSlipAdustment function, the calculation "numerator = part1 - (part2);" and "numerator = part2 - (part1);" can cause integer underflow if part1 is smaller than part2 or vice versa.
p20_1	1	depositForMember	Reentrancy	depositForMember allows external contract calls by transferring tokens using iBEP20(synth).transferFrom(msg.sender, address(this), amount). This could lead to reentrancy attacks where an attacker manipulates the external call to re-enter the function before the initial call is completed.
p20_1	2	harvestSingle	Reentrancy	harvestSingle function is vulnerable to reentrancy attacks due to external contract calls such as iRESERVE(_DAO().RESERVE()).grantFunds(reward, _poolOUT) and iPOOL(_poolOUT).mintSynth(synth, address(this)). An attacker could manipulate these calls to re-enter the function before it finishes executing.
p20_1	1	mintSynth	Reentrancy	The `mintSynth` function can be called by a malicious pool contract, which in turn can call `mintSynth` again before the state is updated, leading to a reentrancy attack.
p20_1	2	burnSynth	Reentrancy	The `burnSynth` function can be called by a malicious user, who can call `burnSynth` again before the state is updated, leading to a reentrancy attack.
p20_1	1	removeLiquidityExact	Reentrancy	The function transfers the funds to the user before updating the state, which makes it vulnerable to reentrancy attacks.
p20_1	2	removeLiquiditySingle	Reentrancy	The function transfers the funds to the user before updating the state, which makes it vulnerable to reentrancy attacks.
p20_1	1	removeForMember	Reentrancy	The function transfers assets before updating the pool balances and burning the liquidity tokens, which allows for potential reentrancy attacks.
p20_1	2	mintSynth	Reentrancy	The function transfers assets before updating the pool balances and adding pool metrics, which allows for potential reentrancy attacks.
p20_1	3	burnSynth	Reentrancy	The function transfers assets before updating the pool balances and adding pool metrics, which allows for potential reentrancy attacks.
p20_1	1	createPoolADD	Reentrancy	The function createPoolADD is vulnerable to reentrancy attacks because external calls to untrusted contracts are made before updating the state of the contract.
