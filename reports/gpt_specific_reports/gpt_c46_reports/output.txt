d125_3	1	_withdrawFromYieldPool	Unexpected function invocation arguments, sequences or frequncies	In the `_withdrawFromYieldPool` function, there's a potential reentrancy vulnerability. The function sends ETH to the user before updating the internal state. An attacker could exploit this vulnerability by calling the function recursively to drain the contract funds. To fix this, the state should be updated before transferring the funds, and the contract should use a reentrancy guard to prevent nested calls.
d125_3	2	processYield	Business-flow atomicity violations	In the `processYield` function, there's no check to ensure that the received ETH amount is correct after the `CurveswapAdapter.swapExactTokensForTokens` call. If the received ETH amount is less than expected, it can cause an incorrect WETH deposit, and the yield manager might not receive the correct amount of WETH. To fix this, the contract should validate the received ETH amount and revert the transaction if it's less than expected.
d125_3	3	depositCollateral	Unexpected environment or contract conditions	In the depositCollateral function, there is no check to ensure that the _amount is greater than 0. If someone calls this function with 0 as _amount, it will not throw an error and will emit a DepositCollateral event, which may not be the desired behavior.
d100_3	1	deposit	Unexpected environment or contract conditions	The deposit function relies on the balance of the base token in the contract to calculate the amount to deposit. However, an attacker could send tokens to the contract address to manipulate the balance and disrupt the calculation of the deposit amount.
d100_3	2	deposit	Business-flow atomicity violations	The deposit function calculates the amount to deposit by calling the balanceOf function of the base token. This creates a race condition where the deposit function could be called by another user before the previous deposit transaction is finished, causing an incorrect deposit calculation.
d100_3	3	withdraw	Business-flow atomicity violations	Similar to the deposit function, the withdraw function calculates the amount to withdraw using the balanceOf function of the base token. This creates a race condition where the withdraw function could be called by another user before the previous withdrawal transaction is finished, causing an incorrect withdrawal calculation.
d100_3	4	setMintingFee and setRedemptionFee	Unexpected function invocation arguments	The setMintingFee and setRedemptionFee functions do not validate if the new fee values are within reasonable limits (e.g., 0 <= fee <= FEE_LIMIT). Although there is a check for the fee not exceeding the FEE_LIMIT, there is no check to ensure that the fee is non-negative. This could lead to potential issues if a negative fee value is passed.
d100_3	5	initiateWithdrawal and uninitiateWithdrawal	Unexpected function invocation sequences or frequencies	Users can initiate and uninitiate withdrawal requests multiple times without any restriction. This could be exploited by an attacker to spam the contract with multiple withdrawal requests or cancel them frequently, leading to increased gas costs for other users.
d97_3	1	depositErc20	Unexpected environment or contract conditions	The depositErc20 function has a potential vulnerability where an outdated ChainLink oracle might be used to calculate rewards or fees. If the oracle returns outdated data, the rewards or fees might not be accurate, potentially causing financial losses to users.
d97_3	2	sendFundsToUser	Business-flow atomicity violations	The sendFundsToUser function updates the processedHash mapping only after performing the transfer. In the case where the transfer fails (e.g., due to an exception in the receiver contract), the processedHash would still be updated, and the user would be unable to retry the transfer. The function should be updated to update the processedHash mapping only after a successful transfer.
d192_1	1	deposit	Unexpected environment or contract conditions	The deposit function does not validate if the `_amount` is greater than zero. If a user deposits 0 tokens, the contract will still mint stable tokens for the user, which could cause unexpected outcomes.
d192_1	2	withdraw	Unexpected environment or contract conditions	Similar to the deposit function, the withdraw function does not validate if the `_amount` is greater than zero. If a user withdraws 0 stable tokens, the contract will still try to transfer tokens to the user, which could cause unexpected outcomes.
d192_1	3	deposit, withdraw	Business-flow atomicity violations	In both deposit and withdraw functions, there is no proper synchronization or atomicity between token transfer and stable token mint/burn. If an error occurs during the minting or burning of stable tokens (e.g., due to a reentrancy attack), it can lead to an imbalance between the tokens in the contract and the stable tokens.
d192_1	4	depositWithPermit	Unexpected function invocation arguments	The depositWithPermit function allows the user to deposit tokens using the permit function to approve the transfer. However, the deposit function is called after the permit function, which means that the tokens have already been approved for transfer. This could lead to a situation where a malicious user can approve an excessive amount of tokens and then call the deposit function multiple times, leading to unexpected behavior.
d192_1	5	listToken, delistToken	Unexpected environment or contract conditions	Both the listToken and delistToken functions can only be called by the contract owner. However, there is no mechanism for transferring ownership of the contract or for the owner to renounce their ownership. This means that the owner retains full control over the contract indefinitely, which could lead to centralization and trust issues.
d143_1	null
d143_1	null
d143_1	null
d125_1	1	CurveswapAdapter.swapExactTokensForTokens	Unexpected function invocation arguments	In the processYield() and _withdrawFromYieldPool() functions, the CurveswapAdapter.swapExactTokensForTokens() function is called with the 'minAmountOut' parameter set to a fixed value of 200. This value represents the minimum amount of output tokens expected in the swap, but it is not adjusted according to the input amount or the market conditions. This may result in the swap failing if the slippage is higher than expected or if the input amount is very low. It is recommended to use a dynamic 'minAmountOut' value based on slippage tolerance.
d125_1	2	processYield	Unexpected environment or contract conditions	The processYield() function assumes that the yield from lendingPool is in stETH, and then converts it to ETH using CurveswapAdapter. However, there is a possibility that the lendingPool could return an outdated yield value or that the stETH/ETH price on Curve is outdated. This can lead to incorrect calculations and potential losses for the users. To mitigate this risk, it is recommended to use an oracle to fetch the latest stETH/ETH price and compare it with the price on Curve before proceeding with the conversion.
d125_1	1	depositCollateral	Unexpected function invocation arguments	The depositCollateral function does not have any checks on the input parameters for _asset and _amount. It is possible that a user can invoke the function with an incorrect or malicious asset address or an unexpected amount, which could lead to undesired results.
d125_1	2	setTreasuryInfo	Unexpected environment or contract conditions	The setTreasuryInfo function allows the admin to set the treasury address and the vault fee. However, there is no check to ensure that the treasury address being set is not the same as the contract address, which could lead to unexpected behavior.
d100_1	1	deposit	Business-flow atomicity violation	In the `deposit` function, the contract calculates the fees based on the `_baseToken.balanceOf(address(this))`. However, this may include tokens that were transferred to the contract by mistake or by a malicious actor, causing an incorrect calculation of fees. It's possible that this could lead to loss of funds for the depositor or the contract.
d97_1	1	depositErc20	Unexpected environment or contract conditions	The function depositErc20 allows for a user to deposit an ERC20 token into the liquidity pool, but there is no check for the possibility of outdated or stale data from the ChainLink oracle. This could potentially result in incorrect deposit amounts or imbalances in the liquidity pool.
d97_1	2	sendFundsToUser	Unexpected function invocation arguments	The function sendFundsToUser is responsible for sending funds to the user. However, it accepts a tokenGasPrice argument without validating it. An attacker could potentially exploit this by providing an extremely low tokenGasPrice, causing the contract to underestimate the gas fee and send more tokens to the user than expected.
d90_3	1	mint	Business-flow atomicity violations	The mint function is vulnerable to business-flow atomicity violations due to the lack of checks and locks during the minting process. A potential race condition could occur if two or more transactions call the mint function simultaneously, leading to incorrect calculations and unintended distribution of tokens.
d83_3	1	donate	Unexpected function invocation arguments	The `donate` function does not validate the input of `_amount`. A user could potentially donate 0 tokens, which may not be the intended behavior. To fix this, you could add a require statement to ensure the donated amount is greater than 0:
d83_3	2	deactivate	Unexpected environment or contract conditions	The `deactivate` function has a logical error in the `require` statement. It checks if the grace period is over, but it should check if the grace period is still active. The correct check would be:
d81_3	null
d51_3	null
d94_1	null
d94_1	null
d94_1	1	makeOffer	Business-flow atomicity violation	The makeOffer function allows users to make offers on NFTs, but it lacks proper checks for the token's ownership status. An offer could be made on an NFT that has been transferred to a new owner, leading to an inconsistency in the offer process.
d94_1	2	acceptOffer	Unexpected environment or contract conditions	The acceptOffer function does not check if the caller (msg.sender) is the actual owner of the NFT before proceeding with the offer acceptance. This can lead to unauthorized users being able to accept offers on NFTs they do not own.
d94_1	null
d90_1	1	mint	Business-flow atomicity violations	In the 'mint' function, the loop that iterates over the assets and mints vTokens is not atomic. If any of the vToken.mint() calls fail or revert due to external factors, the whole transaction will fail, but some vTokens may have been already minted, leading to an inconsistent state.
d90_1	2	mint	Unexpected function invocation arguments, sequences or frequencies	The mint function does not have any restrictions on who can call it or how many times it can be called. This can lead to unexpected minting of tokens by arbitrary addresses, affecting the index's value and potentially enabling manipulation of the index by malicious actors.
d90_1	3	burn	Unexpected environment or contract conditions	The burn function does not check for slippage or outdated data when interacting with price oracle. If the price oracle returns outdated data, the function might not properly distribute assets when burning the index, leading to an incorrect distribution of underlying assets to the _recipient. This can result in losses for the index holders.
d90_1	4	burn	Unexpected function invocation arguments, sequences or frequencies	The burn function does not have any restrictions on who can call it or how many times it can be called. This can lead to unexpected burning of tokens by arbitrary addresses, affecting the index's value and potentially enabling manipulation of the index by malicious actors.
d83_1	2	deactivate	Unexpected function invocation arguments, sequences or frequencies	The `deactivate` function can be called even after a token has been deactivated, which could lead to unwanted behavior such as transferring the token balance to the `msg.sender` repeatedly. To fix this issue, add a condition to check if the token is already deactivated before performing the deactivation.
d83_1	3	donate	Unexpected function invocation arguments, sequences or frequencies	The `donate` function allows users to donate tokens to the contract. However, there is no check to ensure that the `_amount` parameter is greater than zero. This could lead to users calling the function with a zero value, resulting in wasted gas fees and unnecessary events. Add a check to ensure that the donated amount is greater than zero.
d81_1	null
d51_1	1	airdropTokens	Business-flow atomicity violation	The function airdropTokens() iterates through the array of addresses (airdropArray) and sends tokens to each address. If the contract runs out of gas or encounters an error during the airdrop, some addresses may not receive tokens, resulting in an incomplete token distribution. A better approach would be to split the airdrop into smaller batches, allowing users to trigger the function and distribute tokens for a specific range of addresses.
d71_3	1	createMarket	Business-flow atomicity violation	In the `createMarket` function, the contract checks for the existence of a market with the same template and reference[0]. If a market with the same template and reference[0] exists and the template does not allow duplicates, the function reverts. However, between the existence check and the revert, an attacker could create a market with the same template and reference[0], which might lead to an undesired state.
d71_3	1	initialize	Unexpected environment or contract conditions	The "initialize" function lacks any access control, which could lead to potential re-initialization attacks by external entities. The function should have a modifier to limit the access to a specific role or address, like an owner or admin. To fix this issue, the addition of an "onlyOwner" or a similar access control modifier should be added to the "initialize" function.
d71_3	2	deposit	Business-flow atomicity violation	The "deposit" function updates the contract state by calling "_mint" before the "vault.addValue" function is called. If an attacker is able to cause the "vault.addValue" function to fail (e.g., by causing a revert), the contract state would be updated incorrectly. To fix this issue, "vault.addValue" should be called before the "_mint" function, and any contract state updates should only occur after all external contract calls are successful.
d71_3	3	insure	Unexpected function invocation arguments	The "insure" function allows a user to specify their "_maxCost" for the insurance premium, which may lead to unexpected results if a user submits a lower value than the actual premium calculated. To fix this issue, the function should either enforce a specific calculation or range for the insurance premium or provide a more precise way for users to calculate the required premium beforehand.
d71_3	4	applyCover	Unexpected environment or contract conditions	The "applyCover" function can be called by the contract owner to set the market status to "Payingout" and lock the index contracts. However, there is no validation to check if the provided incident information is accurate or up-to-date. This may lead to unexpected consequences if inaccurate information is provided by the contract owner. To fix this issue, additional validation or checks can be implemented to ensure the accuracy of the incident information provided.
d71_3	1	transferDebt	Business-flow atomicity violation	In the `transferDebt` function, there is no check to ensure that the _amount is less than or equal to the debt of the sender. This could lead to underflow if _amount is greater than the sender's debt, which may result in unintended consequences.
d71_3	2	addValueBatch	Unexpected function invocation arguments	The `addValueBatch` function expects _shares to sum up to 1000000. However, there is no restriction on the function input values for the _shares array. This can lead to unexpected function invocation arguments if the sum of the _shares array does not equal 1000000.
d70_3	null
d80_1	1	nonReentrant	Reentrancy	The contract utilizes a nonReentrant modifier to prevent reentrancy attacks. However, it uses a bool `_status` flag to implement the modifier, which is not as robust as the `ReentrancyGuard.sol` provided by OpenZeppelin. Using the OpenZeppelin's `ReentrancyGuard.sol` is recommended to have a better protection against reentrancy attacks.
d80_1	2	setApprovals	Unexpected environment or contract conditions	The function `setApprovals()` sets the maximum approval to the pool and convex booster contract to transfer funds from the wrapper. However, there is no access control on this function, and anyone can call it. This could lead to potential issues if a malicious user resets the approvals while a user interaction is in progress. It is recommended to add appropriate access control to this function to prevent unauthorized usage.
d80_1	3	_checkpoint, _checkpointAndClaim, user_checkpoint	Unexpected function invocation arguments	The `_checkpoint`, `_checkpointAndClaim`, and `user_checkpoint` functions accept an array of addresses as an argument. However, there is no validation of these addresses in the functions, which might lead to unexpected behavior when wrong addresses are supplied. It is recommended to add address validation in these functions to prevent any unwanted behavior.
d80_1	4	addRewards	Unexpected environment or contract conditions	The `addRewards` function is called in the constructor and can be called again afterward. If it is called multiple times, it would push duplicate reward tokens and pools to the `rewards` array, leading to unexpected contract behavior. It is recommended to add a check or a modifier to ensure that this function is only called once during the contract's lifecycle.
d80_1	1	removeVault	Unexpected function invocation arguments	In the `removeVault` function, the `account` parameter is used to identify the account whose vault needs to be removed. However, the function also checks if `account` is not equal to the owner of the vault. If this condition is true, the function proceeds to remove the vault. This can lead to unexpected behavior if someone accidentally or maliciously calls this function with an incorrect `account` parameter. The correct approach would be to check if `account` is equal to the owner of the vault and proceed only if this condition is true.
d80_1	2	wrap	Unexpected environment or contract conditions	In the `wrap` function, the contract uses the `from_` parameter to update the checkpoint but does not verify whether the `from_` parameter is the actual sender of the tokens. This can lead to unexpected behavior if the function is called with an incorrect `from_` parameter.
d78_1	1	enforceTolerance	Unexpected function invocation arguments	The enforceTolerance function is intended to enforce limits on a per-variable basis. However, the function is public and can be invoked by any external actor with arbitrary arguments, potentially causing unexpected behavior or manipulation of the enforceTolerance checks.
d78_1	2	assertGovernanceApproved	Business-flow atomicity violation	In the assertGovernanceApproved function, the transfer of tokens and the updating of the pendingFlashDecision mapping are not atomic. If the transfer of tokens fails, the function will revert, but if any other require statement fails, the changes in the pendingFlashDecision mapping will persist. This could potentially lead to inconsistent state.
d78_1	3	configureFlashGovernance, configureSecurityParameters	Unexpected environment or contract conditions	The configureFlashGovernance and configureSecurityParameters functions can only be called by successful proposals. However, if there are unexpected changes in the environment or contract conditions (e.g., due to ChainLink returning outdated data or slippage occurring), the new configuration could become invalid or suboptimal.
d78_1	4	assertGovernanceApproved	Unexpected function invocation sequences or frequencies	The assertGovernanceApproved function can be called at any frequency, and there is no limitation on the number of times it can be called within a single epoch. This could lead to unexpected sequences or frequencies of flash governance decisions, potentially causing governance issues or manipulation of the contract state.
d78_1	5	burnFlashGovernanceAsset	Unexpected environment or contract conditions	The burnFlashGovernanceAsset function depends on the burnable asset to implement the Burnable interface correctly. If the burnable asset contract has a bug or behaves unexpectedly, the burning of the asset might not happen as intended, resulting in potential loss of funds or contract misbehavior.
d77_1	1	addLiquidity	Unexpected environment or contract conditions	The `addLiquidity` function doesn't update internalBalances.baseTokenReserveQty and internalBalances.quoteTokenReserveQty after adding liquidity. This might cause the internal balances to be outdated, leading to incorrect calculations in subsequent operations.
d77_1	2	swapBaseTokenForQuoteToken	Unexpected function invocation arguments	The `swapBaseTokenForQuoteToken` function doesn't update the internalBalances after the swap, which may result in incorrect calculations for future swaps or liquidity provision/removal.
d77_1	3	swapQuoteTokenForBaseToken	Unexpected function invocation arguments	Similar to `swapBaseTokenForQuoteToken`, the `swapQuoteTokenForBaseToken` function doesn't update the internalBalances after the swap, which may result in incorrect calculations for future swaps or liquidity provision/removal.
d71_1	1	createMarket	Unexpected function invocation arguments	In the `createMarket` function, there is no validation for the length of the `_conditions` array and `_references` array. If an incorrect length is provided, this may lead to unexpected behavior, including incorrect market conditions or references.
d71_1	2	createMarket	Unexpected environment or contract conditions	The `createMarket` function assumes that the `_references[0]` element exists and is used without any validation. If the `_references` array is empty, this will lead to an out-of-bounds access error, causing the function to revert.
d71_1	1	initialize	Unexpected function invocation arguments	In the `initialize` function, there is a check that ensures various conditions are met before proceeding with the initialization. However, this check can lead to potential issues if the `_references` array does not have at least 5 elements. The check does not validate the length of the `_references` array. If `_references` has fewer than 5 elements, the function will throw an "Array out of bounds" error, leading to unexpected behavior.
d71_1	2	requestWithdraw and withdraw	Business-flow atomicity violations	The `requestWithdraw` and `withdraw` functions are separate, allowing the possibility of an atomicity violation. A user can request a withdrawal of a certain amount, and then the available balance can change (e.g., due to other withdrawals) before the user's withdrawal is processed. In this case, the user might not receive the expected amount, or their withdrawal might fail due to insufficient liquidity. This could be mitigated by combining the request and execution of withdrawals into a single atomic function.
d71_1	3	insure	Unexpected environment or contract conditions	The `insure` function calculates the premium based on the current state of the contract (totalLiquidity, lockedAmount, etc.). However, this may lead to unexpected results if the state of the contract changes significantly between the time when the user calculates the expected premium and the time when the `insure` function is called. For instance, this might occur if there are many deposits, withdrawals, or insurances in a short period. To address this issue, the contract could implement a mechanism to lock the state for a short duration during the insurance process.
d71_1	1	withdrawValue	Unexpected environment or contract conditions	In the `withdrawValue` function, the available balance of the contract is checked after the shortage is covered by `_unutilize` function call. However, there is no guarantee that the controller contract will return the expected amount of tokens when the `controller.withdraw` function is called in the `_unutilize` function. This may lead to an unexpected shortage of tokens in the contract.
d71_1	2	utilize	Business-flow atomicity violations	In the `utilize` function, the contract transfers the available balance to the controller and calls the `controller.earn` function. However, there is no guarantee that the `controller.earn` function will be executed successfully. If the `controller.earn` function fails or is manipulated to return before completing its intended actions, the tokens sent to the controller may be lost or stuck, leading to an atomicity violation in the business flow.
d71_1	3	addValueBatch	Unexpected function invocation arguments, sequences, or frequencies	In the `addValueBatch` function, the `_shares` array is expected to have a sum of 1000000. However, this requirement does not guarantee that the individual elements of the `_shares` array are within a valid range (0 to 1000000). If an element in the `_shares` array is larger than 1000000, it may lead to incorrect calculations of allocations and attributions for the beneficiaries.
d70_1	null
d61_3	null
d61_3	1	getChainlinkLatestPrice	Unexpected environment or contract conditions	There is a potential vulnerability with how the getChainlinkLatestPrice function checks the validity of the latest round data for the price feed. Specifically, the function checks if `answeredInRound1 < roundID1` and `answeredInRound2 < roundID2`, which can lead to a situation where the Chainlink Oracle returns outdated data when the latest round hasn't been answered yet, causing the function to return incorrect price data. A better approach would be to compare the `timeStamp1` and `timeStamp2` with a certain threshold, such as the current block timestamp, to ensure the data is not outdated.
d61_3	2	setChainlinkFeedAddress	Unexpected function invocation arguments	The setChainlinkFeedAddress function does not validate if the provided `priceOracle` address is a valid Chainlink AggregatorV3Interface contract. This can lead to a situation where an invalid address is added as a price oracle, causing the getChainlinkLatestPrice function to potentially fail or return unexpected results. To avoid this, you should add a check to ensure the `priceOracle` address is a valid Chainlink AggregatorV3Interface contract.
d64_3	null
d64_1	1	_requireTicket	Unexpected function invocation arguments	The _requireTicket function is using a staticcall to check if the _ticket address passed is valid. However, it doesn't check for a specific return value, which could lead to unexpected behavior. To mitigate this, the function should check the return value of the staticcall to ensure it matches the expected value.
d64_1	2	_calculateRewardAmount	Unexpected environment or contract conditions	The _calculateRewardAmount function calculates the reward amount for a specific user based on their average balance during an epoch. However, if the average total supply of the ticket is 0, the function returns 0 rewards. This may lead to unexpected results, as users with a balance during that epoch would not receive any rewards. To fix this issue, the contract should handle the case where the average total supply is 0, such as providing a minimum reward amount.
d64_1	3	_getRemainingRewards	Unexpected environment or contract conditions	The _getRemainingRewards function calculates the remaining rewards for a promotion by multiplying the tokens per epoch by the remaining epochs. However, it does not consider any rounding errors that may occur during division, leading to potential inaccuracies in the remaining rewards calculation. To address this, the contract should account for rounding errors in the calculation.
d61_1	1	setChainlinkFeedAddress	Unexpected function invocation arguments	There is no validation to check if the input `priceOracle` address is actually a valid Chainlink aggregator contract. A malicious owner can set an incorrect address as the oracle, which can lead to incorrect price data.
d61_1	2	getChainlinkLatestPrice	Unexpected environment or contract conditions	The function uses timestamp as an indicator of whether the price data is valid or not. However, it does not check if the timestamp is too old, which may lead to the use of outdated price data. This can be mitigated by checking if the timestamp difference is within an acceptable range.
d61_1	3	setUniswapFeedAddress	Unexpected function invocation arguments	There is no validation to check if the input `pool` address is a valid Uniswap pool contract. A malicious owner can set an incorrect address as the pool, which can lead to incorrect price data.
d61_1	null
d58_1	1	_push	Unexpected environment or contract conditions	The `_push` function assumes that the provided `options` will be well-formatted, and thus does not check for malformed input. This can lead to unexpected behavior when parsing the input using the `_parseOptions` function, which can return default values if the input is empty or of incorrect length. The `_push` function should include checks to ensure that the provided options are well-formatted to avoid potential issues.
d58_1	2	_pull	Unexpected function invocation arguments	The `_pull` function relies on the `_pullUniV3Nft` function to decrease liquidity and collect tokens. However, there is no check for whether the input `tokenAmounts` are valid or not. If the input contains invalid or unexpected values, it might lead to unexpected behavior when calculating the `liquidityToPull` value. The `_pull` function should include checks to ensure that the input token amounts are valid.
d52_3	1	swap	Unexpected function invocation arguments	The `swap` function allows users to provide either `nativeAmountIn` or `foreignAmountIn` to perform a swap. However, there is no check to ensure that both arguments are not greater than zero simultaneously. As a result, a user can perform a swap by providing both `nativeAmountIn` and `foreignAmountIn` greater than zero, which can lead to undesired behavior.
d52_3	2	mint	Business-flow atomicity violations	The `mint` function is not atomic in its execution, which means that if a user calls this function and the transaction fails due to any reason, the system's state may be left in an inconsistent state. In this case, if the `mint` function call fails after updating the `totalSupply`, the total supply would not correctly reflect the actual total supply in the system.
d52_3	3	_burn	Unexpected environment or contract conditions	The `_burn` function retrieves the balances of `nativeAsset` and `foreignAsset` before transferring the assets to the user. However, the balances are not checked again after the transfers, which can lead to an unexpected environment or contract conditions if the transfers fail or if there's a change in the balances between these two steps.
d52_3	null
d52_3	null
d54_1	2	purchase	Unexpected function invocation arguments, sequences, or frequencies	The 'purchase' function is vulnerable to front-running attacks. An attacker can observe pending transactions and potentially insert their transaction with higher gas fees to manipulate the state of the contract before the victim's transaction is processed. This can affect the purchase price of the tokens if the attacker modifies the 'keyPrice' before the victim's transaction is processed. To mitigate this, a commit-reveal scheme can be implemented to prevent front-running.
d54_1	3	purchase	Unexpected environment or contract conditions	The smart contract is dependent on external contract calls, such as the Unlock Protocol for computing discounts and the OnKeyPurchaseHook for modifying the purchase price. The behavior of these external contracts is not guaranteed, and they may return outdated data or introduce other unexpected conditions. It is essential to ensure the trustworthiness of the external contracts and monitor their updates regularly.
d54_1	null
d54_1	1	shareKey	Unexpected function invocation arguments	The `shareKey` function allows a user to share their key with another user by transferring a portion of the remaining time to a new key. However, it does not check if the `_timeShared` parameter is a valid value (e.g., non-negative). A user could potentially provide a large value, causing the new key to have an unexpectedly large expiration timestamp.
d54_1	2	transferFrom	Business-flow atomicity violation	In the `transferFrom` function, the key transfer process consists of several steps like updating the expiration timestamp, tokenId, and recording the new owner. However, there is no atomicity guarantee for these operations. If the contract execution fails during any of these steps (e.g., due to an out-of-gas exception), the contract state may be left in an inconsistent state with mismatched tokenId and expiration timestamps.
d54_1	3	getTransferFee	Unexpected environment or contract conditions	The `getTransferFee` function calculates the transfer fee based on the remaining time of the key and the `transferFeeBasisPoints`. However, if the `transferFeeBasisPoints` is updated by the lock manager during a transfer operation, it could cause inconsistencies in the fee calculation. The fee charged to the user might be different from the expected fee when the transfer was initiated.
d52_1	1	swap	Unexpected function invocation arguments	The function `swap` is overloaded with two different versions. One of them takes a calldata parameter, which is not used inside the function. This might lead to unexpected behavior when calling the function with calldata.
d52_1	2	mint, _burn, swap	Business-flow atomicity violations	The contract lacks proper input validation checks in the `mint`, `_burn`, and `swap` functions. This might result in incorrect calculations or unintended side effects during execution.
d52_1	3	_update	Unexpected environment or contract conditions	The `_update` function uses unchecked arithmetic when calculating the `timeElapsed`, which can lead to potential integer overflows or underflows. If the `block.timestamp` is somehow manipulated or if the reserve values are manipulated, this could lead to miscalculations.
d52_1	4	getReserves	Unexpected environment or contract conditions	The `getReserves` function exposes the internal state of the contract, which could lead to potential security risks. An attacker can read the reserves and potentially manipulate other contract functions that rely on these values.
d52_1	null
d52_1	1	enter	Unexpected function invocation arguments, sequences or frequncies	In the `enter` function, the `_amount` parameter could be zero, which may not be intended. It might be useful to add a require statement to ensure that the input amount is greater than zero.
d52_1	2	leave	Unexpected function invocation arguments, sequences or frequncies	In the `leave` function, the `_shares` parameter could be zero, which may not be intended. It might be useful to add a require statement to ensure that the input shares are greater than zero.
d42_3	1	vest	Unexpected function invocation arguments, sequences or frequencies	There is no access control for the `vest` function, which allows anyone to call the function and change the vesting details for a given recipient. This can be exploited by malicious actors to manipulate the vesting details of other users.
d42_3	2	lock	Unexpected environment or contract conditions	The function `lock` uses the condition `if (end >= block.timestamp + 90 days)` to check if the locking period is longer than 90 days. However, this may result in an unexpected behavior if the `end` value is very close to the maximum possible value for `uint256` (overflow risk). This could result in a condition where the lock is not properly applied.
d42_3	3	forceClaim	Business-flow atomicity violations	The `forceClaim` function transfers half of the `_amount` to the `msg.sender` and the other half to the `vMochi` address. However, there is no check to ensure that the contract has enough balance to perform these transfers. This could lead to partial execution and incorrect state updates in case of insufficient balance.
d47_3	1	setCore	Business-flow atomicity violations	The function setCore allows the change of the core contract address. The comment in the code states that this function should be run atomically with setCore() on ibBTC if that eventuality ever arises. However, there is no guarantee that they will run atomically, which could lead to inconsistencies.
d47_3	2	updatePricePerShare	Unexpected function invocation arguments, sequences or frequencies	The updatePricePerShare function is permissionless and can be called by anyone. It updates the pricePerShare from the core contract and sets the lastPricePerShareUpdate timestamp to now. It can be called at any frequency by any external actor, which could result in outdated prices if not updated as needed, or spamming if called too frequently. Moreover, there is no upper limit on the time between updates.
d47_3	3	updatePricePerShare	Unexpected environment or contract conditions	The updatePricePerShare function relies on the core contract to provide the current price per share. If the core contract is compromised or provides outdated data, the WrappedIbbtcEth contract will also have incorrect price data. It's important to ensure the core contract returns up-to-date and accurate data.
d47_3	4	mint, burn	Unexpected environment or contract conditions	The mint and burn functions assume that the transfer of ibBTC tokens will always be successful. In case of any unexpected conditions like token allowance issues or slippage, the functions may not work as expected. Using SafeERC20 library functions like safeTransferFrom and safeTransfer could help mitigate potential issues.
d47_3	1	mint, burn	Unexpected function invocation arguments, sequences or frequencies	The mint and burn functions assume that the transfer of ibBTC tokens will always be successful. In case of any unexpected conditions like token allowance issues or slippage, the functions may not work as expected. Using SafeERC20 library functions like safeTransferFrom and safeTransfer could help mitigate potential issues.
d47_3	2	pricePerShare	Unexpected environment or contract conditions	The pricePerShare function relies on the oracle contract to provide the current price per share. If the oracle contract is compromised or provides outdated data, the WrappedIbbtc contract will also have incorrect price data. It's important to ensure the oracle contract returns up-to-date and accurate data.
d47_1	1	transfer, transferFrom	Unexpected function invocation arguments	The `transfer` and `transferFrom` functions in the WrappedIbbtc contract use the `amount` argument, which represents the token amount in wibBTC, to calculate the corresponding ibBTC shares (`amountInShares`). However, the functions should also check whether the input `amount` is non-zero to prevent zero-value transfers. A zero-value transfer could lead to unexpected behavior for other contracts interacting with this contract.
d47_1	2	mint, burn	Unexpected environment or contract conditions	In the `mint` and `burn` functions, there is no check on whether the ICoreOracle is returning the correct and up-to-date price per share for wibBTC. This could lead to users minting or burning wrong amounts of wibBTC if the oracle is returning outdated data or if the oracle gets manipulated by an attacker. One possible mitigation is to include sanity checks on the price per share data returned by the oracle, such as checking if the price is within a reasonable range or has not changed significantly in a short period.
d47_1	1	transfer, transferFrom	Unexpected function invocation arguments	The `transfer` and `transferFrom` functions in the WrappedIbbtcEth contract use the `amount` argument, which represents the token amount in wibBTC, to calculate the corresponding ibBTC shares (`amountInShares`). However, the functions should also check whether the input `amount` is non-zero to prevent zero-value transfers. A zero-value transfer could lead to unexpected behavior for other contracts interacting with this contract.
d47_1	2	updatePricePerShare	Unexpected environment or contract conditions	The `updatePricePerShare` function updates the cached `pricePerShare` and `lastPricePerShareUpdate` values. However, there is no limitation on how frequently this function can be called, which could lead to unnecessary gas consumption if called too often. To mitigate this issue, a minimum time interval between updates can be enforced. Additionally, there are no sanity checks on the price per share data returned by the `core` contract. It's recommended to include sanity checks, such as checking if the price is within a reasonable range or has not changed significantly in a short period.
d42_1	1	lock	Unexpected function invocation arguments	The 'lock' function doesn't validate if the input '_amount' is less than or equal to the vested amount for the user. A user can potentially call this function with any amount and cause unexpected behavior in the contract.
d42_1	2	claim	Business-flow atomicity violation	The 'claim' function first transfers the claimable Mochi to the user and then subtracts the claimable amount from 'mochiUnderManagement'. If there is an issue during the transfer, the 'mochiUnderManagement' value will not be updated. To avoid this, the 'mochiUnderManagement' should be updated before the transfer occurs.
d42_1	3	forceClaim	Business-flow atomicity violation	The 'forceClaim' function transfers half of the '_amount' to the user and the other half to the 'vMochi' address, then it updates the 'vesting[msg.sender].vested' and 'mochiUnderManagement' values. Similar to the 'claim' function, if there is an issue during one of the transfers, the contract state will not be updated correctly. To avoid this, update the contract state before performing the transfers.
d39_1	null
d28_1	1	commitEth	Reentrancy	The function 'commitEth' is marked as nonReentrant, but it has a potential reentrancy issue. The function transfers ether back to the beneficiary before updating the commitmentsTotal. An attacker could potentially exploit this by calling the function again before the commitmentsTotal is updated, allowing them to commit more than they should be able to.
d28_1	2	withdrawTokens	Reentrancy	The function 'withdrawTokens' is marked as nonReentrant, but it has a potential reentrancy issue. The function transfers tokens to the beneficiary before updating the claimed mapping. An attacker could potentially exploit this by calling the function again before the claimed mapping is updated, allowing them to withdraw more tokens than they should be able to.
d28_1	3	finalize	Business-flow atomicity violations	The 'finalize' function can be called by anyone with admin role, the wallet, or a smart contract role, or if the finalize time has expired. This allows multiple parties to potentially finalize the auction, which might not be desired. A more strict access control mechanism should be implemented to ensure that only the intended party is able to finalize the auction.
d28_1	null
d24_3	1	setYieldSource	Unexpected environment or contract conditions	The setYieldSource function can be called by the owner or asset manager, but it does not check whether the yield source being set is valid. This can result in a broken contract if the yield source is outdated or incorrect.
d24_3	1	transferFunds	Business-flow atomicity violations	The transferFunds function can be called by the owner or asset manager to transfer funds from one yield source to another. However, this function does not guarantee atomicity between redeeming tokens from the old yield source and supplying tokens to the new yield source. If the transaction fails between these two operations, funds may be lost or locked in the contract. It would be better to ensure atomicity by using a single transaction for both redeeming and supplying tokens.
d24_2	1	supplyTokenTo, redeemToken	Business-flow atomicity violations	The functions `supplyTokenTo` and `redeemToken` are not atomic, as they consist of multiple actions like transferring tokens and minting/burning shares. Since they use `nonReentrant` modifier, reentrancy attacks are mitigated. However, in case of external contract calls or network congestion, business-flow atomicity violation might occur.
d24_1	null
d16_3	null
d19_3	null
d23_3	1	nTokenTransfer	Unexpected function invocation arguments	In the nTokenTransfer function, there is no input validation to check whether the 'amount' parameter is a positive value. This can lead to unexpected behavior when transferring tokens. It is recommended to add a require statement to ensure the 'amount' is positive.
d23_3	2	nTokenTransfer, nTokenTransferFrom	Business-flow atomicity violations	The nTokenTransfer and nTokenTransferFrom functions claim incentives for both the sender and the recipient during token transfers. However, these functions do not implement atomic operations, which means that if one part of the transaction fails, the entire transaction will not revert. It is recommended to use a pattern like the 'Checks-Effects-Interactions' pattern to ensure proper atomicity.
d23_3	3	nTokenTransferFrom	Unexpected function invocation arguments	In the nTokenTransferFrom function, there is no input validation to check whether the 'amount' parameter is a positive value. Similar to the nTokenTransfer function, this can lead to unexpected behavior when transferring tokens. It is recommended to add a require statement to ensure the 'amount' is positive.
d23_1	1	nTokenTransferApproveAll	Unexpected function invocation arguments, sequences or frequencies	The nTokenTransferApproveAll function allows the caller to approve all nToken transfers to a specific spender. This might be a potential vulnerability as it simplifies the UX for users to approve token transfers to an external exchange or protocol in a single transaction. An attacker might be able to exploit this function by tricking users into approving unlimited transfers to their address, giving them the ability to drain funds.
d23_1	2	_transfer	Unexpected environment or contract conditions	The _transfer function internally claims incentives while transferring tokens. If there are any issues with the incentives calculation or distribution, it might lead to unexpected results during token transfers. For example, if there's a bug in the incentives calculation or an external oracle providing outdated data, the function may distribute incorrect incentives, resulting in imbalances or incorrect token distribution.
d19_1	1	fulfill	Business-flow atomicity violation	The `fulfill` function is supposed to execute the call data, transfer the receiving asset to the recipient, and then handle the relayer fee. However, the current implementation has multiple separate transfer calls, which can lead to partial execution. For example, if the relayer fee is transferred successfully, but the transfer of the receiving asset fails, the transaction will still be marked as fulfilled, causing potential loss of funds.
d19_1	2	fulfill	Unexpected function invocation arguments	The `fulfill` function uses the `IFulfillHelper(txData.callTo).execute()` function to execute the call data. However, there is no validation on the `txData.callTo` address. This may lead to unintended execution of functions if a malicious user passes an unexpected address as `txData.callTo`.
d19_1	3	prepare	Unexpected environment or contract conditions	In the `prepare` function, there is a check for the expiry timestamp: `require((expiry - block.timestamp) >= MIN_TIMEOUT, "prepare: TIMEOUT_TOO_LOW");`. However, there is no check to ensure that the provided `expiry` is in the future. A malicious user may provide an `expiry` that is less than the current block timestamp, causing the transaction to expire immediately.
d16_1	null
d12_1	1	pour	Business-flow atomicity violations	The 'pour' function modifies the vault's collateral and debt amounts without considering the possibility of a revert due to an undercollateralized vault. If a revert occurs, the collateral and debt values will not be in sync, and this may lead to an incorrect state.
d12_1	1	build	Unexpected function invocation arguments	The 'build' function accepts any address as the owner of a vault without validating whether the address is a valid contract or externally owned account. This may lead to unexpected behavior if the vault is owned by an invalid address.
d12_1	1	_mature	Unexpected environment or contract conditions	The '_mature' function relies on the rateOracle to return an accurate rateAtMaturity value. However, the rateOracle is an external contract, which may return outdated or incorrect data. This could lead to incorrect interest rate calculations and affect the overall functioning of the smart contract.
d12_1	null
d8_3	null
d10_3	null
d10_1	1	transferERC20	Unexpected function invocation arguments	The 'transferERC20' function is vulnerable to unexpected function invocation arguments, as it does not validate if the 'to' address is a non-zero address. This could lead to accidental loss of tokens if the 'to' address is set to the zero address (0x0).
d10_1	2	transferETH	Unexpected function invocation arguments	The 'transferETH' function is also vulnerable to unexpected function invocation arguments, as it does not validate if the 'to' address is a non-zero address. This could lead to accidental loss of Ether if the 'to' address is set to the zero address (0x0).
d10_1	3	lock, unlock, transferERC20	Business-flow atomicity violations	The 'lock', 'unlock', and 'transferERC20' functions are vulnerable to business-flow atomicity violations due to the lack of reentrancy protection. A reentrant call to these functions could lead to unexpected behavior, such as incorrect balances or locks being modified.
d10_1	4	timeLockERC721, timeUnlockERC721	Unexpected environment or contract conditions	The 'timeLockERC721' and 'timeUnlockERC721' functions do not check if the NFT contract address is a valid ERC721 contract. This could lead to unexpected behavior if the provided NFT contract address does not implement the required ERC721 interface or if it is a malicious contract.
d8_1	null
d5_1	1	grantFunds	Unexpected environment or contract conditions	In the grantFunds function, the check for the maximum grant amount is based on the current balance of USDV tokens in the VAULT. If there is a sudden change in the USDV balance, either due to transfers or due to price fluctuations, the amount granted could be unexpectedly high or low. A more robust mechanism should be implemented to calculate the maximum grant amount.
d5_1	2	cancelProposal	Unexpected function invocation arguments	The cancelProposal function allows a minority to cancel a proposal that is currently in the finalizing stage. However, there is no validation to check whether the newProposalID provided is actually a valid and existing proposal. This may lead to unexpected behavior where an invalid newProposalID is provided, which doesn't serve the intended purpose of the cancelProposal function. A check should be added to verify if the newProposalID is valid.
d5_1	3	finaliseProposal	Business-flow atomicity violations	In the finaliseProposal function, if the proposal no longer has a quorum at the time of the finalization, it is allowed to be finalized again by calling _finalise(proposalID). This behavior could lead to a proposal being stuck in the finalizing state indefinitely and never actually being completed. To fix this issue, the finaliseProposal function should handle cases where a proposal loses quorum, either by canceling the proposal or by implementing a mechanism to handle such scenarios gracefully.
d5_1	4	init	Unexpected function invocation sequences or frequencies	The init function can only be called once, as it sets the inited variable to true after the first call. However, if there is a need to update the VADER, USDV, or VAULT addresses in the future, there is no way to do so in the current implementation. A function should be provided to update the contract addresses after proper validation (e.g., through a proposal and voting mechanism) to ensure the contract is flexible and can adapt to future changes.
d5_1	1	init	Business-flow atomicity violation	The `init` function sets multiple variables, but it is not atomic. If any operation fails after some variables are already set, the contract's state will be left inconsistent. It is recommended to use an atomic operation, like OpenZeppelin's `initializer` modifier, to ensure consistent state initialization.
d5_1	2	harvest	Unexpected function invocation arguments	The `harvest` function doesn't validate whether the input `synth` address is actually a valid synth contract. The function may behave unexpectedly if the input `synth` is not a valid synth contract. It is recommended to check if the input synth address is in the list of registered synths.
d5_1	3	_deposit	Unexpected environment or contract conditions	In the `_deposit` function, the calculation of `_weight` is dependent on the price fetched from external contracts like `iUTILS` or `iROUTER`. If these external contracts return unexpected values, the calculated `_weight` may be incorrect. It is recommended to handle such scenarios, for example, by checking the returned values from these contracts for validity.
d5_1	4	setParams	Unexpected function invocation arguments	The `setParams` function doesn't validate the input parameters (newEra, newDepositTime, newGrantTime) for their validity, allowing for potentially unintended values. It is recommended to validate the input parameters to ensure they are within acceptable ranges.
d5_1	5	calcCurrentReward	Unexpected environment or contract conditions	The `calcCurrentReward` function calculates the reward based on the reserve of `USDV` or `VADER`. However, if there is any slippage or the reserve becomes outdated, the calculated reward may be incorrect. It is recommended to handle such scenarios, for example, by checking the reserve value's validity and updating it accordingly.
d3_1	1	crossOvercollateralizedBorrow	Business-flow atomicity violation	In the crossOvercollateralizedBorrow function, the deposit, borrow, and withdraw operations are not atomic. If there is an issue during the execution of the function (such as a reentrancy attack, a revert in one of the called functions, or an unexpected condition), it could lead to an inconsistent state of the trader's account.
192_3	1	claim	Reentrancy	The `claim` function calls `bondNFT.claim` and then transfers tokens to the user, which makes it susceptible to reentrancy attacks. An attacker could use a malicious contract to call the `claim` function recursively, draining the contract's funds. The use of reentrancy guards, like OpenZeppelin's ReentrancyGuard, is recommended to prevent such attacks.
192_3	2	claimDebt	Reentrancy	The `claimDebt` function also suffers from the same reentrancy issue as the `claim` function. After calling `bondNFT.claimDebt`, tokens are transferred to the user, which opens up the possibility for reentrancy attacks. Adding a reentrancy guard is highly recommended.
192_3	3	release	Reentrancy	The `release` function calls `bondNFT.release` and then transfers tokens to the user, which makes it susceptible to reentrancy attacks. An attacker could use a malicious contract to call the `release` function recursively, draining the contract's funds. The use of reentrancy guards, like OpenZeppelin's ReentrancyGuard, is recommended to prevent such attacks.
192_3	4	extendLock	Reentrancy	The `extendLock` function calls `claim` function, which is vulnerable to reentrancy attacks, and then transfers tokens from the user, which might make it susceptible to reentrancy attacks. Implementing a reentrancy guard is highly recommended to avoid such issues.
192_1	1	release	Incorrect state updates	The 'release' function updates the totalLocked state by decreasing the lockAmount, but it doesn't check if the bond is actually released before updating the state. This could lead to incorrect state updates if the bond isn't released successfully.
192_1	2	lock, extendLock, release	Missing event emissions	The 'lock', 'extendLock', and 'release' functions should emit events to record the state changes and provide an easy way to track these changes. However, there are no events emitted in these functions. To fix this, you should define events and emit them accordingly in these functions.
192_1	3	claim, claimDebt, lock, extendLock, release	Reentrancy vulnerability	The contract uses external calls to untrusted contracts (IERC20) in the 'claim', 'claimDebt', 'lock', 'extendLock', and 'release' functions. These external calls are not protected by reentrancy guards, and this can lead to reentrancy attacks. To fix this, you should use the Checks-Effects-Interactions pattern and consider adding a reentrancy guard, such as OpenZeppelin's ReentrancyGuard.
112_1	1	unstakeFor	Reentrancy	The function `unstakeFor` is vulnerable to a reentrancy attack because it updates the user's balance after transferring the tokens. An attacker can call the function, receive the tokens, and then call the function again before the balance is updated, potentially allowing them to drain the contract.
83_1	1	deposit	Incorrect handling of deposit fees	When depositing tokens with a deposit fee, the `_amount` is reduced by the fee, but the original `_amount` is still deposited into the MasterChef contract.
83_1	2	add	Inaccurate error message	The error message "already registered" in the `add()` function can be misleading because it checks if `pid[_token]` is 0. Since pid starts from 0, it may cause confusion when debugging or understanding the contract.
78_1	1	withdrawGovernanceAsset	Reentrancy Attack	The `withdrawGovernanceAsset` function is vulnerable to a reentrancy attack. The function first transfers the asset to the user and then deletes the pending flash decision. If a malicious user can perform a reentrant call within the same transaction, they can potentially withdraw their asset multiple times.
78_1	2	enforceTolerance	Incorrect Error Message	The error messages in the `enforceTolerance` function are not informative, as they only show "FE1". It would be more helpful to have a descriptive message to indicate the exact reason for the error. I recommend updating the error messages to provide more context.
70_1	1	_updateVaderPrice	Integer Overflow and Underflow 	In the `_updateVaderPrice` function, when calculating `currentLiquidityEvaluation`, an unchecked block is used which can potentially lead to integer underflow or overflow. Since the Solidity version used is 0.8.9, arithmetic operations are checked for underflow and overflow by default. However, the unchecked block is explicitly disabling this protection, which could lead to incorrect calculations and state updates.
68_1	1	joinTokenSingle	Reentrancy Attack	In the `joinTokenSingle` function, the `safeTransfer` function is called before `_joinTokenSingle`. This may lead to potential reentrancy attacks if the called contract has a malicious implementation of `safeTransfer`. This could result in the called contract making a recursive call to `joinTokenSingle` and updating the state incorrectly.
68_1	2	_joinTokenSingle	Front-Running Attack	In the `_joinTokenSingle` function, the contract calls the `swapExactTokensForTokens` function without specifying a minimum amount of output tokens. This leaves the contract open to front-running attacks, where attackers can manipulate the token price on the DEX by placing their transactions just before the contract's transaction.
68_1	3	_joinTokenSingle	Price Manipulation	In the `_joinTokenSingle` function, the contract calls the `swapExactTokensForTokens` function with `block.timestamp` as the deadline. Since `block.timestamp` can be manipulated by miners to some extent, it could be used for price manipulation. To mitigate this risk, it is recommended to use a reasonable user-specified deadline instead of `block.timestamp`.
58_3	1	_push	Incorrect token amount update	The `_push` function does not update the actual amount of tokens deposited into the Aave protocol. If the deposit operation in Aave does not accept the entire token amount requested, the function will still return the requested tokenAmounts instead of the actual deposited amounts.
58_3	2	_pull	Incorrect token amount update	The `_pull` function does not update the actual amount of tokens withdrawn from the Aave protocol. If the withdraw operation in Aave does not return the entire token amount requested, the function will still return the requested tokenAmounts instead of the actual withdrawn amounts.
58_3	3	_push	Unnecessary updateTvls() call	The `updateTvls()` function is called in the `_push` function after depositing tokens to Aave, but it is not necessary because the `_tvls` are already updated with the tokenAmounts in the same function. This causes an additional gas cost for users when depositing tokens.
58_3	4	_pull	Unnecessary updateTvls() call	The `updateTvls()` function is called in the `_pull` function after withdrawing tokens from Aave, but it is not necessary because the `_tvls` are already updated with the tokenAmounts in the same function. This causes an additional gas cost for users when withdrawing tokens.
65_3	1	validateWeights	Unbounded for loop	In the function `validateWeights`, there is an unbounded for loop that could potentially consume a lot of gas if the `_tokens` array is large. This could lead to exceeding the block gas limit or the transaction running out of gas.
65_3	2	handleFees	Incorrect handling of decimals	The function `handleFees` calculates the fee based on `timeDiff * licenseFee / ONE_YEAR`. However, this calculation may not be accurate due to integer division. It would be better to use SafeMath to perform this calculation.
65_3	3	handleFees, changePublisher, changeLicenseFee, setNewMaxSupply, publishNewIndex	Timestamp manipulation risk	The functions `handleFees`, `changePublisher`, `changeLicenseFee`, `setNewMaxSupply`, and `publishNewIndex` rely on the `block.timestamp` for time-based calculations. This is risky because miners can manipulate the block timestamp within a certain range. It's recommended to use a more secure alternative, like OpenZeppelin's TimelockController.
65_3	4	handleFees	No reentrancy protection	The `handleFees` function is called in multiple places, including the `mintTo`, `burn`, and `auctionBurn` functions, which are protected by the `nonReentrant` modifier. However, the `handleFees` function itself does not have the `nonReentrant` modifier, which could lead to reentrancy issues if the function is called directly or indirectly by a malicious contract. It's recommended to add the `nonReentrant` modifier to the `handleFees` function.
65_3	5	pushUnderlying, pullUnderlying	Floating-point rounding error	In the functions `pushUnderlying` and `pullUnderlying`, the calculation of `tokenAmount` is subject to floating-point rounding errors due to the division operation (`ibRatio / BASE / BASE`). To avoid this, consider using the SafeMath library for more precise calculations or use a fixed-point arithmetic library like ABDKMath64x64.
65_1	1	handleFees	Integer Overflow	In the `handleFees` function, the calculation for `feePct` can potentially lead to an integer overflow when multiplying `timeDiff` by `licenseFee`. It is recommended to use SafeMath library to avoid integer overflows.
65_1	2	mintTo	Missing Input Validation	The `mintTo` function is missing input validation to check if the provided `to` address is not equal to the zero address. It is important to validate the input to prevent accidental token minting to the zero address.
65_1	3	changeLicenseFee	Missing Input Validation	In the `changeLicenseFee` function, the condition `require(newLicenseFee >= factory.minLicenseFee() && newLicenseFee != licenseFee);` might not be enough to prevent extreme values. It is recommended to add an upper bound check for `newLicenseFee` to prevent setting an unreasonably high value.
65_1	4	handleFees, changePublisher, changeLicenseFee, setNewMaxSupply, publishNewIndex	Use of block.timestamp	The use of `block.timestamp` can be manipulated by miners to some extent. Although the impact in this contract is not significant, it is still recommended to be aware of potential miner manipulation when using `block.timestamp`.
58_1	1	_push	Incorrect state update	The _push function does not update the actualTokenAmounts array after the deposit function is executed. It should update the actualTokenAmounts array with the actual deposited amount to accurately reflect the changes in the state.
58_1	2	_pull	Incorrect state update	The _pull function does not update the actualTokenAmounts array after the withdraw function is executed. It should update the actualTokenAmounts array with the actual withdrawn amount to accurately reflect the changes in the state.
58_1	3	updateTvls	Missing state update	The updateTvls function updates the _tvls array with the current aToken balances, but it does not update the state of the Vault contract with the updated _tvls array. The Vault state should be updated with the new _tvls array to reflect the changes in the total value locked.
54_1	1	approve	Front-Running Attack	The approve function is vulnerable to a front-running attack. A malicious user can watch the transaction pool and quickly send a transaction with a higher gas price to "steal" the approval before the original transaction gets mined. Since the approve function does not have any protection against this, a front-running attacker can exploit this vulnerability.
54_1	1	transferFrom	Incorrect state update	In the `transferFrom` function, the state update for the `_tokenId` of the `fromKey` should be done before updating the expirationTimestamp. Otherwise, if an error occurs, it may lead to an incorrect state update.
54_1	2	shareKey	Incorrect state update	In the `shareKey` function, there is a possibility of overwriting the existing key of `_to` address without considering the existing key's expiration time. This may result in an incorrect state update for the key's expirationTimestamp.
42_1	1	updateReserve	Incorrect reserve update	The updateReserve function calculates the new reserve as the difference between the contract's balance and the sum of mochiShare and treasuryShare. However, this calculation does not take into account any potential change in the contract's balance after the update. An attacker could manipulate the balance to cause an incorrect state update.
42_1	2	changeTreasuryRatio and changevMochiRatio	Insufficient validation	The functions changeTreasuryRatio and changevMochiRatio do not validate the input value of the ratio. This could lead to unintended consequences, such as setting the ratio to more than 100%, resulting in an incorrect state update. It is recommended to add a check to ensure that the input ratio is within the acceptable range (0 to 100%).
42_1	3	distributeMochi	Reentrancy attack	The distributeMochi function calls the _buyMochi and _shareMochi internal functions. The _buyMochi function interacts with an external contract (Uniswap) to swap tokens, while the _shareMochi function transfers tokens to multiple addresses. These external calls can potentially be exploited to perform a reentrancy attack. To mitigate this risk, it is recommended to implement checks-effects-interactions pattern and use a reentrancy guard.
42_1	4	_shareMochi	Incorrect calculations in _shareMochi	The _shareMochi function calculates the amount of Mochi to be sent to the vMochi Vault and veCRV Holders, but it does not update the mochiShare and treasuryShare correctly. The current implementation sets mochiShare and treasuryShare to zero after the Mochi transfers. However, this can lead to incorrect state updates if there's any remaining balance after the transfers. Instead, mochiShare and treasuryShare should be updated according to the actual amounts transferred.
42_1	1	addReward	Incorrect reward update	The addReward function calculates the new reward as the difference between the contract's balance and the total rewards. However, this calculation does not take into account any potential change in the contract's balance after the update. An attacker could manipulate the balance to cause an incorrect state update. It is recommended to use a proper method to calculate new rewards and update the state.
42_1	2	claimRewardAsMochi	Reentrancy attack	The claimRewardAsMochi function interacts with an external contract (Uniswap) to swap tokens and then transfers the Mochi tokens to the message sender. These external calls can potentially be exploited to perform a reentrancy attack. To mitigate this risk, it is recommended to implement checks-effects-interactions pattern and use a reentrancy guard.
42_1	3	claimRewardAsMochi	Insufficient input validation	The claimRewardAsMochi function does not validate the input value of reward[msg.sender] before approving the Uniswap router to transfer USDM. This could lead to unintended consequences, such as transferring an incorrect amount of tokens. It is recommended to add a check to ensure that the reward amount is greater than 0.
42_1	4	claimRewardAsMochi	Unclaimed rewards	The claimRewardAsMochi function does not update the reward mapping and the rewards variable after a successful claim. This can lead to users being able to claim their rewards multiple times. It is recommended to update the reward mapping and the rewards variable after a successful claim to avoid double-claiming.
36_1	1	handleFees()	Reentrancy Attack	The `handleFees()` function is called in the `mint()` and `burn()` functions, as well as in the `auctionBurn()` function, which is called externally by the auction contract. The `handleFees()` function updates the `lastFee` state variable, and then mints tokens to the publisher and the owner. The issue arises because the call to `_mint()` can potentially trigger a reentrancy attack if the publisher or the owner is a malicious contract. To mitigate this issue, you should either use the checks-effects-interactions pattern or apply a reentrancy guard to the `handleFees()` function.
19_3	1	fulfill	Reentrancy	In the `fulfill` function, external calls to untrusted contracts (`IFulfillHelper(txData.callTo).addFunds` and `IFulfillHelper(txData.callTo).execute`) are made before the state is updated. Although the contract uses the `nonReentrant` modifier, a potential reentrancy attack may occur if the called contracts are malicious.
19_3	2	prepare	Front Running	In the `prepare` function, there's no protection against front running attacks. A malicious miner could reorder or manipulate transactions to their advantage. For example, a miner could see a user preparing a transaction and insert their own transaction before the user's, potentially exploiting the user.
10_3	1	transferERC20	Reentrancy	The 'transferERC20' function is vulnerable to reentrancy attacks. It allows an attacker to call back into the contract before the state has been updated. This can lead to unintended behavior and potential loss of funds. The issue arises because the 'TransferHelper.safeTransfer()' function is called before updating the balance of the token.
10_3	2	rageQuit	Unchecked return value	The 'rageQuit()' function does not check the return value of the 'IRageQuit(delegate).rageQuit()' function call. If the called function fails silently or returns an incorrect value, the state of the contract might be inconsistent, leading to unexpected behavior.
10_3	3	timeLockERC20	Front-running	The 'timeLockERC20()' function is vulnerable to front-running attacks. An attacker can monitor the transaction pool and submit a transaction with a higher gas price to have their transaction included before the victim's transaction. The issue arises due to the use of 'msg.sender' and the 'expires' parameter, which can be manipulated by an attacker.
3_3	1	borrow	Missing access control	The `borrow` function is an internal function, which means it can be called by any function within the same contract, or inherited contracts. Although the goal stated at the beginning is to make all external functions only accessible to margintrader role, there is no access control check for the `borrow` function. This could lead to incorrect state updates if any external function (in this or inherited contract) that calls this function does not have proper access control.
3_3	2	extinguishDebt	Missing access control	Similar to the `borrow` function, the `extinguishDebt` function is an internal function without any access control check. This could also lead to incorrect state updates if any external function (in this or inherited contract) that calls this function does not have proper access control.
3_3	1	registerWithdrawal	Reentrancy Attack	In the `registerWithdrawal` function, the state is not properly updated before the tokens are transferred, making it vulnerable to reentrancy attacks. An attacker could call the function repeatedly in the same transaction and withdraw more tokens than they should. To fix this issue, make sure to update the state before transferring the tokens.
3_3	2	_registerBorrow	Insufficient validation	The `_registerBorrow` function should validate that the borrowAmount is greater than zero. This would prevent unnecessary state updates and protect against potential issues. Add a require statement to check if the borrowAmount is greater than zero before proceeding with the rest of the function.
3_3	3	_registerWithdrawal	Insufficient validation	The `_registerWithdrawal` function should validate that the withdrawAmount is greater than zero. This would prevent unnecessary state updates and protect against potential issues. Add a require statement to check if the withdrawAmount is greater than zero before proceeding with the rest of the function.
3_3	4	registerTradeAndBorrow	Incorrect state update	In the `registerTradeAndBorrow` function, when there is no debt to extinguish, the totalLong state for the tokenTo is updated incorrectly. It should be updated as `totalLong[tokenTo] += outAmount;` instead of `totalLong[tokenTo] += outAmount - extinguishableDebt;`.
35_1	null
25_1	1	_updateUserRewards	Integer Overflow	The claim function allows any user to claim rewards on behalf of any other user. There should be an access control check to ensure that only the rightful owner of the rewards can claim them.
24_1	1	redeemToken	Reentrancy	The `redeemToken` function is marked as nonReentrant (using ReentrancyGuardUpgradeable), but it is still vulnerable to reentrancy attacks due to the use of `safeTransferFrom` after updating the contract's state. The `safeTransferFrom` function can potentially call a malicious contract that re-enters `redeemToken`, causing unexpected behavior.
19_1	1	fulfill	Reentrancy	The `fulfill` function is vulnerable to reentrancy attacks since it makes external calls (transferring assets) before updating the state (variantTransactionData). An attacker could exploit this vulnerability by calling the fulfill function again during the external call, leading to incorrect state updates.
19_1	2	prepare	Front-running	The `prepare` function is vulnerable to front-running attacks, as it doesn't check for the validity of the transaction sender before updating the state. An attacker could monitor pending transactions and attempt to front-run the prepare function by submitting a transaction with a higher gas price to claim the position before the original transaction gets mined.
10_1	null
3_1	1	deleteAccount	Missing access control	The `deleteAccount` function can potentially be misused to reset an account's borrow and holding balances to zero. There is no access control mechanism like `modifier` or `require` statement ensuring that only authorized roles (e.g. margin trader) can call this function. Although the function is marked as `internal`, it can still be called by any function within the same contract or a derived contract. To fix this issue, you can add an access control check that only allows certain roles to call the function.
3_1	2	getLastDepositBlock	Unnecessary external exposure	The `getLastDepositBlock` function is marked as `external`, which means it can be called from outside the contract. However, this function merely returns the value of `lastDepositBlock` for a given trader, and there is no need for an external caller to access this value. It can be marked as `internal` or `private` to prevent unnecessary exposure of this function.
3_1	1	_registerBorrow	Global exposure cap check	The function _registerBorrow does not properly update the states for totalShort and totalLong, leading to incorrect state updates in the smart contract. The totalLong should not be updated in this function, as it represents the total deposits of the token in the platform. Updating totalLong here could lead to a situation where the global exposure cap is exceeded without being detected.
3_1	2	registerTradeAndBorrow	Incorrect state update in registerTradeAndBorrow	The registerTradeAndBorrow function does not correctly update the account's holdings and borrowed states, leading to potential inconsistencies in the smart contract's states.
d143_3	1	recordPaymentFrom	Business-flow atomicity violation	The function `recordPaymentFrom` is responsible for recording payments made to a project. However, it doesn't handle the case where multiple payments are made simultaneously or in quick succession, which may lead to incorrect balance calculations or race conditions. To resolve this, the function should ensure that the balance calculations are atomic.
d143_3	2	recordDistributionFor, recordUsedAllowanceOf	Unexpected environment or contract conditions	The functions `recordDistributionFor` and `recordUsedAllowanceOf` make use of the external price oracle `prices` to convert currencies. The contract assumes that the price oracle returns accurate and up-to-date data. However, the oracle may return outdated data, which may lead to incorrect calculations for distribution and allowance usage. To resolve this, the contract should implement a mechanism to verify the accuracy of the price data or use a reliable price oracle.
d143_3	3	recordRedemptionFor	Unexpected function invocation arguments, sequences, or frequencies	The function `recordRedemptionFor` handles the redemption of tokens by users. It calculates the `reclaimAmount` based on the current overflow and the number of tokens being redeemed. However, it doesn't validate the arguments that are passed to the function or the frequency of the redemption requests. This may lead to incorrect calculations or token redemption by malicious actors. To resolve this, the function should validate the input arguments and implement rate limiting or a cooldown mechanism for the redemption process.
d143_3	1	priceFor	Unexpected environment or contract conditions	The `priceFor` function relies on external price feeds through the `IJBPriceFeed` interface to fetch the price data. Since the data is coming from external sources, there is a risk of outdated or inaccurate data being returned. To mitigate this risk, the contract should include a mechanism to ensure data freshness, such as checking the timestamp of the latest price update or including a maximum acceptable age for the data.
d143_3	1	currentPrice	Unexpected environment or contract conditions	The `currentPrice` function retrieves the latest price data from the Chainlink AggregatorV3Interface. Since the data is coming from an external source, there is a risk of outdated or inaccurate data being returned. To mitigate this risk, the contract should include a mechanism to ensure data freshness, such as checking the timestamp of the latest price update or including a maximum acceptable age for the data.
d192_3	1	deposit	Unexpected function invocation arguments	In the deposit function, there is a potential vulnerability related to the token's decimals. The function calculates the amount of tigAsset to mint based on the assumption that the `_token` has less than or equal to 18 decimals. If a token with more than 18 decimals is listed and allowed to be deposited, it could result in unexpected calculations and incorrect minting of tigAsset.
d192_3	2	withdraw	Unexpected function invocation arguments	Similar to the deposit function, the withdraw function also assumes that the `_token` has less than or equal to 18 decimals. This could result in incorrect calculations and incorrect token withdrawal amounts.
d192_2	1	deposit	Unexpected function invocation arguments	In the deposit function, the calculation for minting the stable token might lead to unexpected results due to potential rounding errors. The calculation does not take into consideration decimals for the allowed token, which might lead to the user receiving an incorrect amount of stable tokens. To fix this, consider using a more accurate calculation that accounts for the decimals.
d192_2	2	deposit	Unexpected environment or contract conditions	The deposit function does not account for potential slippage or price fluctuations for the tokens. This might lead to incorrect minting of stable tokens as the token price might have changed since the last oracle update. To address this issue, consider using an oracle like Chainlink to fetch the latest token prices before minting the stable tokens.
d143_2	1	currentPrice	Unexpected environment or contract conditions (e.g., ChainLink: returning outdated data or slippage occurring)	The 'currentPrice' function returns the latest price fetched from the Chainlink AggregatorV3Interface. There is a possibility that the latest data might be outdated or impacted by extreme market conditions like slippage, which could affect the accuracy of the price returned. Users relying on this price for critical calculations or decisions might face risks due to such scenarios.
d143_2	2	currentPrice	Unexpected function invocation arguments	The 'currentPrice' function takes the '_decimals' parameter as input, and there is no validation to check whether the input value is within a valid range or not. This could lead to issues if a user accidentally inputs an excessively large or negative value for '_decimals'. A proper validation check should be implemented to ensure that the input value for '_decimals' is within a reasonable range.
d143_2	1	priceFor	Unexpected function invocation arguments	The 'priceFor' function takes the '_decimals' parameter as input, and there is no validation to check whether the input value is within a valid range or not. This could lead to issues if a user accidentally inputs an excessively large or negative value for '_decimals'. A proper validation check should be implemented to ensure that the input value for '_decimals' is within a reasonable range.
d143_2	null
d125_2	1	CurveswapAdapter.swapExactTokensForTokens	Unexpected function invocation arguments	The function `CurveswapAdapter.swapExactTokensForTokens` is called with the argument `200` as the minimum amount of tokens expected in return. However, this number is hardcoded and does not account for potential slippage or varying market conditions, which could result in undesired outcomes during the token swap. It would be more appropriate to calculate the slippage based on the current market conditions and user preferences.
d125_2	2	processYield	Unexpected environment or contract conditions	The function `processYield` relies on the `_getYield` function to determine the yield amount for the LIDO contract. However, this function is not visible in the provided code, and its implementation cannot be verified. If `_getYield` were to return outdated or incorrect data, it could lead to unexpected contract conditions or incorrect calculations for the yield amount.
d125_2	1	depositCollateral	Unexpected function invocation arguments	In the depositCollateral function, there is no validation for the input parameters _asset and _amount. A user might send an incorrect asset address or deposit an incorrect amount, which could result in unexpected behavior. It's recommended to add validations to check for valid asset addresses and non-zero deposit amounts.
d100_2	1	deposit	Unexpected environment or contract conditions	In the `deposit` function, the amount to deposit is calculated using the balance of the contract instead of the amount provided as an argument. This could lead to unintended behavior when the contract has latent funds. To fix this, the code should use `_amount` directly to calculate `_amountToDeposit`:
d100_2	2	initialize	Unexpected function invocation arguments	In the `initialize` function, the `__ERC20_init_unchained` function is called with string literals as arguments, which are not required to be wrapped in `string()`. The correct way to call the function should be:
d97_2	null
d96_3	null
d96_2	1	mint, burn, lend, withdraw, borrow, pay, collectProtocolFee	Business-flow atomicity violation	There is no revert mechanism in place in case the functions fail during execution, causing a possible violation of business-flow atomicity. The functions should be wrapped in a try-catch block, and in case of failure, all state changes should be reverted.
d96_1	null
d94_3	null
d94_3	1	makeOffer	Business-flow atomicity violation	In the `makeOffer` function, the contract first checks if the `_autoAcceptBuyPrice` function returns true. If it does, the function returns 0 without modifying the offer. However, if it returns false, the offer is processed further. This could lead to an atomicity violation if another transaction is processed between the `_autoAcceptBuyPrice` check and the offer processing, potentially causing the offer to be accepted at an incorrect price.
d94_3	2	makeOffer	Unexpected function invocation arguments	In the `makeOffer` function, the function call to `feth.marketLockupFor{ value: msg.value }(msg.sender, amount)` and `feth.marketChangeLockup{ value: msg.value }(...)` both use `msg.value` as the value for the function call. If the caller provides an unexpected value in `msg.value`, it could lead to incorrect locking of funds or potentially disrupt the contract's internal state.
d94_3	1	buy	Business-flow atomicity violation	In the `buy` function, there is no atomicity in the condition check and execution. An attacker could potentially exploit this by causing a race condition. The function checks if `buyPrice.price > maxPrice` or `buyPrice.seller == address(0)`, but there is no guarantee that the state will remain the same until `_buy` is executed. To fix this, consider using the `checks-effects-interactions` pattern.
d94_3	null
d94_2	1	_getCreatorPaymentInfo	Unexpected function invocation arguments, sequences, or frequencies	The function `_getCreatorPaymentInfo` uses multiple external contract calls with `try-catch` blocks to fetch information about royalties. There is a possibility that the external contracts may provide unexpected arguments, sequences, or frequencies. However, the function handles potential errors by using `try-catch` blocks and falling through to the next royalty API check if an error occurs. This mitigates the risk but does not entirely eliminate it.
d94_2	1	buy	Unexpected function invocation arguments	In the 'buy' function, the 'maxPrice' parameter is not checked for overflow, which could lead to unexpected results when a malicious user provides an extremely large value.
d94_2	2	setBuyPrice	Unexpected environment or contract conditions	In the 'setBuyPrice' function, there is a possibility that the price value is greater than the maximum uint96 value. Although there is a check to avoid this situation, it does not prevent the contract from being used with ERC721 tokens that have a very high value, potentially causing unexpected behavior.
d94_2	null
d94_2	null
d90_2	1	mint	Business-flow atomicity violations	The `mint` function has a loop iterating over the assets and invoking vToken.mint() for each asset. If a transaction fails during this loop (e.g., due to an out-of-gas exception), the minting process is interrupted, and the index state becomes inconsistent with the asset balances.
d90_2	3	mint, burn	Unexpected environment or contract conditions	The contract relies on the price oracle to provide up-to-date and correct asset prices. If the price oracle returns outdated data, it could result in an incorrect calculation of the minted index tokens or the burned assets. This issue could occur in the `mint` function when calculating the `minAmountInBase` and the `lastAssetBalanceInBase`. It could also happen in the `burn` function when calculating the `accountBalance` and executing the `vToken.burn(_recipient)` function.
d83_2	1	withdraw	Business-flow atomicity violation	In the `withdraw` function, the `claimed` mapping is updated before the token transfer. If the token transfer fails (e.g., due to a malicious token contract), the user's withdrawal claim will be marked as completed, even though they have not received the tokens. To fix this issue, the token transfer should occur before updating the `claimed` mapping.
d83_2	2	withdraw	Unexpected function invocation arguments	The `withdraw` function allows the caller to specify the recipient address (`_to`) for the withdrawn tokens. This may lead to mistakes or potential abuse if the caller unintentionally or maliciously enters an incorrect address. It's recommended to use `msg.sender` as the recipient address directly or add checks to ensure that the specified recipient address is valid and expected by the caller.
d83_2	3	activate	Unexpected environment or contract conditions	The `activate` function sets the `activated` timestamp for a given token based on the current block timestamp. In rare cases, the block timestamp can be manipulated by miners within a certain range. This could potentially impact the activation and deactivation periods. To mitigate this risk, consider using a more reliable source of time, such as a decentralized oracle, or increase the GRACE_PERIOD to reduce the potential impact of minor timestamp manipulations.
d83_2	4	deactivate	Unexpected environment or contract conditions	The `deactivate` function allows the client to deactivate a token after the GRACE_PERIOD has passed. However, there's no check to ensure that the remaining tokens are returned to the client or a specified party. If the contract has a balance of other tokens (e.g., due to donations), these tokens will remain in the contract and be inaccessible. To address this issue, consider adding a function to allow the client to withdraw any remaining tokens upon deactivation or after the GRACE_PERIOD has passed.
d81_2	null
d51_2	1	distributeTokens	Business-flow atomicity violation	The AirdropDistribution contract lacks a distributeTokens function that would allow the owner to distribute tokens to the airdropArray of addresses. As a result, the contract does not provide atomicity in distributing tokens, leaving the possibility that some recipients may not receive their tokens, or the token distribution could be interrupted or manipulated.
d77_3	null
d78_3	1	assertGovernanceApproved	Unexpected function invocation arguments	The 'assertGovernanceApproved' function takes the 'emergency' argument but does not validate whether the emergency decision was made by a trusted or authorized entity. This could lead to misuse of the emergency functionality.
d78_3	2	withdrawGovernanceAsset	Business-flow atomicity violations	In the 'withdrawGovernanceAsset' function, the user can withdraw their collateral asset after the lock period, even if the decision has not yet been approved by the community. This may allow users to perform malicious actions without being punished by the community.
d78_3	3	configureFlashGovernance	Unexpected environment or contract conditions	The 'configureFlashGovernance' function allows setting the deposit asset, amount, unlock time, and burnability of the asset. However, it does not validate whether the asset address is a valid ERC20 token or not, which could lead to unexpected behavior.
d78_3	4	burnFlashGovernanceAsset	Unexpected function invocation sequences	The 'burnFlashGovernanceAsset' function allows burning the collateral asset of a flash governance decision. However, it does not check whether the asset has been withdrawn by the user who made the decision. This could lead to unexpected scenarios where the collateral asset is burned even if it has been withdrawn by the user.
d80_3	null
d80_3	null
d80_2	null
d80_2	null
d78_2	1	assertGovernanceApproved	Unexpected function invocation arguments, sequences or frequencies	The `assertGovernanceApproved` function can be called with the `emergency` parameter set to true, which allows bypassing the epoch restriction. There is a warning in the code about using the emergency flag carefully, but it is not enforced programmatically. An attacker with knowledge of the contract might call this function with the `emergency` flag set to true, resulting in unexpected behavior or disrupting the system.
d77_2	1	swapBaseTokenForQuoteToken	Business-flow atomicity violation	The `swapBaseTokenForQuoteToken` function updates the contract state by transferring tokens before calculating and updating the internal balances. This could lead to incorrect internal balance calculations in the case of a reentrant call. To fix this issue, the token transfer should be executed after updating the internal balances.
d77_2	2	swapQuoteTokenForBaseToken	Business-flow atomicity violation	The `swapQuoteTokenForBaseToken` function updates the contract state by transferring tokens before calculating and updating the internal balances. This could lead to incorrect internal balance calculations in the case of a reentrant call. To fix this issue, the token transfer should be executed after updating the internal balances.
d71_2	1	createMarket	Unexpected environment or contract conditions	There is a potential vulnerability with the use of Chainlink oracles in this smart contract due to the assumption of the latest data. If the market uses Chainlink oracles to provide data for any of the contract's references, it might return outdated data in certain cases. To mitigate this issue, the contract should validate that the data provided by the oracles is recent or within an acceptable time range.
d71_2	1	initialize	Unexpected function invocation arguments	The initialize function does not have proper validation checks for the input parameters. The input arrays '_conditions' and '_references' are used directly without checking their lengths, which could lead to unexpected results or potential out-of-bounds issues.
d71_2	2	deposit, _depositFrom	Business-flow atomicity violations	In the deposit and _depositFrom functions, the event "Deposit" is emitted before the minting of tokens with _mint(). This could lead to an incorrect representation of the state in the case where the mint operation fails or reverts.
d71_2	3	allocateCredit, withdrawCredit	Unexpected environment or contract conditions	Both allocateCredit and withdrawCredit functions are updating the rewards for the user; however, there is no check for possible overflow when calculating the new rewardDebt. This can lead to unexpected behavior and incorrect reward calculations.
d71_2	null
d70_2	1	mintSynth	Business-flow atomicity violations	There is no check for the total supply of synths that can be minted. An attacker might take advantage of this and mint an unlimited amount of synths, which could lead to a potential vulnerability.
d70_2	1	burnSynth	Unexpected function invocation arguments	The function burnSynth checks if the synthAmount is greater than 0 but does not validate if the amount is within an acceptable range. An attacker could potentially call the function with an extremely large synthAmount, causing issues with the contract.
d70_2	1	burnFungible	Unexpected environment or contract conditions	The function burnFungible does not handle the case where the reserves of nativeAsset and foreignAsset become very low. This could lead to slippage, which may result in unexpected losses for users interacting with the contract. Additionally, the function does not check if the liquidity provided is greater than 0, which could lead to unexpected behavior.
d70_2	2	setTokenSupport	Unexpected environment or contract conditions	The function setTokenSupport allows the contract owner to change the support status of a token. However, it does not validate if the reserves of the token are empty when trying to unsupport a token. An attacker could potentially unsupport a token with non-empty reserves, leading to unexpected consequences.
d58_3	null
d64_2	null
d61_2	1	getChainlinkLatestPrice	Unexpected environment or contract conditions	The function `getChainlinkLatestPrice` can return outdated data if the Chainlink aggregator feed fails to update in time or if the price feed stops working. This can happen due to various reasons such as a temporary network issue or a bug in the aggregator contract. The function checks for timeStamp and answeredInRound, however, these conditions might not be enough to guarantee the freshness of the data.
d61_2	2	setUniswapFeedAddress	Unexpected function invocation arguments	The function `setUniswapFeedAddress` does not validate if the pool address provided actually represents a valid Uniswap pool for the given token pair. An attacker could potentially set an incorrect pool address, which could lead to incorrect price information being used. To mitigate this, the function should validate the pool address by checking if it is indeed a valid Uniswap pool for the given token pair.
d61_2	1	withdraw, withdrawFrom, _withdraw	Business-flow atomicity violation	The `withdraw` and `withdrawFrom` functions call the internal `_withdraw` function. The `_withdraw` function unlocks tokens/shares from the strategy and then transfers them to the receiver address. However, there is no check ensuring the transfer is successful. In case of a failed transfer, the tokens would remain unlocked in the contract, but the balanceInShares would be decreased, causing an inconsistency in the user's balance.
d61_2	2	withdrawAll	Unexpected environment or contract conditions	The `withdrawAll` function iterates through the list of strategies and withdraws the user's balance in each strategy. However, there is no check to ensure that the strategies are still valid, i.e., they have not been removed from the strategy registry. In case a strategy is removed from the registry but still holds user balances, the `withdrawAll` function would not be able to withdraw tokens locked in that strategy, leading to a potential loss of user funds.
d58_2	null
d54_3	null
d54_3	1	_cancelAndRefund	Business-flow atomicity violations	The _cancelAndRefund function cancels the key and transfers the refund amount to the key owner. However, it does not ensure atomicity of these operations. If the transfer of the refund fails (e.g., due to out-of-gas exception), the key would still be cancelled, causing a discrepancy between the key's state and the expected refund amount.
d54_3	1	purchase	Business-flow atomicity violations	The purchase function handles the assignment of keys, the recording of key purchases, and the transfer of funds. However, it does not ensure atomicity for these operations. If any of these operations fail (e.g., due to out-of-gas exception), the contract state may be left in an inconsistent state. To address this issue, the contract should use a checkpoint-revert mechanism to ensure that all operations succeed or all are reverted.
d54_2	1	purchase	Unexpected function invocation arguments	In the purchase function, there is a check to ensure that the price paid by the user is greater than or equal to the minimum price (`require(pricePaid >= inMemoryKeyPrice, 'INSUFFICIENT_VALUE');`). However, the function does not validate the input parameters, such as `_value`, `_recipient`, and `_referrer`. A malicious actor could exploit these unchecked parameters to cause unexpected behavior.
d54_2	2	purchase	Unexpected environment or contract conditions	The contract relies on external calls to `unlockProtocol.recordConsumedDiscount(discount, tokens);`, `unlockProtocol.recordKeyPurchase(inMemoryKeyPrice, _referrer);`, and `onKeyPurchaseHook.onKeyPurchase(msg.sender, _recipient, _referrer, _data, inMemoryKeyPrice, pricePaid);`. This introduces potential risks related to reentrancy and the execution of malicious code from external contracts.
d54_2	3	purchase	Unexpected function invocation sequences	The purchase function updates the `toKey.expirationTimestamp` and emits events before transferring tokens or making external calls. A malicious contract could potentially call the purchase function in a specific sequence or frequency to manipulate the `expirationTimestamp` and related events without actually completing a valid purchase. Reordering the function execution to ensure proper transfer and external calls before updating the timestamp and emitting events can mitigate this risk.
d54_2	1	cancelAndRefund	Unexpected function invocation arguments	In the cancelAndRefund function, the _tokenId parameter is not validated. A malicious actor could provide an invalid tokenId, which might cause unexpected behavior.
d54_2	2	_cancelAndRefund	Unexpected environment or contract conditions	The contract relies on external calls to `_transfer(tokenAddress, _keyOwner, refund);` and `onKeyCancelHook.onKeyCancel(msg.sender, _keyOwner, refund);`. This introduces potential risks related to reentrancy and the execution of malicious code from external contracts.
d54_2	3	_cancelAndRefund	Unexpected function invocation sequences	The _cancelAndRefund function updates the key's `expirationTimestamp` and emits the CancelKey event before transferring funds and making an external call to `onKeyCancelHook.onKeyCancel`. This could allow a malicious contract to call _cancelAndRefund in a specific sequence or frequency to manipulate the `expirationTimestamp` and related events without actually completing a valid refund. Reordering the function execution to ensure proper transfer and external calls before updating the timestamp and emitting events can mitigate this risk.
d54_2	1	shareKey	Business-flow atomicity violations	In the `shareKey` function, there is no atomicity in operations like updating the expirationTimestamp, tokenId, and key manager. If a transaction fails in the middle of this process, it could result in an inconsistent state. To fix this issue, consider wrapping these operations in a function that reverts all changes if an error occurs during execution.
d52_2	1	mint	Unexpected environment or contract conditions	The `mint` function does not consider the possibility of slippage occurring during the minting process. Slippage can occur when there is a significant difference in the price of the assets in the pool. The contract does not have a mechanism to control slippage, which might lead to users getting fewer tokens than expected.
d52_2	2	swap	Unexpected function invocation arguments	The `swap` function allows users to swap tokens in the pool. However, it does not have any input validation for the `to` address parameter. This lack of validation means that a user can accidentally or maliciously provide an invalid address (e.g., zero address or the contract's own address), resulting in a potential loss of funds.
d52_2	1	update	Business-flow atomicity violation	In the `update` function, the average prices for all token pairs are updated without any restrictions on who can call this function. This can lead to potential manipulation of the oracle's average prices by repeatedly calling the function. It would be better to restrict access to this function using a modifier, like `onlyOwner`.
d52_2	2	registerPair	Unexpected function invocation arguments, sequences or frequencies	In the `registerPair` function, there is no check for whether `factory` is a zero address or not. This could lead to unexpected behavior if a zero address is provided as the factory argument. It is recommended to add a check for the factory address to ensure it is not a zero address.
d52_2	3	consult	Unexpected environment or contract conditions	In the `consult` function, the Chainlink aggregator is used to fetch the latest round data without checking whether the data is outdated or not. To ensure the oracle doesn't return outdated data, it would be recommended to add a check to ensure the data returned by the aggregator is recent enough, for example by comparing its timestamp to the current block's timestamp with an acceptable tolerance.
d52_2	4	registerPair	Unexpected environment or contract conditions	In the `registerPair` function, the provided token0 and token1 are not checked if they are valid ERC20 tokens or not. The contract assumes the provided tokens are ERC20 compliant. It is recommended to add a check to ensure both token0 and token1 are valid ERC20 tokens before proceeding with the registration process.
d52_2	1	enter	Unexpected contract conditions	The `enter` function calculates the amount of xVADER to be minted based on the totalVader and totalShares. However, it does not account for potential slippage in the price of VADER tokens, which could occur if the price of VADER changes rapidly. This could lead to imprecise calculations of xVADER minted and cause users to receive an incorrect amount of xVADER tokens.
d39_3	1	transferNotionalFrom	Business-flow atomicity violation	In the `transferNotionalFrom` function, the notional is transferred from one address to another, and the interests of both vaults are updated. However, there is no atomicity guarantee to ensure that either both transfers and interest updates are successful or none at all. If an unexpected error or revert occurs during this process, the contract might end up in an inconsistent state.
d39_3	3	matureVault	Unexpected environment or contract conditions	In the `matureVault` function, the contract relies on `block.timestamp` to determine if the maturity has been reached. Miners can manipulate the `block.timestamp` within a certain range, potentially causing the vault to mature earlier or later than intended. However, this manipulation is limited, and the impact on the contract might be minimal.
d28_3	null
d28_3	1	depositETH	Unexpected function invocation arguments	The depositETH function assumes that the smart contract accepts ETH only if token1 or token2 is WETH. However, it is possible for the contract to accept ETH when both tokens are not WETH. This can happen if the paymentCurrency in the market is ETH_ADDRESS, but the auctionToken is not WETH.
d28_3	2	finalize	Business-flow atomicity violations	The finalize function can be called multiple times, causing the liquidity to be added multiple times. The launcherInfo.launched variable is set to true after the liquidity is added, but it should be set before to prevent multiple calls to finalize.
d47_1	1	transfer, transferFrom	Unexpected function invocation arguments	The `transfer` and `transferFrom` functions expect the input `amount` to be in wibBTC, but it's not clear if the users are aware of this. Since the functions internally convert the amount to ibBTC shares, users might accidentally transfer the wrong amount of tokens. It would be better to have a clear documentation or a separate function for transferring in terms of shares.
d47_1	2	mint, burn	Business-flow atomicity violations	The `mint` and `burn` functions do not use the `nonReentrant` modifier, which might expose the contract to reentrancy attacks. If a malicious token contract is used, it could call the `mint` or `burn` functions recursively during the execution of `ibbtc.transferFrom` or `ibbtc.transfer`, causing unexpected behavior or loss of funds.
d47_1	3	pricePerShare	Unexpected environment or contract conditions	The `pricePerShare` function relies on the external `oracle` contract to return the current price per share. If the oracle provides outdated or incorrect data, it might cause the `WrappedIbbtc` contract to operate with incorrect values, leading to potential loss of funds or incorrect token balances. It is essential to ensure the oracle provides accurate and up-to-date data.
d47_1	1	transfer, transferFrom	Unexpected function invocation arguments	The `transfer` and `transferFrom` functions expect the input `amount` to be in wibBTC, but it's not clear if the users are aware of this. Since the functions internally convert the amount to ibBTC shares, users might accidentally transfer the wrong amount of tokens. It would be better to have clear documentation or a separate function for transferring in terms of shares.
d47_1	2	mint, burn	Business-flow atomicity violations	The `mint` and `burn` functions do not use the `nonReentrant` modifier, which might expose the contract to reentrancy attacks. If a malicious token contract is used, it could call the `mint` or `burn` functions recursively during the execution of `ibbtc.transferFrom` or `ibbtc.transfer`, causing unexpected behavior or loss of funds.
d47_1	3	updatePricePerShare	Unexpected environment or contract conditions	The `updatePricePerShare` function relies on the external `core` contract to return the current price per share. If the `core` contract provides outdated or incorrect data, it might cause the `WrappedIbbtcEth` contract to operate with incorrect values, leading to potential loss of funds or incorrect token balances. It is essential to ensure the `core` contract provides accurate and up-to-date data.
d42_2	null
d39_2	1	addNotional, removeNotional, transferNotionalFrom, transferNotionalFee	Unexpected function invocation arguments	The functions addNotional, removeNotional, transferNotionalFrom, and transferNotionalFee can only be called by the `admin`. This might create a single point of failure or trust issues, as the admin could potentially manipulate the vaults of other users without their consent.
d39_2	2	matureVault	Unexpected environment or contract conditions	The matureVault function is called to set the maturityRate and mark the vault as matured. However, it relies on the `block.timestamp`, which can be manipulated by miners within a certain range ( 15 seconds). This manipulation can potentially affect the maturity rate calculation and have unexpected consequences for the vault's interest calculations.
d39_2	3	addNotional, removeNotional, transferNotionalFrom, transferNotionalFee	Unexpected environment or contract conditions	The functions addNotional, removeNotional, transferNotionalFrom, and transferNotionalFee all rely on the external call to `CErc20(cTokenAddr).exchangeRateCurrent()` which can potentially return outdated data or be affected by temporary market fluctuations. This might lead to inaccuracies in the interest calculations and have unexpected consequences for the users' vaults.
d28_2	1	initCrowdsale	Unexpected function invocation arguments	The function initCrowdsale is public and can be called by anyone. This can lead to potential misuse or unintended behavior. The function should be either internal or have proper access control checks to prevent misuse.
d28_2	1	depositETH	Unexpected environment or contract conditions	The depositETH() function checks if the token1 or token2 is WETH (wrapped Ether) before allowing the deposit of Ether. However, it is possible that the ChainLink returns outdated data, and the deposited Ether amount is not accurately represented in the WETH token. This can lead to incorrect token amounts being used during liquidity pool creation.
d28_2	2	initAuctionLauncher	Unexpected function invocation arguments	The initAuctionLauncher function takes the _locktime parameter as input, and then it checks if the _locktime is less than 10000000000. This assumes that the user is entering an Unix timestamp in seconds, not milliseconds. If the user mistakenly inputs a timestamp in milliseconds, it will not be properly handled, which can lead to incorrect liquidity lock durations.
d28_2	3	finalize	Business-flow atomicity violations	The finalize() function is responsible for adding liquidity to the Uniswap pool after the auction is finalized. The function is not atomic, meaning that it can be called multiple times before the liquidity is added to the pool. This can result in an incorrect state of the contract, and it may lead to multiple finalize() calls and incorrect liquidity values.
d28_2	4	withdrawLPTokens, withdrawDeposits	Unexpected function invocation sequences	The withdrawLPTokens() and withdrawDeposits() functions can only be called by an admin or operator role. However, there is no restriction on the sequence in which these functions can be called. This can lead to unexpected outcomes if the admin or operator calls the functions in an incorrect order, or before the finalize() function has been called.
d28_2	5	cancelLauncher	Business-flow atomicity violations	The cancelLauncher() function allows an admin to cancel the launcher, marking it as launched without actually adding liquidity to the pool. This can result in the contract being in an inconsistent state, as it appears launched without actually having gone through the necessary steps. It may also cause issues for users who interacted with the launcher before it was canceled.
d12_3	1	stir	Business-flow atomicity violations	The 'stir' function transfers collateral and debt between two vaults without ensuring atomicity. If the function call fails in the middle, it may result in an inconsistent state. To fix this issue, consider using a more atomic approach, such as using a temporary variable to store the new state and updating the state in a single step.
d12_3	1	pour	Unexpected function invocation arguments, sequences, or frequencies	The 'pour' function allows the caller to modify the collateral and debt in a vault. However, the function does not validate the caller's identity, allowing anyone with access to the function to call it with arbitrary arguments. To fix this issue, consider adding an access control mechanism (e.g., onlyOwner, or a specific role) to restrict the callers who can invoke the function.
d12_3	1	batch	Reentrancy Attack	The `batch` function in the Ladle contract is designed to execute a batch of operations atomically. However, it calls external contracts (including `moduleCall` and some others) which could potentially be malicious. A malicious contract can call back into the `batch` function, causing unexpected behavior and a reentrancy attack. To mitigate this issue, consider using the Checks-Effects-Interactions pattern and adding a reentrancy guard.
d12_3	2	Various (e.g., `_serve`, `_close`, `_repay`)	Front-Running	Several functions in the Ladle contract involve trading operations (such as `_serve`, `_close`, and `_repay`). These operations interact with external contracts like IPool and IFYToken. Since Ethereum transactions are public, miners or other users could front-run these transactions, potentially leading to unfavorable trading conditions for users of the Ladle contract. To mitigate this issue, consider implementing mechanisms to minimize front-running, such as batching transactions, private transactions, or using decentralized trading solutions that offer protection against front-running.
d23_2	null
d19_2	null
d16_2	1	liquidate	Unexpected function invocation arguments	The 'liquidate' function accepts an int256 'amount' as one of its arguments. However, it does not check if the given amount is a positive number or not. This may lead to incorrect behavior if a negative value is passed.
d16_2	2	verifyAndSubmitLiquidation	Unexpected environment or contract conditions	The 'verifyAndSubmitLiquidation' function checks if the gas price of the transaction (tx.gasprice) is less than or equal to the fast gas oracle's latest answer (IOracle(fastGasOracle).latestAnswer()). This may result in a potential issue if the fast gas oracle returns outdated data, as it could lead to liquidations being executed with an incorrect gas price.
d12_2	1	pour, slurp	Business-flow atomicity violations	In the 'pour' and 'slurp' functions, the '_pour' function is called to update the balances, and then the collateralization level is checked. This allows for the possibility of temporary atomicity violations, where the vault's collateralization level is not maintained throughout the entire operation.
d12_2	3	mature	Unexpected environment or contract conditions	The 'grab' function locks a vault if it is undercollateralized, but it does not check for ChainLink oracles returning outdated data or slippage occurring during asset price fetching. If an oracle returns outdated or incorrect data, this could lead to an incorrect vault lock.
d12_2	1	batch	Re-entrancy vulnerability	The batch function is vulnerable to a re-entrancy attack because it allows external contract calls through the `Operation.MODULE` operation type. An attacker could craft a malicious contract to call the `batch` function again before the initial call has completed, potentially causing undesired side effects or manipulation of the state.
d12_2	2	addJoin, addPool	Lack of input validation	The addJoin and addPool functions do not validate the input addresses for the join and pool contracts, allowing the potential to add a malicious or incorrect contract. This could lead to manipulation of the state or unintended behavior.
d12_2	3	setModule, setFee	Centralization of control	The setModule and setFee functions are only accessible by the `auth` modifier, which allows only authorized users to change the state of the contract. This centralizes control over the contract and introduces a point of failure. If the owner's private key is compromised, an attacker could take control over the contract, potentially causing undesired side effects or manipulation of the state.
d12_2	4	_moduleCall	Unchecked external call return value	The `_moduleCall` function does not check the return value of the external contract call (`module.call()`) to ensure the successful execution of the called function. This may lead to unintended behavior or state inconsistency if the external contract call fails to execute successfully.
d5_3	1	cancelProposal	Business-flow atomicity violations	The cancelProposal function allows a minority to cancel an existing proposal during the finalizing stage, but it doesn't properly revert the state of the old proposal. The votes of the old proposal are set to 0, but other related mappings and states are left unchanged. An attacker can potentially exploit this by calling cancelProposal repeatedly, manipulating the state of the contract.
d5_3	1	init	Business-flow atomicity violation	The init function is missing a mechanism to prevent multiple initializations. While the contract sets the `inited` variable to true, it doesn't check if the variable is already true when the function is called. Multiple initializations can lead to unintended contract behavior, such as changing the contract's essential parameters, like VADER, USDV, ROUTER, FACTORY, and POOLS, and manipulating their values.
d5_3	2	depositForMember	Unexpected function invocation arguments	The depositForMember function accepts any synth address as long as it is a Synth. However, there is no validation to check whether the provided `amount` is greater than 0. If a user deposits with an `amount` of 0, the function will still execute and emit the `MemberDeposits` event, leading to incorrect and misleading event data.
d5_3	3	calcCurrentReward	Unexpected environment or contract conditions	In the calcCurrentReward function, if the calculated reward is greater than or equal to the reserve (either reserveUSDV or reserveVADER), the reward is set to the reserve's full amount. This condition might lead to a situation where the contract's entire reserve is depleted by a single member's harvest, potentially affecting other members' ability to harvest or withdraw their funds.
d3_3	1	crossSwapExactTokensForTokens	Unexpected function invocation arguments	The function crossSwapExactTokensForTokens does not check if the provided input tokens and output tokens are the same. Swapping the same tokens may lead to an unexpected behavior and loss of funds due to fees.
d3_3	2	crossSwapTokensForExactTokens	Unexpected function invocation arguments	The function crossSwapTokensForExactTokens does not check if the provided input tokens and output tokens are the same. Swapping the same tokens may lead to an unexpected behavior and loss of funds due to fees.
d10_2	null
d8_2	1	updatePoolForVault	Unexpected function invocation arguments	In the function updatePoolForVault, it updates the staking pool for the given vaultId by calling stakingTokenProvider.stakingTokenForVaultToken(pool.rewardToken). This function could potentially return unexpected staking tokens if the stakingTokenProvider contract is compromised or if the staking token mapping for the given reward token is not properly set. To mitigate this risk, ensure proper access control and validation in the stakingTokenProvider contract.
d8_2	2	receiveRewards	Unexpected environment or contract conditions	The receiveRewards function transfers rewards from the caller to the rewardDistToken contract and then distributes the rewards. However, the function doesn't check if the reward token's transferFrom function is successful. If the transfer fails (e.g., due to insufficient allowance or balance), the contract will continue to distribute the rewards, which can lead to incorrect reward distribution. To fix this issue, check the return value of the transferFrom function and revert the transaction if it returns false.
d8_2	3	deposit	Unexpected environment or contract conditions	The deposit function transfers the staking tokens from the sender to the contract and mints reward distribution tokens. However, it doesn't check if the staking token's transferFrom function is successful. If the transfer fails (e.g., due to insufficient allowance or balance), the contract will continue to mint the reward distribution tokens, leading to incorrect token supply. To fix this issue, check the return value of the transferFrom function and revert the transaction if it returns false.
d5_2	1	grantFunds	Unexpected environment or contract conditions	In the grantFunds function, there is a check to ensure that the grant amount requested is not more than 10% of the USDV balance in the VAULT. However, this check is susceptible to potential changes in the USDV balance that may occur between the time the proposal is made and the time it is executed. If the balance decreases due to external factors, the check may fail, and the proposal may not be executed as intended.
d5_2	2	cancelProposal	Business-flow atomicity violations	The cancelProposal function allows for the cancelation of an existing proposal when a new proposal is created with a minority of votes. However, the function does not ensure that the new proposal has the same or higher number of votes than the old one, allowing for potential manipulation of the voting process. Moreover, the votes for the old proposal are set to 0 without any checks, which may lead to incorrect vote counts in the future.
d5_2	null
d3_2	1	crossOvercollateralizedBorrow	Business-flow atomicity violations	The `crossOvercollateralizedBorrow` function deposits funds, registers a borrow, and then withdraws the borrowed funds. This function does not ensure atomicity, meaning that if any of these actions fail, the funds could be left in an inconsistent state. To fix this issue, consider using a Solidity `require` statement to check the success of each action and revert the transaction if any of them fail.
145_3	1	wrapETH2LD	Unchecked external calls	In the wrapETH2LD function, there is an external call to registrar.transferFrom(registrant, address(this), tokenId); that isn't checked for success or failure. This could lead to incorrect state updates in the smart contract if the transfer fails.
145_3	2	registerAndWrapETH2LD	Unchecked external calls	In the registerAndWrapETH2LD function, there is an external call to registrar.register(tokenId, address(this), duration); that isn't checked for success or failure. This could lead to incorrect state updates in the smart contract if the register call fails.
145_3	3	renew	Unchecked external calls	In the renew function, there is an external call to registrar.renew(tokenId, duration); that isn't checked for success or failure. This could lead to incorrect state updates in the smart contract if the renew call fails.
145_3	4	setUpgradeContract	Unchecked external calls	In the setUpgradeContract function, there are external calls to registrar.setApprovalForAll(address(upgradeContract), false); and ens.setApprovalForAll(address(upgradeContract), false); that aren't checked for success or failure. This could lead to incorrect state updates in the smart contract if any of these calls fail.
145_3	5	unwrapETH2LD	Unchecked external calls	In the unwrapETH2LD function, there is an external call to registrar.transferFrom(address(this), newRegistrant, uint256(labelhash)); that isn't checked for success or failure. This could lead to incorrect state updates in the smart contract if the transfer call fails.
192_2	null
145_2	1	wrap	IncompatibleParent	In the 'wrap' function, when the parentNode is equal to ETH_NODE, it reverts with 'IncompatibleParent'. However, it is not clear why wrapping a subdomain under ETH_NODE should not be allowed, as the wrapETH2LD function allows it. This may lead to inconsistent behavior between the two wrapping functions.
145_2	2	setMetadataService	Unrestricted setMetadataService	The setMetadataService function allows changing the metadata service without any restrictions, which could potentially be abused by the contract owner to change the metadata service to a malicious one. It might be better to implement a time-lock or a multisig mechanism for updating the metadata service to prevent abuse.
145_2	3	upgradeETH2LD, upgrade	Function upgradeETH2LD and upgrade	In both the upgradeETH2LD and upgrade functions, the upgradeContract is called without checking if it is set to a valid address. If the upgradeContract is not set (i.e., address(0)), it would result in a revert. To improve the user experience, it would be better to check if the upgradeContract is set and provide a more meaningful error message.
112_3	null
83_3	1	deposit	Integer Overflow	In the deposit function, the `user.amount` and `pool.accConcurPerShare` are being multiplied without checking for integer overflow. The product of these two values could exceed the maximum value for a uint128, causing an integer overflow.
78_3	1	withdrawGovernanceAsset	Reentrancy Vulnerability	In the withdrawGovernanceAsset function, the external call to transfer the asset is made before the state is updated. This could potentially lead to a reentrancy attack where an attacker could repeatedly call the function and drain the contract of the assets. To fix this, the state should be updated before making the external call.
78_3	2	assertGovernanceApproved	Unchecked Return Value	The assertGovernanceApproved function calls the transferFrom function without checking its return value. If the transferFrom function fails for any reason, it may return false, but the rest of the assertGovernanceApproved function will continue to execute, leading to incorrect state updates. To fix this issue, the return value of the transferFrom function should be checked.
70_3	1	getStaleVaderPrice, getStaleUSDVPrice	Stale price data vulnerability	The functions getStaleVaderPrice and getStaleUSDVPrice calculate and return the stale prices of Vader and USDV tokens, respectively. These stale prices are based on the pastLiquidityEvaluation values of the pairs. If these values are not updated frequently enough or if there are issues with the oracles, the stale prices may not accurately reflect the current market prices, which could be exploited by attackers for profit.
70_3	2	getVaderPrice, getUSDVPrice	Reentrancy vulnerability	The getVaderPrice and getUSDVPrice functions update the state of the contract, and then call an external contract (Chainlink Oracle) to get the price of the foreign asset. If the external contract is malicious and calls the same function before the initial function call is completed, it could lead to a reentrancy attack. You can mitigate this issue by using a reentrancy guard or by restructuring the code to separate state updates from external calls.
70_3	3	_updateVaderPrice, _updateUSDVPrice	Unchecked arithmetic vulnerability	In the _updateVaderPrice and _updateUSDVPrice functions, the nativeTokenPriceAverage is calculated using unchecked arithmetic. If an overflow or underflow occurs, this could lead to incorrect price updates. To avoid this issue, you should use the "SafeMath" library or "checked" arithmetic operations in Solidity 0.8.x to ensure that overflows and underflows are handled properly.
70_3	4	setupVader, setupUSDV	Unhandled error conditions	In the setupVader and setupUSDV functions, there are no checks to ensure that the updatePeriod is greater than the maxUpdateWindow. If the updatePeriod is less than the maxUpdateWindow, this could lead to incorrect price updates. You should add a check to ensure that the updatePeriod is greater than the maxUpdateWindow before allowing the function to proceed.
68_3	1	joinTokenSingle	Incorrect amount check	In the `joinTokenSingle` function, there is no proper check for the input token amount provided by the user. It is possible that the user sends a higher input amount than `_joinTokenStruct.inputAmount`, but the smart contract only transfers `_joinTokenStruct.inputAmount` to itself. When the function completes, any remaining balance of the input token will be sent back to the user. This might lead to incorrect calculations in the `_joinTokenSingle` function.
68_3	2	_joinTokenSingle	Possible price manipulation	In the `_joinTokenSingle` function, the deadline for the `swapExactTokensForTokens` function call is set to `block.timestamp`, which essentially means the swap will not fail due to deadline issues. However, this makes the contract vulnerable to price manipulation by malicious actors who can perform sandwich attacks. Setting a proper deadline for the swap can help mitigate this issue.
68_3	3	_maxApprove	Unsafe approval	The `_maxApprove` function is called multiple times to set the allowance for various token transfers. This function approves the maximum possible uint256 value as the allowance, which can be risky in certain scenarios. To avoid unnecessary risks, it is better to only approve the amount that is actually needed.
145_1	1	setSubnodeOwner	Incorrect State Update	The function 'setSubnodeOwner' allows a user to set a subnode owner, but it does not correctly update the state of the subnode. The function sets the subnode owner without checking if the owner exists or not. This could result in an incorrect state update and allow an attacker to change the owner of a subnode without proper authorization.
145_1	2	wrapETH2LD	Reentrancy	The 'wrapETH2LD' function is vulnerable to reentrancy attacks. The function transfers the ownership of the token to the contract before updating the state (i.e., calling _wrapETH2LD()). An attacker can exploit this vulnerability by calling the same function again before the state update is completed, which can lead to incorrect state updates and unintended consequences.
145_1	3	unwrapETH2LD	Reentrancy	Similar to the 'wrapETH2LD' function, the 'unwrapETH2LD' function is also vulnerable to reentrancy attacks. The function transfers the ownership of the token from the contract to the new registrant before updating the state (i.e., calling _unwrap()). This could allow an attacker to exploit the vulnerability by calling the same function again before the state update is completed, leading to incorrect state updates and unintended consequences.
112_2	1	unstakeFor	Re-entrancy vulnerability	The `unstakeFor` function can potentially be exploited by a reentrancy attack since it calls an external contract, `IERC20(token).safeTransfer(dst, amount)`, before updating the state of `balances[src]`. If the `dst` address is a malicious contract, it can re-enter the `unstakeFor` function and withdraw more tokens than it should be allowed to.
83_2	1	deposit, withdraw	Rounding Error	In the deposit and withdraw functions, reward calculations involve integer division, which may cause rounding errors. In the following lines:
78_2	1	configureSecurityParameters	Missing input validation	In the function configureSecurityParameters, the parameter 'changeTolerance' is not properly validated. The require statement checks if security.changeTolerance is less than 100, but it should check if changeTolerance is less than 100.
78_2	2	enforceToleranceInt	Integer underflow	In the function enforceToleranceInt, the calculation `-1 * v1` and `-1 * v2` can result in integer underflow, as Solidity does not protect against integer underflows by default.
70_2	1	getChainlinkPrice	Stale Chainlink Price	The function getChainlinkPrice does not take into account the possibility of a stale price due to a price update not occurring for a long period of time. It only checks if the answeredInRound >= roundID, but this might not be enough to ensure the freshness of the data.
70_2	2	_updateVaderPrice, _updateUSDVPrice	Unchecked Arithmetic Operations	In both functions _updateVaderPrice and _updateUSDVPrice, there are unchecked arithmetic operations that may lead to incorrect results due to overflows or underflows. For instance, the calculation of pairData.nativeTokenPriceAverage can be subject to overflows if the values involved are too large. Using SafeMath or Solidity 0.8.x's built-in overflow/underflow checks is recommended to prevent these issues.
70_2	3	syncVaderPrice, syncUSDVPrice	Potential Reentrancy	In functions syncVaderPrice and syncUSDVPrice, the state variables totalLiquidityWeight are updated after the for loop, while the for loop involves external calls like getChainlinkPrice. This may lead to potential reentrancy issues if the called contracts are malicious or compromised. It is recommended to apply the Checks-Effects-Interactions pattern and update the state variables before making external calls.
68_2	1	joinTokenSingle	Reentrancy 	The joinTokenSingle function is vulnerable to a reentrancy attack. The function first transfers the input tokens from the user to the contract and then calls the _joinTokenSingle internal function. After executing _joinTokenSingle, it sends the remaining input tokens back to the user. The problem is that the function sends the remaining tokens back to the user before updating the state of the contract, which makes it vulnerable to a reentrancy attack. An attacker could potentially call the joinTokenSingle function again before the state is updated, leading to incorrect state updates and unintended behavior. To mitigate this issue, you can use the Checks-Effects-Interactions pattern, which would involve updating the state before transferring the remaining tokens back to the user.
68_2	2	_joinTokenSingle	Front-running	The _joinTokenSingle function is vulnerable to front-running attacks. The function uses the block.timestamp for the deadline when calling the IPangolinRouter(swap.exchange).swapExactTokensForTokens function. Since miners can manipulate the block.timestamp within a certain range, a malicious miner or a front-runner could potentially exploit this to their advantage. To mitigate this issue, you can use the block.number instead of block.timestamp and add a reasonable number of blocks for the deadline. This would make it more difficult for a miner or a front-runner to manipulate the deadline.
54_3	null
54_3	1	shareKey	Reentrancy Attack	In the shareKey function, the `_checkOnERC721Received` call is made after the state updates have been completed. This call can potentially trigger an external contract, making the contract vulnerable to reentrancy attacks.
54_3	2	transferFrom	Reentrancy Attack	Similar to the shareKey function, the transferFrom function has a potential reentrancy vulnerability due to the call to `emit Transfer(_from, _recipient, _tokenId);` before the state updates have been completed.
54_3	3	transfer	Reentrancy Attack	In the transfer function, the shareKey and transferFrom functions are called before the state updates, which could also lead to a reentrancy vulnerability.
54_3	4	safeTransferFrom	Reentrancy Attack	The safeTransferFrom function calls the transferFrom function and then checks the ERC721Received. This also poses a potential reentrancy vulnerability.
42_3	1	updateReserve	Incorrect state update	The `updateReserve` function calculates the new reserve and updates the `treasuryShare`. However, it doesn't update the `mochiShare` correctly. The updated `mochiShare` should be calculated based on the updated `treasuryShare` and not the balance of USDM in the contract.
42_3	2	distributeMochi	Potential reentrancy	The `distributeMochi` function calls `_buyMochi` and `_shareMochi` functions, which can interact with external contracts (Uniswap and Mochi tokens). This may open up the possibility for reentrancy attacks, which could lead to incorrect state updates.
42_3	1	addReward	Incorrect state update	The `addReward` function calculates the new reward and updates the `reward` mapping for the given recipient, but it doesn't update the `rewards` state variable correctly. The `rewards` variable should be updated based on the new reward for the recipient.
42_3	2	claimRewardAsMochi	Potential reentrancy	The `claimRewardAsMochi` function interacts with external contracts (Uniswap and Mochi tokens) and may open up the possibility for reentrancy attacks, which could lead to incorrect state updates.
36_3	1	handleFees	Reentrancy	In the handleFees() function, the contract mints tokens and sends them to the publisher and the factory owner. This operation might be prone to reentrancy attacks, as an attacker can use a malicious contract as the publisher or factory owner and call functions such as mint() or burn() in the fallback function. To mitigate this issue, consider using the Checks-Effects-Interactions pattern.
36_3	2	handleFees	Integer Overflow	In the handleFees() function, when calculating the fee and the newIbRatio, arithmetic operations with large numbers can lead to integer overflow. To avoid this issue, consider using the SafeMath library from OpenZeppelin for all arithmetic operations in the contract.
36_3	3	approveUnderlying	Unchecked Token Approvals	In the approveUnderlying() function, the contract approves an unlimited allowance of each token for the spender. This approach might not be secure, as it can allow malicious contracts to drain all tokens. Instead, consider setting a reasonable allowance limit or resetting the allowance to zero before setting a new value.
36_3	4	N/A	Unprotected State Variables	State variables (publisher, licenseFee, factory, auction, ibRatio, pendingPublisher, pendingLicenseFee, pendingWeights, tokens, weights, and lastFee) are declared as public, which can expose them to potential manipulation. Consider making them private and providing getter functions if necessary.
65_2	1	mintTo	Reentrancy	The `mintTo` function is marked as nonReentrant, but it calls the `pullUnderlying` function which in turn calls `IERC20.safeTransferFrom`. The `safeTransferFrom` function may result in reentrancy issues, as it can potentially call an external contract via the `from` address. An attacker may use this vulnerability to manipulate the state before the execution of the rest of the function.
65_2	2	validateWeights	Incomplete validation	The `validateWeights` function is intended to check the uniqueness of tokens, but it only adds the current token to the `tokenList` array after the inner loop has finished. This means that the function may fail to detect duplicate tokens in some cases. To fix this, move the `tokenList[i] = _tokens[i];` line inside the inner loop, right after the `require(_tokens[i] != tokenList[x]);` statement.
65_2	3	handleFees	Timestamp manipulation	The `handleFees` function relies on `block.timestamp` to calculate the time difference and fees. However, `block.timestamp` can be manipulated by miners within a certain range. Instead of using `block.timestamp`, consider using block numbers and a well-defined average block time for more accurate and less manipulable calculations.
58_2	1	updateTvls	Incorrect state update	The function `updateTvls()` updates the `_tvls` state variable by setting its elements to the current aToken balances. This may not take into account accrued interest or donations to Aave since the last deposit or withdraw, leading to an incorrect state update.
58_2	2	_push	Missing state update	The function `_push()` does not update the `_tvls` state variable after depositing tokens to the Aave Lending Pool. This could lead to an incorrect state as the function does not reflect the new token amounts in the `_tvls` state variable.
58_2	3	_pull	Missing state update	The function `_pull()` does not update the `_tvls` state variable after withdrawing tokens from the Aave Lending Pool. This could lead to an incorrect state as the function does not reflect the new token amounts in the `_tvls` state variable.
54_2	2	_recordOwner	Approval bypass	The _recordOwner function pushes the _keyOwner into the `owners` array without checking if the _keyOwner already exists in the array. This can lead to duplicate entries in the `owners` array, causing inefficiency in storage and possible incorrect results in the `numberOfOwners` function.
54_2	3	_setKeyManagerOf	Duplicate entries in `owners` array	The _setKeyManagerOf function emits the KeyManagerChanged event with the new key manager address always set to address(0). This does not accurately reflect the new key manager's address and can cause confusion for any off-chain listeners monitoring the event.
54_2	1	shareKey	Incorrect state update	In the shareKey function, the parent key's expirationTimestamp is updated using the _timeMachine function. However, the tokenId is not updated, which could cause issues if the parent key is shared multiple times. To fix this, the parent key's tokenId should be updated to a new tokenId after the _timeMachine function call.
54_2	2	transferFrom	Incorrect state update	In the transferFrom function, the fromKey's tokenId is set to 0 after transferring the key to the new owner, but the fromKey's key manager is not reset. This could lead to incorrect state update, as the key manager should be reset to the address(0). To fix this, reset the key manager for the fromKey after setting the tokenId to 0.
54_2	3	transfer	Incorrect state update	In the transfer function, the key is shared or transferred based on the condition `maxTimeToSend < timeRemaining`. However, this check does not account for the transfer fee. As a result, the check should be updated to include the transfer fee. To fix this, calculate the transfer fee and update the condition as `maxTimeToSend + transferFee < timeRemaining`.
42_2	1	updateReserve	Integer Overflow	In the updateReserve function, there is a possibility of integer overflow when calculating the newReserve. If the sum of mochiShare and treasuryShare is larger than the balance of USDM, the subtraction operation will result in an incorrect value for newReserve. This can lead to incorrect updates of treasuryShare and mochiShare.
42_2	1	addReward	Integer Overflow	In the addReward function, there is a possibility of integer overflow when calculating the newReward. If the rewards variable is larger than the balance of USDM, the subtraction operation will result in an incorrect value for newReward. This can lead to incorrect updates of the reward mapping and the rewards variable.
36_2	null
24_3	1	redeemToken	Reentrancy	The `redeemToken` function is vulnerable to a reentrancy attack because it updates the user balance by calling `_burnShares(amount)` after the external call to `yieldSource.redeemToken(amount)`. An attacker could exploit this vulnerability by creating a malicious YieldSource contract that, when `redeemToken` is called, re-enters the `redeemToken` function before the user balance is updated, allowing the attacker to withdraw more than they should be able to.
24_3	2	supplyTokenTo	Reentrancy	The `supplyTokenTo` function is also vulnerable to a reentrancy attack because it updates the user balance by calling `_mintShares(amount, to)` after the external call to `yieldSource.supplyTokenTo(amount, address(this))`. An attacker could exploit this vulnerability by creating a malicious YieldSource contract that, when `supplyTokenTo` is called, re-enters the `supplyTokenTo` function before the user balance is updated, allowing the attacker to mint more shares than they should be able to.
25_3	1	_updateUserRewards	No integer overflow check in `_updateUserRewards()`	In the `_updateUserRewards()` function, the new value of user reserves is calculated without checking for integer overflows. This can potentially lead to incorrect reward calculations.
35_3	1	subscribe	Incorrect mapping access	In the `subscribe` function, the `Incentive` object is being retrieved using the `positionId` instead of the `incentiveId`. This will result in accessing the wrong incentive object.
35_3	2	claimReward	Incorrect mapping access	In the `claimReward` function, the `Incentive` object is being retrieved using the `positionId` instead of the `incentiveId`. This will result in accessing the wrong incentive object.
35_2	1	subscribe	Incorrect Mapping Indexing	In the subscribe function, the incentive is retrieved using the positionId, which should be incentiveId.
35_2	2	claimReward	Incorrect Mapping Indexing	In the claimReward function, the incentive is retrieved using the positionId, which should be incentiveId.
35_2	3	getReward	Incorrect Mapping Indexing	In the getReward function, the incentive is retrieved using the positionId, which should be incentiveId.
25_2	1	_updateUserRewards	Incorrect rewards accumulation	In the _updateUserRewards function, the rewards are calculated using the `_balanceOf[user]` instead of the balance after the token amount is minted, burned, or transferred. This leads to incorrect rewards being accumulated for users during these operations.
24_2	1	_requireYieldSource	Incorrect conditional check	In the _requireYieldSource function, the logic for checking if the provided yield source is valid seems to be incorrect. The condition `isInvalidYieldSource = depositTokenAddress != address(0);` should be `isInvalidYieldSource = depositTokenAddress == address(0);`. The current code will return true when the depositTokenAddress is a non-zero address, marking a valid yield source as invalid, causing the require statement to fail.
19_2	1	cancel	Reentrancy	The `cancel` function is vulnerable to a reentrancy attack. This is because the function first updates the `variantTransactionData` mapping and then performs the `LibAsset.transferAsset` calls to transfer the assets. An attacker may create a malicious contract that can call back the `cancel` function in between the state update and the transfer calls, leading to incorrect state updates and asset transfers.
10_2	1	transferERC20	Reentrancy	The `transferERC20` function is vulnerable to reentrancy attacks. An attacker can exploit this vulnerability by creating a malicious contract that calls `transferERC20` function and initiates a reentrancy attack during the execution of the `TransferHelper.safeTransfer` function. This can potentially lead to loss of funds or incorrect state updates.
10_2	2	delegatedTransferERC20	Reentrancy	The `delegatedTransferERC20` function is vulnerable to reentrancy attacks as well. Similar to the `transferERC20` function, an attacker can exploit this vulnerability by creating a malicious contract that calls the `delegatedTransferERC20` function and initiates a reentrancy attack during the execution of the `TransferHelper.safeTransfer` function. This can potentially lead to loss of funds or incorrect state updates.
3_2	null
3_2	1	_registerBorrow	Incorrect state update	In the function _registerBorrow, when updating the totalShort and totalLong, the global state is updated before checking the token cap. This can lead to an incorrect state update. The require statement should be executed before updating the totalShort and totalLong to prevent incorrect state updates. The corrected function should look like this:
3_2	2	registerTradeAndBorrow	Incorrect state update	In the function registerTradeAndBorrow, the totalLong[tokenFrom] and totalLong[tokenTo] states are updated before checking the token cap for tokenTo. This can lead to an incorrect state update. The require statement should be executed before updating the totalLong states to prevent incorrect state updates. The corrected function should look like this:
