110_3	1	reportHarvest	Incorrect Order of Calculations 	In function `reportHarvest`, `uint256 assetsAtHarvest = balance() - _harvestedAmount;` is calculated before the `_handleFees` function call. It might lead to the wrong calculation of `assetsAtHarvest` if `_handleFees` modifies the balance of the contract. It is recommended to move this line of code after `_handleFees(_harvestedAmount, harvestTime);`.
110_3	2	initialize	Unexpected Values	In the initialize function, no checks are made for the `_feeConfig` array size. This may lead to unexpected behavior if the array size is less than 4. It could cause the contract to revert on initialization, or it could lead to incorrect fees being set.
110_3	4	_depositFor, _depositWithAuthorization, etc.	Deviating Semantics	These functions are callable when the contract is not paused (`whenNotPaused` modifier is used). This might lead to deviating semantics as these functions should typically be callable only when the contract is active (i.e., not paused). It is recommended to use a more descriptive modifier, such as `whenActive`, to improve code clarity and prevent potential bugs.
112_1	1	initializeLpGauge	Incorrect Error Handling	The function 'initializeLpGauge' checks whether the '_LP_GAUGE' exists in the 'currentAddresses' mapping and throws an error if it does. But the error message is 'Error.ROLE_EXISTS' which is misleading as it's not a role but an address that exists. The error message should be appropriately named like 'Error.GAUGE_EXISTS'.
112_1	2	N/A	Duplicate Import	The contract has imported the "../libraries/Errors.sol" and "../interfaces/IController.sol" twice. This is not causing any issues with the code execution, but it's unnecessary and could be cleaned up for better readability.
112_1	3	initialize	Missing Error Handling	In the 'initialize' function, there is no check to prevent the '_token' address from being a zero address. It would be safer to include a require statement to ensure that '_token' is not the zero address.
112_1	4	stakeFor	Incorrect Order of Operations	In the 'stakeFor' function, the tokens are transferred before the balance of the recipient is updated. If there is a failure in the transfer (for example, if the contract does not have enough tokens), the recipient's balance will still be increased. This could lead to an incorrect state where the recipient has more tokens according to the contract than they actually do. The token transfer should be the last operation in the function.
112_1	5	unstakeFor	Potential Reentrancy Bug	In the 'unstakeFor' function, the state (balances, allowances, strategiesTotalStaked, _poolTotalStaked) is updated after the call to 'IERC20(token).safeTransfer'. This can expose the contract to reentrancy attacks, where the 'safeTransfer' function calls back into this contract before the state is updated. It is safer to update the state before making external calls.
112_1	6	unstakeFor	Redundant Check	In the 'unstakeFor' function, there is a redundant check for 'src == msg.sender' in the 'require' statement. The same condition is already covered by the 'allowance_' >= 'amount' condition because if 'src' == 'msg.sender', 'allowance_' would be infinite (as set in the 'transferFrom' function) and thus always greater or equal to 'amount'.
110_1	null
79_3	1	initialize()	Incorrect order of calculations	In the `initialize()` function, `tokenIncentivesPercent` and `tokenReserve` are calculated based on the `balance` at the time of function call. However, it is not guaranteed that the `balance` will not change until `tokenIncentivesForUsers`, `tokenIncentivesBalance` are calculated. Thus, calculations may not reflect the correct `balance` at the time of these calculations. The calculations should be made immediately after the `balance` is fetched.
79_3	2	withdrawAVAX(), withdrawIncentives(), emergencyWithdraw()	Unchecked return value	The return value of the `transfer` function is not checked in these functions. If the `transfer` function fails for some reason (for example, the recipient contract throws an exception), these functions will not notice this and will continue their execution.
79_3	3	withdrawAVAX(), withdrawIncentives(), emergencyWithdraw()	Potential reentrancy	In these functions, external calls (`transfer`) are made before the internal state (`balance`) is updated. This could potentially allow for a reentrancy attack, where the external contract called could re-enter and drain the contract. It's always recommended to follow the Checks-Effects-Interactions pattern to avoid such potential reentrancy issues.
79_3	4	initialize(), atPhase(), getPenalty()	Incorrect use of Solidity's timestamp	In these functions, Solidity's `block.timestamp` is used for determining the start of auctions and calculating penalties. It's important to note that `block.timestamp` can be manipulated by miners to some degree and should not be used for critical calculations. A miner could potentially manipulate the timestamp to influence the phase of the contract.
79_3	6	createPair()	Incorrect order of calculations	In the `createPair()` function, `tokenAllocated` and `tokenIncentivesForUsers` are calculated with integer division which could lead to truncation errors. The calculations should be reordered or use a form of fixed point arithmetic to avoid truncation errors.
78_3	1	redeemRate	Division by Zero Error	The redeemRate function calculates the redeem rate by dividing the balance of the base token held by the contract by the total supply of the proxy token. If the total supply of the proxy token is zero, then this would result in a division by zero error. The function does attempt to catch this with an if statement that checks if the total supply is zero, but it would be better to throw an error in this case instead of returning ONE, as this could cause confusion for the user.
78_3	2	mint, redeem	Potential Re-entrancy Bug	Although it is not a direct accounting bug, these functions have the potential for re-entrancy attacks. They first execute an external call to the ERC20 token, then update the internal state. It would be safer to follow the Checks-Effects-Interactions pattern and update the internal state before executing the external call.
77_3	1	wDiv, wMul, calculateQty, calculateQtyToReturnAfterFees, etc.	Incorrect Calculation	Solidity performs integer division, which means it rounds down. In multiple functions, this contract does division like `a / b` where `a` and `b` are integers. If `a < b`, the result will always be zero, which may not be the expected outcome. You may need to account for these rounding errors in your code.
77_3	2	diff, calculateAddQuoteTokenLiquidityQuantities, calculateAddBaseTokenLiquidityQuantities, etc.	Underflow/Overflow	Solidity's uint256 variables can underflow or overflow, which can lead to unexpected results. For instance, the `diff` function can underflow if `b > a`. Likewise, the `calculateAddQuoteTokenLiquidityQuantities` and `calculateAddBaseTokenLiquidityQuantities` functions have several places where an overflow could occur. Consider using the SafeMath library, or Solidity's built-in overflow/underflow checks if you're using a version that includes them.
77_3	3	calculateAddLiquidityQuantities, calculateAddTokenPairLiquidityQuantities, etc.	Insufficient validation	There are many places in this code where inputs are used without sufficient validation. For example, in `calculateAddLiquidityQuantities` and `calculateAddTokenPairLiquidityQuantities`, various input parameters are used without checks. This can lead to unexpected behavior or even potential security issues.
77_3	4	sqrt	Denial of Service (DoS)	The `sqrt` function is a while loop that depends on the input value, and if the input is large enough, it may consume a lot of gas and block other transactions.
71_3	null
102_1	null
97_1	null
92_1	1	less	Arithmetic Underflow	In the less function, there is unchecked subtraction of `feiAmount` from `getTotalFeiBoostedForVault[vault]` and `totalFeiBoosted`. This may lead to an arithmetic underflow if `feiAmount` is greater than `getTotalFeiBoostedForVault[vault]` or `totalFeiBoosted`. This is a potential security vulnerability that can be exploited.
92_1	2	boost	Missing Input Validation	In the boost function, `feiAmount` is passed to `feiTurboCToken.borrow` and `vault.deposit` without any validation. If the input is not as expected (e.g., extremely large values), it could potentially lead to unexpected contract behavior or reentrancy attacks.
92_1	3	boost, less, gib	Potential Reentrancy Attack	Functions like `boost`, `less`, and `gib` are marked as `nonReentrant`, which is good. However, they also call external contracts (e.g., `vault.deposit` in `boost`), which is a potential reentrancy attack vector if the external contracts are malicious. Although `nonReentrant` should protect against this, it's better to minimize trust in external contracts.
92_1	4	boost	Incorrect Order of Operations	In the boost function, `vault.deposit` is called after `feiTurboCToken.borrow`. If the borrowing fails, the tokens are still deposited into the vault which may not be the desired behavior. The order should be switched or checks should be implemented to ensure the borrowing was successful before proceeding.
92_1	5	slurp	Incorrect Calculation	In the slurp function, `safeInterestAmount` is calculated as `interestEarned - protocolFeeAmount`. However, it seems like the contract is not considering the potential cases where `protocolFeeAmount` could be larger than `interestEarned`. This could lead to an underflow error.
83_1	1	deposit	Incorrect calculations, Unexpected values	Integer overflow and underflow bugs can occur when the value computed to store in an integer is outside the range of the type. Solidity doesn't handle such cases automatically, it can lead to unexpected behavior. This could occur in the functions deposit and withdraw where arithmetic operations are performed without checks for overflows or underflows. Moreover, when the multiplication operation is performed before the division operation, it could also cause a rounding error. It is recommended to use SafeMath functions for arithmetic operations to avoid such issues.
79_1	1	depositAVAX	Arithmetic Overflow/Underflow	In the function `depositAVAX`, the `newAllocation` is calculated without checking for potential overflow. This could be maliciously exploited by a bad actor who could supply a huge amount of AVAX to cause an overflow. If this were to happen, the `newAllocation` variable would roll over, and the attacker could potentially receive more tokens than they should. It is a best practice to use SafeMath for such calculations to avoid overflow and underflow errors.
79_1	2	withdrawAVAX	Arithmetic Overflow/Underflow	In the function `withdrawAVAX`, `feeAmount` is calculated without checking for potential overflow. If `_amount` is very large, the multiplication with `getPenalty()` could overflow. It is a best practice to use SafeMath for such calculations to avoid overflow and underflow errors.
79_1	3	emergencyWithdraw	Potential Re-entrancy	In the function `emergencyWithdraw`, there is a potential re-entrancy bug as the state `user.balance` is updated after the external call `_safeTransferAVAX(msg.sender, balance)`. If the contract calling this function has a fallback function that calls back into this contract, it can call the function again before the state `user.balance` is updated. This can lead to an unexpected behavior where the user can withdraw more than they should be able to. To avoid re-entrancy bugs, you should follow the checks-effects-interactions pattern, which means you should make any external calls after you've done all the internal work necessary for the function.
79_1	4	withdrawLiquidity	Potential Re-entrancy	Similar to the `emergencyWithdraw` function, the `withdrawLiquidity` function also updates the state `user.hasWithdrawnPair` after the external call `pair.transfer(msg.sender, balance)`, which can lead to a re-entrancy vulnerability. It is advisable to follow the checks-effects-interactions pattern to prevent such vulnerabilities.
78_1	1	redeemRate, mint, redeem	Rounding Errors**	Solidity doesn't natively support decimal numbers, which means that when division is performed, it can lead to rounding errors. This can create accounting errors or imprecision.
78_1	2	mint, redeem	Potential Re-Entrancy Attacks**	The 'mint' and 'redeem' functions perform a state-changing operation after an external call which can potentially open the contract to re-entrancy attacks.
78_1	3	redeem	Insufficient Balance Check**	In the 'redeem' function, there's no explicit check that the contract has sufficient base tokens to transfer. If the contract doesn't have enough tokens, the 'transfer' function will fail and revert all changes. It would be better to include an explicit check.
77_1	null
71_1	1	unlock	Missing input validation	The unlock function doesn't check if the insurance with the provided ID (_id) exists before accessing its properties. This can lead to unexpected behavior if an insurance with the provided ID does not exist.
71_1	2	withdraw	Integer underflow	The operation `withdrawalReq[msg.sender].amount -= _amount;` can potentially underflow if `_amount` is greater than `withdrawalReq[msg.sender].amount`. This can lead to the user's withdrawal request amount becoming a very large number.
71_1	3	_depositFrom	Unhandled exception	The function `_depositFrom` calls the function `vault.addValue`, but doesn't handle any potential reverts or exceptions that could be thrown from this function. This could cause a transaction to fail unexpectedly.
71_1	4	redeem	Reentrancy attack	The redeem function updates the state of the contract after making an external call to `vault.borrowValue`. This could potentially allow for a reentrancy attack, where the called contract calls back into the redeem function before the initial call has finished.
71_1	5	unlock	Incorrect comparison	The line `insurances[_id].status == false;` seems to be a typo. It should probably be `insurances[_id].status = false;` since the current line is comparing the status to false but not actually changing it.
61_3	null
61_3	null
61_3	null
61_3	null
60_3	1	Multiple	Safety checks and Events missing	The contract lacks safety checks (like require or assert) and events, which are considered good practices in Solidity contracts.
70_1	1	_updateVaderPrice	Arithmetic Underflow	In the function `_updateVaderPrice`, you are performing subtraction without checking for underflows (nativeTokenPriceCumulative - pairData.nativeTokenPriceCumulative) / timeElapsed. An unchecked underflow could lead to unexpected behavior.
70_1	2	_updateUSDVPrice	Arithmetic Underflow	Similarly, in the function `_updateUSDVPrice`, subtraction without checking for underflows is performed (nativeTokenPriceCumulative - pairData.nativeTokenPriceCumulative) / timeElapsed.
70_1	3	getVaderPrice, getUSDVPrice	Potential Reentrancy	Both functions call syncVaderPrice() and syncUSDVPrice() which change the state of the contract and then return values based on the state. If the state-changing function is called by an external contract, it could potentially lead to a reentrancy attack. Although this might not be a direct issue in your case, it's generally safer to avoid state changes after external calls.
70_1	4	_calculateVaderPrice, _calculateUSDVPrice	Floating Point Precision	Both functions perform division and multiplication with decimal numbers. Solidity doesn't natively support floating-point numbers, so the operations may lead to precision errors.
70_1	5	_addVaderPair, _addUSDVPair	Use of `block.timestamp`	The use of `block.timestamp` can be manipulated by miners to a certain degree. Depending on how critical the timing is in your contract, this could be a potential problem.
70_1	6	Various	Unchecked External Call	There are various instances where the contract makes external calls to oracles and other contracts. If these external calls fail, the contract might behave unexpectedly. It's always good practice to check the success of external calls.
70_1	7	_addVaderPair, _addUSDVPair	Lack of input validation	These functions do not validate if the provided pair or foreignAsset address is a valid contract address.
70_1	1	grant	Incorrect calculation order	In the function 'grant', the calculation of the amount to grant is done using integer division before multiplication, this can lead to loss of precision due to truncation. Specifically, `(reserve() * _MAX_GRANT_BASIS_POINTS) / _MAX_BASIS_POINTS` should be rewritten to `(reserve() / _MAX_BASIS_POINTS) * _MAX_GRANT_BASIS_POINTS` to ensure no precision is lost.
70_1	2	reimburseImpermanentLoss	Overflow risk	In the 'reimburseImpermanentLoss' function, there is a risk of overflow in the calculation `amount = amount * vaderPrice;`. Solidity does not handle integer overflows or underflows, so it's important to include checks that prevent these operations from occurring.
70_1	3	reimburseImpermanentLoss	Unexpected value	The function 'reimburseImpermanentLoss' assumes that the value of `lbt.previousPrices(uint256(ILiquidityBasedTWAP.Paths.USDV))` is non-zero. However, if this value is 0, it could result in an unexpected value for the calculation `amount = amount / usdvPrice;` because `usdvPrice` is undefined in this case. The function should include a check to ensure that this value is non-zero before performing the division.
70_1	1	mint, burn	Incorrect calculation order	In both the `mint` and `burn` functions, the calculation of `uAmount` and `vAmount` respectively is done using integer multiplication before division. This could lead to an overflow error. The calculation should be rearranged to prevent this, i.e., `(vPrice * vAmount) / 1e18` should be rewritten as `(vPrice / 1e18) * vAmount`.
70_1	2	mint, burn	Division by zero	In both the `mint` and `burn` functions, there are no checks to see if the returned `vPrice` and `uPrice` from the `lbt.getVaderPrice()` and `lbt.getUSDVPrice()` calls are zero before proceeding to use them in a division operation. This can potentially lead to a division by zero error if the values are indeed zero.
70_1	3	mint	Overflow risk	In the `mint` function, the calculation `cycleMints += uAmount;` could potentially lead to an overflow error. Solidity does not handle integer overflows or underflows, so it's important to include checks that prevent these operations from occurring.
66_1	1	_buyBack	Re-entrancy bug	This function includes an external call to `IsYETIRouter(_routerAddress).swap(_YUSDToSell, _YETIOutMin, address(this));` before the state variable `lastBuybackTime` is updated. This could potentially expose the contract to a re-entrancy attack where the `swap` function could call back into `publicBuyBack` before `lastBuybackTime` is updated.
66_1	2	mint	Function access control	The `mint` function is public and lacks any access control, allowing any address to call it and potentially manipulate the total supply of tokens. This could potentially lead to an inflation attack.
66_1	3	_burn	Division by zero	In the `_burn` function, there is a division calculation `uint256 amount = (shares * effectiveYetiTokenBalance) / totalSupply;`. If `totalSupply` is zero, this would cause a division by zero error.
66_1	4	publicBuyBack	Incorrect use of SafeMath library	In the `publicBuyBack` function, there is a division calculation `uint256 YUSDToSell = div(YUSDBalance.mul(5), 100);`. However, this could be done more safely and efficiently with Solidity's SafeMath library, as `uint256 YUSDToSell = YUSDBalance.mul(5).div(100);`.
66_1	5	_burn	Potential Underflow	In the `_burn` function, `users[from].balance = user.balance.sub(shares.to128());` might lead to underflow if the `shares` is greater than `user.balance`. The use of the `sub` function from the SafeMath library would throw an error if an underflow occurred, but there are no checks or error messages to make this clear to users.
61_1	null
61_1	null
61_1	null
61_1	1	emergencyWithdraw, lockTokens, unlockTokens, unlockShares	Reentrancy attack	Even though you're using the `nonReentrant` modifier from the `ReentrancyGuard` contract to protect against reentrancy attacks, it's important to be aware of this type of bug. This modifier prevents nested calls back into the contract until the function has finished executing, which can protect against reentrancy vulnerabilities. However, if the `ReentrancyGuard` contract were misused or omitted in a future update, this could become an issue.
61_1	2	updateProtocolAddresses	Missing input validation	The function `updateProtocolAddresses` is used to update liquidity token for an asset. However, there is no validation to check whether the given `_asset` or `_liquidityToken` address is a valid contract address or not. Passing an incorrect or malicious contract address can lead to unexpected results.
61_1	3	_updateSavingsAccount	Lack of event emission	There is an event `SavingsAccountUpdated` emitted in the `_updateSavingsAccount` function, however, you didn't declare this event in the contract. If this event is used for tracking changes, you should declare it.
61_1	4	getSharesForTokens	Potential loss of precision	The function `getSharesForTokens` is used to calculate the number of shares for a given amount of tokens. However, the calculation involves division operation, which might lead to precision loss. You might want to consider implementing a rounding mechanism.
60_1	1	settleAccount	Incorrect Order of Calculations	In the `settleAccount` function, the `shortfall` is first calculated based on the `newBalance` and then added to `self.shortfall`. However, then `newBalance` is set to zero if it was negative, and `self.balances[account]` is updated with `newBalance.abs()`. This could lead to an incorrect value in `self.balances[account]` if `newBalance` was negative. Then, `self.shortfall` is updated again with `shortfall`. This may lead to `self.shortfall` being larger than it should be, as `shortfall` was calculated based on the old `newBalance`. The order of calculations should be reconsidered to avoid this potential bug.
52_3	1	calculateSwap	Division by Zero	This function assumes that `reserveIn` + `amountIn` will never be zero when it performs division operation. If both `reserveIn` and `amountIn` are zero, it will cause a division by zero error.
52_3	2	calculateSwapReverse	Division by Zero	This function assumes `amountOut * 2` is not zero when it performs the division operation. If `amountOut` is zero, it will cause a division by zero error.
52_3	3	calculateSwap, calculateSwapReverse	Integer Overflow/Underflow	Both these functions perform multiplication operations that could potentially result in integer overflow if the operands are very large. For example, `amountIn * reserveIn * reserveOut` in calculateSwap and `reserveIn * reserveOut` in calculateSwapReverse. Solidity 0.8.0 onwards automatically checks for these underflows and overflows, but this could still be a concern if the contract is meant to be used with older versions of Solidity.
52_3	4	calculateLoss	Integer Overflow/Underflow	This function calculates `originalValue` and `releasedValue` by performing multiplication and division without checking for overflow or division by zero. If `releasedAsset` is zero, division by zero will occur.
52_3	5	calculateSlipAdjustment	Division by Zero	The function assumes `(vaderDeposited + vaderBalance) * (assetDeposited + assetBalance)` will never be zero. If all input variables are zero, this will cause a division by zero error.
52_3	6	root	Unhandled edge case	This function calculates the square root of a number using the Babylonian method. However, if the input is 2 or 3, it will return 1 which is not the correct square root. This could potentially lead to incorrect calculations in other functions that use the root function.
52_3	7	calculateLiquidityUnits	Incorrect calculation order	The function performs multiplication before division which can lead to loss of precision due to integer division. The operation `totalPoolUnits * poolUnitFactor` should be performed after the division by `denominator` to minimize precision loss.
52_3	1	addLiquidity	Recursion Error	The `addLiquidity` function appears twice, with identical parameters. This could potentially lead to a stack overflow error if the function recursively calls itself indefinitely. This could be a copy-paste mistake, or possibly an attempt at function overloading gone wrong. You should correct this to avoid potential issues.
52_3	2	removeLiquidity	Uninitialized Contract	In the `removeLiquidity` function, the `reserve.reimburseImpermanentLoss` function is called, but the `reserve` variable is not initialized in the constructor and can only be initialized via the `initialize` function. If `removeLiquidity` is called before `initialize`, this will lead to a function call on a zero-address contract, causing a failure.
52_3	3	addLiquidity, _addLiquidity	Missing Input Validation	The functions `addLiquidity` and `_addLiquidity` do not validate if `tokenA` and `tokenB` are the same. If they are the same, this could lead to unexpected behavior.
52_3	4	_swap	Missing Return Values for Failure Cases	In the `_swap` function, if `path.length` is not equal to 2 or 3, there is no return statement. This could lead to unexpected return value issues if `_swap` is called with an invalid `path`.
52_3	5	initialize	Missing Error Message	In the `initialize` function, the `require` statement doesn't include an error message. While this is not a bug per se, it is good practice to include an error message to make debugging easier if the condition fails.
52_3	1	doubleSwap	Reentrancy Attack	Even though the contract uses the ReentrancyGuard, there is a potential reentrancy attack in the doubleSwap function. The function calls the foreignAssetB.safeTransfer(to, foreignAmountOut) at the end of the function, but the state variables are updated before this. If the "to" address is a malicious contract, it can call back into doubleSwap before the transfer function finishes executing. This attack could potentially manipulate the state variables or drain the contract funds.
52_3	2	constructor, mint, burn, doubleSwap, swap, rescue	Lack of Input Validation	The contract doesn't seem to validate the input parameters in many of its functions. For instance, the constructor function doesn't verify if _nativeAsset is a valid address or not. Similarly, in the mint, burn, doubleSwap, swap, and rescue functions, there's no validation for the parameters received. This could potentially lead to unexpected behavior.
52_3	3	_burn, _update	Integer Underflow	The _burn function calculates amountNative and amountForeign by multiplying liquidity with reserves and dividing by _totalSupply. If _totalSupply is larger than the product of liquidity and reserves, this will underflow and become a very large number. Also, in the _update function, balanceNative and balanceForeign are subtracted from without any checks. If the subtracted amount is larger, it will underflow and become a very large number.
52_3	null
52_3	null
59_1	1	getRealBurnBudget	Potential Underflow	In the 'getRealBurnBudget' function, 'usableExcess' is calculated by subtracting 'premiumExcess' from 'maxBurnSpend'. If 'premiumExcess' is greater than 'maxBurnSpend', it will result in an underflow. Although the contract uses SafeMath, it is still important to handle these cases to prevent unexpected behavior.
59_1	2	getPegDeltaFrequency	Potential Division by Zero	In the 'getPegDeltaFrequency' function, the variable 'total' is divided by 'auctionAverageLookback'. If 'auctionAverageLookback' is set to 0, this will cause a division by zero error. Although there's a require statement in 'setAuctionAverageLookback' that prevents setting this variable to zero, it's still important to handle such cases to prevent unexpected behavior.
59_1	3	getAverageParticipation, getPegDeltaFrequency	Unbounded Loops	In 'getAverageParticipation' and 'getPegDeltaFrequency' functions, there are loops that iterate through auctions or observations. These loops are potentially unbounded as the number of auctions or observations increases, leading to possible high gas costs or out-of-gas errors.
59_1	4	initialize	Missing input validation	In the 'initialize' function, there is no validation of the input addresses for '_timelock', 'initialAdmin', '_stabilizerNode', and '_auction'. It's possible to input the zero address (0x0) for these parameters, which would likely cause unintended behavior in the contract. It's generally a good practice to add require statements to validate that these addresses are not the zero address.
59_1	5	_getIndexOfObservation	Improper use of 'public' visibility	The '_getIndexOfObservation' function is marked as 'internal', which means it can only be called from within this contract or contracts deriving from it. However, it's used in public view functions, which means external callers can effectively call this function by calling these public functions. If this function isn't intended to be usable by external callers, it would be a good idea to reassess the design of this contract to avoid exposing this functionality.
59_1	1	`_calculateMaltRequiredForExit`	Over/Underflow Error	This function is using division and multiplication operations which could lead to overflow/underflow errors. Solidity does not throw an error when a number is divided by zero, it will instead return zero. Also, multiplication operations could overflow if the operands are too large. To prevent these potential overflows/underflows, consider using SafeMath for these operations. Specifically, you should consider using SafeMath for the following operations:
59_1	2	`exitEarly`	Incorrect Order of Calculations	This function is not checking if the `amountOut` is greater than `minOut` before updating the `auctionExits`. In case the `amountOut` is less than `minOut`, the function will revert but not before updating the `auctionExits`. To correct this, the `require(amountOut > minOut, "EarlyExit: Insufficient output");` statement should be moved up before the `auctionExits` are updated.
59_1	3	`_calculateMaltRequiredForExit`	Use of incorrect variables	In this function, the calculation of `amount` is based on the `userCommitment` and `userRedeemed`. However, these values are not updated in the function. If `amount` is greater than `userCommitment - userRedeemed`, `amount` is set to `userCommitment - userRedeemed`. This may not be the desired behavior as it could lead to an erroneous calculation of `amount`. Consider updating `userCommitment` and `userRedeemed` before calculating `amount`.
59_1	4	`earlyExitReturn`	Incorrect Calculation	In the function `earlyExitReturn`, the calculation for `maxProfit` is done with the formula `(fullReturn - amount) * (maxEarlyExitBps * progressionBps / 10000) / 1000`. The multiplication and division operations are not in parentheses which could lead to incorrect calculation due to operator precedence. You should consider using parentheses to ensure the correct order of operations. The correct expression should be `((fullReturn - amount) * (maxEarlyExitBps * progressionBps)) / (10000 * 1000)`.
58_1	null
56_1	null
52_1	1	calculateLoss	Incorrect Order of Calculations/Rounding Error	In the function calculateLoss, you have two instances of an operation of the form `(A * B) / C`. Due to the nature of integer division in Solidity, this might not yield the expected results. Specifically, if `(A * B) < C`, the result of the operation will be `0`. The correct order of operations to ensure the right precedence and to avoid the rounding down to 0 before the multiplication should be: `(A * B) / C` should be changed to `A * (B / C)`, given that `B / C` would not result in a fraction.
52_1	1	addLiquidity	Function Overloading Error	There are two functions named `addLiquidity` with the same parameters which could cause confusion and unexpected behavior. The first `addLiquidity` function calls the second `addLiquidity` function with the exact same arguments it received, leading to a recursive call without a base case. This can cause a stack overflow error (out of gas exception).
52_1	2	_addLiquidity	Incomplete Code/Logic Error	The `_addLiquidity` function doesn't account for the scenario when a pool already exists for the provided token pair. In this case, it should determine the amountA and amountB based on the existing pool's reserves and the desired amounts. Currently, it just sets amountA and amountB equal to the desired amounts without considering the existing state of the pool.
52_1	3	initialize	Ownership Renouncement	The `initialize` function renounces the contract's ownership after setting the reserve. This means that no further changes can be made that require owner permissions, such as updating the reserve address. It's important to consider whether this is the desired behavior.
52_1	4	removeLiquidity	Missing Input Validation	The `removeLiquidity` function doesn't validate if the provided tokens (tokenA and tokenB) have a corresponding pool in the factory. This can lead to unexpected behavior or errors if a pool doesn't exist for the provided tokens.
52_1	5	_swap	Missing Return Values	The `_swap` function doesn't return a value in all paths. In the case when path length is 2 and the second token in the path isn't the native asset, there's no return statement. This can lead to unexpected behavior or errors.
52_1	null
52_1	1	burnSynth	Arithmetic Overflow and Underflow	In the function `burnSynth`, there is a subtraction of two uint values, `reserveNative - amountNative`. This could potentially lead to an underflow error if `amountNative` is greater than `reserveNative`. Using SafeMath library or Solidity 0.8.0 or newer for these operations would prevent this issue.
52_1	2	_update	Arithmetic Overflow and Underflow	In the function `_update` (which is not in the provided code but it's called multiple times), there could be potential arithmetic overflows or underflows, depending on the implementation of the function. It's highly recommended to use SafeMath library or Solidity 0.8.0 or newer for these operations.
52_1	1	`vaderToUsdv`	Incorrect order of calculations	If `_usdvEnabled` is `false`, `vaderAmount` is directly multiplied with the return value from `consult(VADER)`. However, considering the difference in decimal places between VADER and the native token, this calculation might need to be adjusted. The return value from `consult(VADER)` should probably be multiplied by `vaderAmount` and then divided by `10**decimals` to account for the decimal difference.
52_1	2	`consult`	Unexpected values	The calculation `uint256(price) * (10**10)` assumes that the Chainlink price feed returns a price with 8 decimal places. This might not be the case for all price feeds. You should confirm the number of decimal places for the specific Chainlink price feed you're using.
52_1	3	`registerPair`	Incorrect variable	When `token0` is not `VADER`, the pair address is set to the `_vaderPool` address. However, the `_vaderPool` is not necessarily the correct pair for `token0` and `token1`. This may lead to incorrect reserves and prices being used for this pair.
47_3	1	transferFrom	Underflow Error	The function "transferFrom" is susceptible to an underflow error when the allowance is less than the amount to transfer. This can occur due to the use of the Solidity's "sub" function without a proper check before that to ensure the allowance is greater than or equal to the amount.
47_3	2	updatePricePerShare	Timestamp Manipulation	The function "updatePricePerShare" is using the "now" keyword for the timestamp. This can be manipulated by miners in Ethereum and is not a reliable source of time.
47_3	3	mint, burn	Lack of event after state-changing action	After changing the contract's state in the "mint" and "burn" functions, there is no event emitted. This can make it harder to track contract interactions and state changes.
47_3	4	burn	Reentrancy Attack	The function "burn" is susceptible to a reentrancy attack. The external call to the ibbtc token's transfer function is made before the state (_burn) is updated. This can potentially allow for recursive calls back into the contract before its state is settled.
47_3	5	balanceToShares, sharesToBalance	Overflows Error	The functions "balanceToShares" and "sharesToBalance" have potential overflow issues due to multiplication with 1e18. If the input values are too large, the multiplication can cause an overflow.
47_3	6	transfer, transferFrom	Missing Input Validation	In the "transfer" and "transferFrom" functions, there is no check to ensure that the "recipient" address is not the zero address. This can lead to accidental loss of tokens.
47_3	1	transferFrom	Underflow Error	The function "transferFrom" is susceptible to an underflow error when the allowance is less than the amount to transfer. This can occur due to the use of the Solidity's "sub" function without a proper check before that to ensure the allowance is greater than or equal to the amount.
47_3	2	burn	Reentrancy Attack	The function "burn" is susceptible to a reentrancy attack. The external call to the ibbtc token's transfer function is made before the state (_burn) is updated. This can potentially allow for recursive calls back into the contract before its state is settled.
47_3	3	mint, burn	Lack of event after state-changing action	After changing the contract's state in the "mint" and "burn" functions, there is no event emitted. This can make it harder to track contract interactions and state changes.
47_3	4	balanceToShares, sharesToBalance	Overflows Error	The functions "balanceToShares" and "sharesToBalance" have potential overflow issues due to multiplication with 1e18. If the input values are too large, the multiplication can cause an overflow.
47_3	5	transfer, transferFrom	Missing Input Validation	In the "transfer" and "transferFrom" functions, there is no check to ensure that the "recipient" address is not the zero address. This can lead to accidental loss of tokens.
47_3	6	pricePerShare, balanceToShares, sharesToBalance	Oracle Manipulation	The contract relies on an external oracle for the price per share. This could be manipulated by a malicious oracle or if the oracle contract is compromised. The functions "pricePerShare", "balanceToShares", and "sharesToBalance" are potentially affected.
49_3	1	computeDepth	Arithmetic Precision Loss	In the `computeDepth` function, there is a risk of precision loss when dividing `_marketLiquidity * 1e18` by `_ovlPrice`. Solidity performs integer division, where the fractional part is discarded. This could result in a lower than expected `depth_` value, especially if `_ovlPrice` is significantly larger than `_marketLiquidity`.
49_3	2	_tickToPrice	Arithmetic Overflow	In the `_tickToPrice` function, if `sqrtRatioX96` is larger than `type(uint128).max`, there is a risk of arithmetic overflow when performing `sqrtRatioX96 * sqrtRatioX96`. Also, the use of `1 << 192` or `1 << 128` might not be safe in the event of large `baseAmount` values.
49_3	3	fetchPricePoint	Potential Revert due to Casting	In the `fetchPricePoint` function, casting a `uint32` to `int32` and then again to `int56` might cause the function to revert if the original `uint32` value is larger than the maximum value an `int32` can hold.
49_3	4	fetchPricePoint	Potential Revert due to Integer Underflow	In the `fetchPricePoint` function, there's an operation ` _liqs[0] - _liqs[1]` which can potentially underflow if `_liqs[1]` is larger than `_liqs[0]`.
49_1	null
47_1	1	transferFrom, transfer	Erroneous Accounting	The functions `transferFrom` and `transfer` use a function called `balanceToShares` to convert the `amount` into `amountInShares`. This function uses the `pricePerShare` from an oracle, which could lead to erroneous accounting if the oracle provides incorrect or manipulated data.
47_1	2	balanceOf, totalSupply	Erroneous Accounting	The functions `balanceOf` and `totalSupply` also use the `pricePerShare` from an oracle to calculate the balance or total supply. Again, this could lead to erroneous accounting if the oracle provides incorrect or manipulated data.
47_1	3	mint, burn	Incorrect Order of Calculations	In the `mint` and `burn` functions, the transfer of tokens and the minting or burning of shares are not atomic, meaning they are not executed in one transaction. If the transaction fails halfway, it could lead to an inconsistent state of the contract.
47_1	4	mint, burn	Absence of input validation	The `mint` and `burn` functions do not validate the `_shares` input parameter. If `_shares` is zero or a very large number, it could lead to unexpected results.
47_1	5	mint, burn	Absence of Re-entrancy guard	The `mint` and `burn` functions call the external `transferFrom` and `transfer` methods of the `ibbtc` contract, but they don't have a re-entrancy guard to prevent potential re-entrancy attacks.
47_1	1	transferFrom, transfer	Erroneous Accounting	The functions `transferFrom` and `transfer` use a function called `balanceToShares` to convert the `amount` into `amountInShares`. This function uses the `pricePerShare` variable, which could lead to erroneous accounting if the `pricePerShare` is not updated frequently or correctly.
47_1	2	balanceOf, totalSupply	Erroneous Accounting	The functions `balanceOf` and `totalSupply` also use the `pricePerShare` to calculate the balance or total supply. Again, this could lead to erroneous accounting if the `pricePerShare` is not updated frequently or correctly.
47_1	3	mint, burn	Incorrect Order of Calculations	In the `mint` and `burn` functions, the transfer of tokens and the minting or burning of shares are not atomic, meaning they are not executed in one transaction. If the transaction fails halfway, it could lead to an inconsistent state of the contract.
47_1	4	mint, burn	Absence of input validation	The `mint` and `burn` functions do not validate the `_shares` input parameter. If `_shares` is zero or a very large number, it could lead to unexpected results.
47_1	5	mint, burn	Absence of Re-entrancy guard	The `mint` and `burn` functions call the external `transferFrom` and `transfer` methods of the `ibbtc` contract, but they don't have a re-entrancy guard to prevent potential re-entrancy attacks.
47_1	6	updatePricePerShare	Possible Stale Data	The `updatePricePerShare` function is permissionless, and anyone can call it to update the `pricePerShare`. However, the contract does not enforce the frequency of updates, which could lead to stale data if not updated regularly.
34_3	null
31_3	1	harvest	Use of incorrect variables	The `harvest` function processes rewards, but the method `_processRewardsFees` receives `earnedReward` as a parameter which is the balance of the `reward` token after getting rewards from the `LOCKER`. The function `_processRewardsFees` processes the fee on this amount and sends the fees to the governance and the strategist. But, the reward is not converted to `want` token before processing fees. The fees should be processed on the `want` token instead of the `reward` token.
31_3	2	_withdrawSome	Incorrect order of calculations	The `_withdrawSome` function requires that the amount to withdraw is not more than 99.8% of the current balance (`max >= _amount.mul(9_980).div(MAX_BPS)`). This can result in a miscalculation in cases where the `_amount` is very high, and `max` is low. This is because multiplying `_amount` by `9_980` can overflow if `_amount` is very large. This could be prevented by first dividing `_amount` by `MAX_BPS` and then multiplying the result by `9_980`.
31_3	3	manualRebalance	Unexpected values	In the `manualRebalance` function, `toLock` is passed as a parameter, which is then directly used to calculate `newLockRatio`. The contract has a `MAX_BPS` constant which is `10_000`, and `toLock` is required to be less than or equal to `MAX_BPS`. But, it is not checked whether `toLock` is a valid value within the required range (0 to `MAX_BPS`). This could potentially lead to unexpected behavior if `toLock` is a negative value or an excessively large value.
30_3	1	deposit	Potential overflow	The `_normalizeDecimals` function can potentially cause an overflow if the token has a decimal less than 18 and the `_amount` is very large.
30_3	2	deposit	Insufficient balance check	The `_amount` to be deposited is not checked against the balance of the depositor, which might lead to failed transactions and lost gas fees.
30_3	3	withdraw	Insufficient withdrawal amount check	The withdrawal amount after subtracting the fee is not checked if it's still positive. In case of very high fees, the actual withdrawal amount might be very small or even negative.
30_3	1	setCap	Incorrect Order of Calculations 	The function setCap first sets the new cap for the strategy, then withdraws the amount in excess of the new cap. However, it doesn't take into account the possibility that the withdrawal operation might fail, which would result in an incorrect cap being set. Ideally, it should perform the withdrawal first, then set the new cap only if the withdrawal was successful.
30_3	2	removeStrategy	Unexpected Values	The function removeStrategy removes a strategy from a vault, and it uses the 'sub' function from the SafeMath library to adjust array indexes. However, it does not account for the scenario where the 'index' variable might be zero. If 'index' is zero, 'sub(1)' would underflow and produce an unexpected value. This could result in an incorrect array index being accessed, leading to potential errors or exploits.
30_3	3	withdraw	Deviating Semantics	In the withdraw function, the 'safeTransfer' method is used to transfer tokens from the contract to the caller. However, the amount to be transferred is calculated after the withdrawal operations have been performed. This could lead to a situation where the actual balance of the contract is less than the calculated withdrawal amount, resulting in a failed transfer. This is inconsistent with the typical expectation that a withdrawal should only be possible if there are enough funds in the contract.
45_1	1	getLockedAmount	Unexpected Value	In the getLockedAmount function, when 'isIncrease' is set to false, the 'newLockedAmount' is being set to 'array[i].lockedAmount - 1' if 'array[i].lockedAmount' is greater than 'amount'. This might lead to unexpected values of 'newLockedAmount' as it decreases the 'lockedAmount' by 1 instead of 'amount'. It seems like a potential mistake in the code logic as it deviates from the expected behavior of reducing the 'lockedAmount' by 'amount'.
45_1	2	_findMedian	Incorrect Order of Calculations	In the _findMedian function, the median is calculated as an average of two middle numbers when the array length is even. This could lead to incorrect results if those two numbers are large enough that their sum exceeds the maximum value of uint256 (2^256 - 1). A better way to avoid overflow would be to calculate the average by adding half of each number: `(num1 / 2) + (num2 / 2)` and add 1 if num1 and num2 are both odd to account for the division truncation.
44_1	1	constructor	Missing input validation	In the constructor, the inputs `feeRecipient_` and `swapFee_` are not validated. There should be checks to ensure that `feeRecipient_` is not the zero address and `swapFee_` is within a reasonable range (e.g., less than `SWAP_FEE_DIVISOR`).
44_1	2	sweepFees	Reentrancy attack	The `sweepFees` function could potentially suffer from a reentrancy attack when transferring ETH to the `feeRecipient`. This function should ideally be marked with the `nonReentrant` modifier to prevent reentrancy attacks. Note that while the `nonReentrant` modifier is present, it's not utilized here.
44_1	3	fallback, receive	Fallback function misuse	The contract has fallback and receive functions that are payable but don't perform any actions. This could potentially lead to accidental loss of funds if Ether is sent to the contract unintentionally.
42_1	null
39_1	1	initiateVaultFillingZcTokenInitiate, initiateZcTokenFillingVaultInitiate, initiateZcTokenFillingZcTokenExit, initiateVaultFillingVaultExit, exitZcTokenFillingZcTokenInitiate, exitVaultFillingVaultInitiate, exitVaultFillingZcTokenExit, exitZcTokenFillingVaultExit	Incorrect Order of Calculations	In these functions, the filled volume of the order is being updated before any of the token transfers and minting operations have been confirmed to have succeeded. It's recommended that state variables like `filled[hash]` be updated only after all external function calls (like `transferFrom`, `mint`, etc.) have been successfully completed to avoid reentrancy attacks.
39_1	2	setFee	Use of Incorrect Variables	The function `setFee` is using a parameter `t` as an index to update the `fenominator` array. However, there is no validation to ensure `t` is a valid index for the array. This could result in an out-of-gas error if `t` exceeds the length of the `fenominator` array.
39_1	3	redeemZcToken	Incorrect Order of Calculations	The function `redeemZcToken` calls `mPlace.redeemZcToken` before calling `CErc20(mPlace.cTokenAddress(u, m)).redeemUnderlying(redeemed)`. The order of these calls could potentially cause issues if the first call modifies the state in a way that affects the second call.
39_1	4	splitUnderlying, combineTokens	Cases with Unexpected Values	In the functions `splitUnderlying` and `combineTokens`, there is no check to ensure that the `a` parameter is greater than 0. If a user were to call these functions with `a` as 0, the function calls to transfer and mint/redeem tokens could succeed, but it would result in unnecessary gas costs and could potentially lead to other issues.
39_1	5	All Functions	Missing Checks for External Calls	All function calls to external contracts (including ERC20 transfers, mints, redeems, etc.) should be checked for their return value or use the 'Safe' version of these functions to ensure they succeeded. If these calls fail silently, it could result in lost funds or other unexpected behavior.
34_1	null
31_1	null
30_1	1	setGauge	Zero Address Check	The function `setGauge` is not checking if the provided address is a zero address. A zero address can be set as gauge which could potentially lock funds forever if ever interacted with.
30_1	2	swap	Oracle Manipulation / Front Running	The function `swap` makes use of an expected amount parameter. If an oracle is used for this expected amount, and the oracle is not decentralized or is manipulatable, it could lead to loss of funds. Also, there is a possibility of front-running attacks where someone could see the transaction in the mempool and interact with the `swap` function before the transaction gets mined.
30_1	3	withdraw	Re-entrancy	The `withdraw` function is at risk of re-entrancy attacks. It is calling an external contract (through the `_controller.withdraw` function) before the state (the user balance) is updated which could lead to re-entrancy attacks.
30_1	null
29_3	1	`mint`, `burn`, `burnSingle`, `swap`, `flashSwap`	Reentrancy Bug**	The lock modifier used in these functions is meant to prevent reentrancy attacks, but it can potentially be bypassed. The `unlocked` variable is initially set to `1` and is changed to `2` at the start of the function execution. However, there's no guarantee that it will always be `1` before the function is called. An attacker can potentially manipulate the state of the contract to make `unlocked == 2` which can then bypass the reentrancy guard and allow for reentrancy attacks.
29_3	2	`_mul`, `_div`	Integer Overflow and Underflow**	Solidity does not handle overflows and underflows automatically. This might lead to unexpected behavior if not handled correctly. Consider using SafeMath or Solidity 0.8.0 or later to handle these operations.
29_3	3	`_transfer`	Call to external contract**	The `bento.call` in the `_transfer` function is a call to an external contract. This is risky because the external contract could be compromised, or it could be coded to perform actions that you don't expect.
29_3	null
29_3	1	mint, burn, burnSingle, swap, flashSwap	Reentrancy	The functions mint, burn, burnSingle, swap, flashSwap contain a potential reentrancy bug. These functions are marked with the modifier 'lock' which uses a flag (unlocked) to prevent reentrancy. However, this flag is set back to 1 at the end of these functions, allowing potential reentrant calls. This could be exploited if the functions have a callback to an external contract that calls back into this contract before the original function has finished executing.
29_3	2	_transfer, _balance	Unchecked external call	The functions _transfer and _balance make an external call to the 'bento' contract without checking the return value. If these calls fail, the entire transaction will revert, which may not be the desired behavior.
29_3	3	_mintFee	Overflow	The _mintFee function multiplies two uint112 numbers, which could potentially result in a number that is larger than what can be stored in a uint256, resulting in an overflow.
29_3	4	updateBarFee	Unhandled exceptions	The updateBarFee function makes a staticcall to the masterDeployer contract and decodes the returned bytes into a uint256. If the call fails or returns incorrect data, this will throw an exception which isn't caught in the function. This could cause transactions that call this function to revert unexpectedly.
29_3	5	_getReserves, _balance, _update, _mintFee, _getAmountOut, _transfer, _nonOptimalMintFee	Missing function visibility	These internal functions don't have an explicit visibility set. Although they default to internal visibility, it's good practice to explicitly set the visibility for clarity.
29_3	6	various	Use of magic numbers	There are several instances where "magic numbers" are used (like 0xf7888aec, 0x97da6d30, 0xf18d03cc). These values should be replaced with named constants for better code readability and maintainability.
29_1	1	flashSwap	Missing Input Validation	
29_1	2	burn	Arithmetic Underflow	
29_1	3	burnSingle	Arithmetic Underflow	
29_1	4	swap	Arithmetic Underflow	
29_1	5	burnSingle	Missing Input Validation	
29_1	null
29_1	null
25_1	1	peek, get	Arithmetic Precision	In the `peek` and `get` functions, the value is calculated as `value = price * amount / 1e18;`. This may lead to precision loss due to integer division, especially if `price * amount` is less than `1e18`. It would be more accurate to perform the division first and then multiply by `amount`.
25_1	2	setSource, setSources	Absence of Input Validation	There are no checks to ensure that the `source` address provided to the `setSource` and `setSources` functions is not a zero address. If a zero address is passed into these functions, it would overwrite an existing source address with a zero address, which can lead to unexpected behavior.
25_1	1	peek, get	Arithmetic Precision	In the `peek` and `get` functions, the value is calculated as `value = price * amount / 1e18;`. This may lead to precision loss due to integer division, especially if `price * amount` is less than `1e18`. It would be more accurate to perform the division first and then multiply by `amount`.
25_1	2	setSource, setSources	Absence of Input Validation	There are no checks to ensure that the `source` address provided to the `setSource` and `setSources` functions is not a zero address. If a zero address is passed into these functions, it would overwrite an existing source address with a zero address, which can lead to unexpected behavior.
25_1	4	_peek, _get	Unchecked External Call Return Values	The contract calls external functions `exchangeRateStored` and `exchangeRateCurrent` on the `CTokenInterface` contract, but does not check their return values. If these functions were to fail, the contract would not be aware of this, which could lead to incorrect behavior.
25_1	1	_updateRewardsPerToken	Arithmetic overflow	In the _updateRewardsPerToken function, there is a potential for arithmetic overflow in the line where the new value for rewardsPerToken_.accumulated is calculated. This can occur if the product of `1e18 * timeSinceLastUpdated * rewardsPerToken_.rate` is larger than what can be stored in a uint256.
25_1	2	_updateUserRewards	Potential loss of rewards	In the _updateUserRewards function, when the new value for userRewards_.accumulated is calculated, the division by 1e18 could potentially result in a loss of rewards due to the truncation of decimal places.
25_1	3	setRewards	Incorrect timestamp comparison	In the setRewards function, there are checks to ensure that a new rewards program can be set only if one is not currently running. However, these checks compare the current block timestamp (in seconds since Unix epoch) with the start and end times of the reward period, which are stored as uint32 values. Given that the current Unix timestamp has already exceeded the maximum value that can be stored in a uint32, these checks will always fail, preventing a new rewards program from being set.
17_1	null
14_3	1	redeemToken	Unexpected value	The `redeemToken` function calculates the `requiredShares` to withdraw from the `badgerSett`. However, the calculation is done in such a way that it could potentially lead to unexpected values. The `requiredShares` are calculated as `(amount * totalShares + totalShares) / badgerSettBadgerBalance`. In this calculation, the `totalShares` are added twice, which may not be intended and could lead to unexpected, higher values for `requiredShares`.
14_3	2	redeemToken	Potential for underflow	The `redeemToken` function uses the `sub` function from the SafeMath library to calculate `requiredSharesBalance` and the new balance of the `msg.sender` in `balances[msg.sender]`. If the value from which we are subtracting is smaller than the value being subtracted, this will result in an underflow error. The contract does not check this condition before subtracting.
14_3	3	supplyTokenTo	Potential for overflow	In the `supplyTokenTo` function, the `add` function from the SafeMath library is used to update the balance of the `to` address in `balances[to]`. If the sum of `balances[to]` and `balanceDiff` exceeds the maximum possible uint256 value, this will result in an overflow error. This condition is not checked before the addition operation.
14_3	1	_tokenToShares	Incorrect order of calculations	The function `_tokenToShares` performs multiplication before division which could lead to an overflow. It might be more accurate and safe to perform the division first.
14_3	2	_sharesToToken	Incorrect order of calculations	Similar to `_tokenToShares`, the `_sharesToToken` function also does multiplication before division, which can potentially lead to overflow errors.
14_3	3	redeemToken	Unexpected value	In the `redeemToken` function, `redeemAmount` is converted to `redeemedShare` using `_tokenToShares` function, which might not yield the expected amount of shares due to the rounding issues in integer division. This could result in slightly lower `redeemedUnderlyingAsset` than expected.
14_3	4	redeemToken	Potential for underflow	The `redeemToken` function uses the `_burn` function from the ERC20Upgradeable library to burn `redeemedShare` from `msg.sender`. If the balance of the `msg.sender` is less than `redeemedShare`, this will result in an underflow error. This condition is not checked before the burning operation.
14_3	5	supplyTokenTo	Potential for overflow	In the `supplyTokenTo` function, the `_mint` function from the ERC20Upgradeable library is used to mint `mintedTokenShares` to `to`. If the sum of `mintedTokenShares` and the current balance of `to` exceeds the maximum possible uint256 value, this will result in an overflow error. This condition is not checked before the minting operation.
8_3	null
16_1	1	updatePrice	Arithmetic Overflow	In the function `updatePrice`, when updating the old pricing entry, the addition operation is performed without checking for overflow. This could result in incorrect calculations if the `cumulativePrice` or `trades` exceed the maximum value of uint256.
16_1	2	updateFundingRate	Arithmetic Underflow	In the function `updateFundingRate`, the subtraction operation `derivativeTWAP.toInt256() - underlyingTWAP.toInt256() - timeValue` can lead to an underflow issue if `underlyingTWAP.toInt256() + timeValue` is larger than `derivativeTWAP.toInt256()`. This can result in a large positive number instead of a negative number due to how underflows work in Solidity.
16_1	1	Various	Use of `require` for validating business logic	`require` is used throughout the contract to enforce business rules. While this is a common pattern in Solidity, it can lead to unexpected results if the conditions aren't met, since `require` will revert the entire transaction. This can make it difficult to identify and handle specific errors in a complex system. It might be worth considering a pattern that allows for more granular error handling.
16_1	2	Various	No input validation	The contract doesn't seem to validate inputs to many of its functions. While some functions use the `onlyOwner` or `onlyWhitelisted` modifiers to restrict access, there's no explicit validation of the input parameters to these and other functions. This can lead to unexpected behavior or vulnerabilities if these functions are called with invalid or malicious inputs.
16_1	3	withdraw	Potential reentrancy attack	In the `withdraw` function, the contract calls an external contract (`IERC20(tracerQuoteToken).transfer`) after updating the state (`tvl = tvl - amount;`). This could potentially lead to reentrancy attacks if the called contract is malicious. A potential solution would be to follow the Checks-Effects-Interactions pattern, where the state is updated after all external calls.
16_1	4	Various	Lack of event emission	There are some state-changing functions that do not emit events. This can make it harder to track the state changes of the contract via events. An example could be the `_updateAccountLeverage` function which updates the leverage but does not emit an event.
16_1	1	latestAnswer	Incorrect Order of Calculations	The gas price and ETH price fetched from Chainlink Oracle are not converted to have consistent decimals before multiplication. Therefore, the returned value may not be in USD/Gas * 10^18 if the decimals of these two oracles are not the same. To fix it, the contract could use the toWad function to convert them to a consistent decimal base before multiplication.
16_1	2	setDecimals	Deviating Semantics	The 'setDecimals' function allows the owner to set the 'decimals' variable without any restrictions. This can lead to inconsistency in calculations throughout the smart contract as other functions use the 'decimals' variable assuming it's 18.
16_1	3	setGasOracle, setPriceOracle	Use of Incorrect Variables	The setGasOracle and setPriceOracle functions are not validating if the input addresses are actual contract addresses. This could potentially allow for setting non-contract addresses as oracle addresses, which would lead to failure when trying to interact with these addresses as contracts.
16_1	4	toWad	Unexpected Values	The multiplication operation raw * scaler could potentially overflow if not handled correctly. An overflow check should be added for this operation to ensure the result fits in a uint256.
16_1	1	applyTrade	Unexpected Values	This function is performing mathematical operations that could potentially lead to overflow or underflow. However, since Solidity 0.8.0 (which this contract is using), arithmetic operations revert on underflow and overflow. Therefore, it is safe. But, it is still a good practice to check for overflows and underflows when working with older versions of Solidity.
16_1	2	marginIsValid	Use of Incorrect Variables	The function marginIsValid does not check if the provided position is valid. It only checks whether the calculated margin is less than 0 and whether the margin is greater than or equal to the minimum margin. However, it does not validate if the values in the position are within expected bounds.
16_1	3	margin	Incorrect Order of Calculations	The price is casted to an int256. If the price is higher than type(int256).max(), this will throw an exception. While this is a guard against an overflow, it also limits the maximum price that can be used. It's not necessarily a bug, but it is a limitation that should be well-documented.
16_1	4	tokenToWad, wadToToken	Use of Incorrect Variables	The functions tokenToWad and wadToToken assume that the provided 'tokenDecimals' are less than or equal to 'MAX_DECIMALS'. If 'tokenDecimals' is greater, these functions will not work correctly.
14_1	1	balanceOfToken	Incorrect order of calculations	The function `balanceOfToken` performs a multiplication followed by a division. Depending on the values of `balances[addr]`, `badgerSettBadgerBalance`, and `totalShares`, this order of operations might cause rounding errors or integer underflows. Ideally, the division should be performed first to ensure that the multiplication does not exceed the maximum uint256 value.
14_1	2	redeemToken	Cases with unexpected values	In the function `redeemToken`, the case when `totalShares` is zero is handled by returning zero. However, if `totalShares` is zero and `amount` is non-zero, it is possible that the user is expecting to redeem tokens but gets zero in return. This might be an unexpected behavior.
14_1	3	redeemToken	Cases with unexpected values	There is a potential case with unexpected values where `badgerSettBadgerBalance` is zero. If `badgerSettBadgerBalance` is zero, `requiredShares` will be zero due to the division by `badgerSettBadgerBalance`, and `requiredSharesBalance` will underflow as it tries to subtract 1 from zero. This might cause unexpected behavior and revert the transaction.
14_1	4	redeemToken	Incorrect variable usage	In the `redeemToken` function, `balances[msg.sender]` is decreased by `requiredSharesBalance`, but it seems that it should be decreased by the redeemed `badgerBalanceDiff` instead, because `balances` map seems to track the user's balance in the underlying badger token, not in badgerSett shares.
14_1	5	supplyTokenTo	Cases with unexpected values	The function `supplyTokenTo` does not handle the case where `badgerSett.deposit(amount)` might fail. If the `deposit` function were to fail, `balanceDiff` could be zero and the user's balance would not be updated, even though the badger tokens have already been transferred. This could lead to a loss of funds for the user.
14_1	1	_tokenToShares, _sharesToToken	Incorrect order of calculations	In both `_tokenToShares` and `_sharesToToken` functions, there is multiplication before division. In these functions, you should be careful with the order of operations, as the current operation order can lead to loss of precision due to rounding down.
14_1	2	_depositToIdle	Cases with unexpected values	In the `_depositToIdle` function, there's no check for the return value of `mintIdleToken`. If `mintIdleToken` fails and returns zero, the function will still succeed, and the user's tokens will be stuck in this contract.
14_1	3	supplyTokenTo, redeemToken	Cases with unexpected values	In the `supplyTokenTo` and `redeemToken` functions, there's no check if the `to` address or `msg.sender` is the zero address. Transferring tokens to the zero address can lead to permanent loss of those tokens.
14_1	4	redeemToken	Incorrect variable usage	In the `redeemToken` function, the `redeemAmount` is denominated in `token()`, but it seems to be used as an amount of shares in `redeemIdleToken`. If `token()` and shares have different decimals, this will cause incorrect behavior.
14_1	5	transferERC20	Cases with unexpected values	In the `transferERC20` function, there's a check that `erc20Token` is not `idleToken`, but there's no check if `erc20Token` is the zero address. If `erc20Token` is the zero address, this function will revert because `safeTransfer` to the zero address is likely to fail.
8_1	null
3_3	null
3_3	null
3_3	1	_withdrawHourlyBond	Underflow vulnerability	In function _withdrawHourlyBond, there is a potential underflow when subtracting the 'amount' from 'bond.amount'. If 'amount' is greater than 'bond.amount', this operation will underflow and lead to an incorrect calculation. We need to add a require statement to ensure 'amount' is less than or equal to 'bond.amount'.
3_3	2	calcCumulativeYieldFP	Incorrect order of calculations	The calculation `yieldAccumulator.accumulatorFP * yieldAccumulator.hourlyYieldFP * secondsDelta` in the function `calcCumulativeYieldFP` might lead to overflow due to incorrect order of calculations. The multiplication operation should be done after the division to avoid potential overflow.
3_3	3	_withdrawHourlyBond	Potential Reentrancy	In function _withdrawHourlyBond, before reducing the bond.amount and lendingMeta[issuer].totalLending, it is better to transfer the amount to the user (in a real use-case scenario where funds are transferred). If the transfer happens after the state update and it calls back into this contract, it could potentially cause a reentrancy attack. This is more of a theoretical point as this contract does not currently perform any transfers. However, if it were to be extended to do so, this could become a problem.
3_3	4	N/A (general issue)	Time manipulation	The contract relies heavily on block.timestamp (alias "now") for calculations. This can potentially be manipulated by miners to a certain degree, which could impact the calculations and operations within the contract.
3_3	5	calcCumulativeYieldFP	Precision loss	In function calcCumulativeYieldFP, when calculating the accumulatorFP, the division is done before the multiplication. This can lead to precision loss, because in Solidity, division truncates the result. This could potentially lead to financial implications as this contract deals with financial calculations.
3_3	null
5_1	null
5_1	1	calcValueInBase, calcValueInToken	Division by Zero	There are no checks to ensure that the variables _baseAmt and _tokenAmt are not zero before they are used as a denominator in the division operation in the functions calcValueInBase and calcValueInToken. A division by zero would cause a revert in the EVM.
5_1	2	getCollateralValueInBase	Unhandled exceptions	In the getCollateralValueInBase function, if the collateralAsset argument isn't a base, pool or synth as per isBase, isPool and isSynth checks, the function would end without returning any values. This might lead to unpredictable behavior in the functions that call getCollateralValueInBase and expect it to return values.
5_1	3	isPool	Uninitialized variables	In the isPool function, the variable pool is not initialized which could lead to unpredictable behavior. If the condition inside the if statement does not hold true, the function would return an undefined value.
5_1	4	calcPart	Incorrect use of require statement	The require statement in the function calcPart checks if the bp parameter is between 0 and 10000, inclusive. However, it is not required to check if bp is greater than or equal to 0 because the bp parameter is of type uint, which cannot be negative.
3_1	null
3_1	1	adjustAmounts	Underflow	In the `adjustAmounts` function, there is a statement `account.holdings[fromToken] = account.holdings[fromToken] - soldAmount;` which can potentially cause an underflow error if `soldAmount` is greater than `account.holdings[fromToken]`. Solidity will not throw an exception on underflow or overflow. Instead, it will silently give an incorrect result.
3_1	null
3_1	1	setLendingCap, setLendingBuffer, setHourlyYieldAPR	Lack of Input Validation	Without proper validation, these functions are prone to misuse or bugs resulting from extreme input values.
3_1	2	applyBorrowInterest, registerBorrow, payOff	Potential Overflow and Underflow	These functions perform arithmetic operations without explicitly checking for overflows or underflows.
3_1	3	N/A	Lack of Events	The contract does not emit events, making it difficult to monitor state changes.
3_1	4	deactivateIssuer	Inaccurate Error Messages	The error message does not correctly reflect the action being performed.
3_1	5	N/A	Implicit Visibility in State Variables	Not declaring visibility explicitly can lead to confusion about how and where state variables can be accessed.
112_3	1	increaseActionLockedBalance	Logic Error	In the increaseActionLockedBalance function, the balance of actionLockedBalances[account] is increased without checking if this operation causes an overflow.
112_3	2	decreaseActionLockedBalance	Logic Error	In the decreaseActionLockedBalance function, the balance of actionLockedBalances[account] is decreased without checking if this operation causes an underflow.
112_3	3	unstakeFor	Re-entrancy Bug	In the unstakeFor function, the external calls to the safeTransfer function and handleLpTokenTransfer function may allow re-entrancy attacks because there are state changes after these calls.
112_3	4	stakeFor	Logic Error	In the stakeFor function, the balance of the contract is checked after the token transfer. If the transfer fails or an incorrect amount is transferred, the require statement will throw an error. However, the error message 'INVALID_AMOUNT' is not descriptive of the actual issue.
112_3	5	stakeFor	Arithmetic Overflow	In the stakeFor function, the balance of the account is increased without checking for potential arithmetic overflow.
112_3	6	unstakeFor	Arithmetic Underflow	In the unstakeFor function, the balance of the account is decreased without checking for potential arithmetic underflow.
112_3	7	transfer	Arithmetic Overflow	In the transfer function, the balance of the account is increased without checking for potential arithmetic overflow.
112_3	8	transfer	Arithmetic Underflow	In the transfer function, the balance of the account is decreased without checking for potential arithmetic underflow.
112_2	null
110_2	null
83_3	null
92_3	1	boost	Reentrancy vulnerability.	The `boost` function calls `vault.deposit` after the `feiAmount` has been borrowed but before it's marked as borrowed. This is a potential reentrancy attack vector because `vault.deposit` is an external call to an untrusted contract. The external contract could call back into the `boost` function before the original call is finished, potentially leading to incorrect state.
92_3	2	less	Underflow potential	The `less` function reduces `getTotalFeiBoostedForVault[vault]` and `totalFeiBoosted` without checking if `feiAmount` is greater than them. This could potentially lead to an underflow if `feiAmount` is larger than `getTotalFeiBoostedForVault[vault]` or `totalFeiBoosted`.
92_3	3	slurp	Incorrect calculations	The function `slurp` calculates the `interestEarned` by subtracting `getTotalFeiBoostedForVault[vault]` from `vault.assetsOf(address(this))`. This can lead to underflow if `getTotalFeiBoostedForVault[vault]` is greater than `vault.assetsOf(address(this))`. Furthermore, it's worth noting that you're trusting the `vault.assetsOf` function to return the correct value. If it doesn't, it could affect your contract's state.
92_3	4	sweep	Potential loss of funds	The `sweep` function allows the owner to withdraw any ERC20 token from the contract. However, there is a check that disallows withdrawing tokens if `getTotalFeiBoostedForVault[ERC4626(address(token))]` is not zero or `token` is not `assetTurboCToken`. This might lead to loss of funds if the `getTotalFeiBoostedForVault` mapping contains a non-zero value for any token other than `fei` or `assetTurboCToken`.
97_3	1	getRewardAmount	Incorrect Order of Calculations	The reward calculation can result in an incorrect amount due to the order of operations. In this function, the multiplication precedes the division operation, which could lead to an integer overflow if the multiplication operation results in a very large number. It might be safer to perform the division operation first to avoid any possible overflow.
97_3	2	getAmountToTransfer	Unexpected Values	The function calculates the amount to transfer based on the gas used and some other factors. However, if the gas used is higher than expected, or if the tokenGasPrice is very high, it can result in a gasFee that is greater than the amount, leading to an underflow when calculating the amountToTransfer. There should be a check to ensure that the gasFee does not exceed the amount.
97_3	3	depositErc20, depositNative	Unexpected Values	The reward amount is subtracted from the incentivePool without checking whether the reward amount is less than or equal to the available incentivePool for the respective token. This can result in an underflow if the rewardAmount is greater than the incentivePool.
97_3	4	getTransferFee	Unexpected Values	The function calculates the fee based on the current and provided liquidity. However, if the currentLiquidity is greater than the amount, the resultingLiquidity can be negative, which can cause the denominator of the fee calculation to be negative or zero, leading to an unexpected result or division by zero error.
102_3	null
102_2	1	getMonthlyAPR	Division by Zero	If the `previousMonth` variable is zero, this will cause a division by zero error when calculating the `percentageChange`.
102_2	2	requestCPIData	Potential Security Vulnerability	The function `requestCPIData` is callable by anyone after the 14th day of the month, which could potentially lead to unwanted behaviors or malicious exploitation.
102_2	3	fulfill	Potential Security Vulnerability	The function `fulfill` is external and doesn't verify the identity of the caller, which could potentially allow unauthorized actors to fulfill requests.
97_2	1	getAmountToTransfer	Incorrect Order of Calculations	In the getAmountToTransfer function, the calculation for the transfer fee is performed before considering the gas fee. In reality, the gas fee should be calculated first since it might affect the balance and thus the transfer fee calculation.
97_2	2	setTrustedForwarder	Incorrect use of a variable	There's an attempt to set _trustedForwarder, which is a function parameter, rather than setting a state variable. This is most likely a mistake.
97_2	3	depositErc20, depositNative	Unexpected values	The functions depositErc20 and depositNative both have a risk of underflow when executing the instruction 'incentivePool[tokenAddress] = incentivePool[tokenAddress] - rewardAmount;'. If rewardAmount is greater than incentivePool[tokenAddress], it will cause an underflow, leading to incorrect behavior.
97_2	4	setTrustedForwarder	Incorrect use of a variable	The function is trying to set _trustedForwarder which is a function parameter, rather than setting a state variable. It should probably be setting a state variable with a similar name.
92_2	null
83_2	1	deposit, withdraw	Unexpected behavior in deposit and withdraw functions	In the deposit function, if the deposit fee is greater than 0, the user's amount is reduced by the deposit fee. In the withdraw function, the user can only withdraw if their amount is greater than 0. It might be more user-friendly to allow a withdraw of 0, which would still allow them to collect any pending rewards.
79_2	1	withdrawAVAX	Potential Underflow Bug	In the `withdrawAVAX` function, there's a potential underflow when calculating `user.balance -= _amount;` and `wavaxReserve -= _amount;`. If `_amount` is greater than `user.balance` or `wavaxReserve`, the subtraction will underflow and result in a very large number because of the way Solidity handles underflows.
79_2	2	withdrawLiquidity, withdrawIncentives	Potential Reentrancy Bug	The `withdrawLiquidity` and `withdrawIncentives` functions transfer tokens to an external address and then update the state variable `user.hasWithdrawnPair` and `user.hasWithdrawnIncentives` respectively. This pattern can be vulnerable to reentrancy attacks. The state variable should be updated before the transfer is made.
79_2	3	initialize	Lack of Input Validation	In the `initialize` function, there is no check for whether the `_token` address is a zero address, which could lead to potential issues.
79_2	4	depositAVAX	Potential Overflow Bug	In the `depositAVAX` function, there's a potential overflow when calculating `uint256 newAllocation = user.balance + msg.value;`. If the sum of `user.balance` and `msg.value` is greater than the maximum value that can be stored in a `uint256`, the addition will overflow and result in a very small number.
79_2	5	emergencyWithdraw	Unexpected Behavior	In the `emergencyWithdraw` function, if the caller is the issuer, all remaining tokens are sent to the issuer. However, if the caller is not the issuer, only the user's balance in WAVAX is withdrawn. The function may lead to unexpected outcomes if the issuer is also a user.
79_2	6	createPair	Incorrect Calculation	In the `createPair` function, it's possible that `tokenAllocated` could be zero if the `floorPrice` is set extremely high. This could lead to a division by zero error later in `tokenIncentivesForUsers = (tokenIncentivesForUsers * tokenAllocated) / tokenReserve;`. There should be a check to ensure that `tokenAllocated` is not zero.
78_2	null
77_2	1	wDiv	Integer Division Precision Loss	The function wDiv performs integer division which could lead to precision loss because Solidity rounds down to the nearest integer during division. If 'b' is greater than 'a', the result will be zero due to how integer division works in Solidity.
77_2	2	wMul	Integer Overflow/Underflow	The function wMul multiplies 'a' and 'b', which may cause an overflow if the result is greater than the max uint256. Similarly, the function diff subtracts 'a' and 'b', which may lead to underflow if 'b' is greater than 'a'.
77_2	3	sqrt	Incorrect use of function 	The sqrt function is set as internal but it is not called from within the contract, so it may not function correctly in the current context. It is recommended to change its visibility based on the need or use it correctly.
71_2	null
71_2	null
66_3	1	_buyBack	Logic error	The `_buyBack` function is not updating `effectiveYetiTokenBalance` after buying back tokens. This could lead to an inconsistency between the real balance of YETI tokens in the contract and the `effectiveYetiTokenBalance` variable, which is used in calculations like `mint` and `burn` functions.
66_3	2	mint	Logic error	The `mint` function allows any user to mint new sYETI tokens by simply calling the function with the desired amount of YETI to be staked. However, the function does not check whether the user has sufficient YETI balance before minting the new sYETI tokens.
66_3	3	burn, _burn	Logic error	The `burn` and `_burn` functions remove sYETI tokens from the total supply and transfer YETI tokens to the user. However, these functions do not check if the contract has enough YETI tokens to transfer to the user. This could lead to a situation where the contract's YETI balance is less than the amount it tries to transfer, causing the transfer to fail.
66_3	4	setAddresses	Access control bug	The `setAddresses` function allows the owner to set the addresses of the YETI and YUSD tokens. However, there is no mechanism in place to prevent the owner from setting these addresses multiple times, which could potentially allow the owner to change the addresses after they have been initially set. This could be a serious security risk.
66_3	5	publicBuyBack	Arithmetic Precision Error	The `publicBuyBack` function calculates 5% of the YUSD balance in the contract using integer division, which could lead to precision loss. This might not be a critical issue, but it can lead to minor discrepancies in the calculations over time.
66_3	6	rebase	Arithmetic Overflow Error	The `rebase` function includes multiplication operations without using SafeMath, which could potentially lead to arithmetic overflow. For example, in the calculation `valueOfContract.mul(transferRatio)`, if the values of `valueOfContract` and `transferRatio` are large enough, the result could exceed the maximum value for uint256, causing an overflow.
66_3	7	rebase	Missing event emission	In the `rebase` function, the `effectiveYetiTokenBalance` is updated, but there is no event emitted to track this change. This could make it harder to monitor and verify the changes in the `effectiveYetiTokenBalance` variable.
70_3	null
70_3	null
70_3	1	_calculateVaderPrice and _calculateUSDVPrice	Semantic Error / Incorrect Variable Reference	In the functions _calculateVaderPrice and _calculateUSDVPrice, the calculation of totalUSD is made with division by totalVaderLiquidityWeight and totalUSDVLiquidityWeight respectively. This division operation is done inside the for loop. Therefore, if the total liquidity weight is zero (which can happen if there's no liquidity in the pairs), it will cause a division by zero error. Division by zero is undefined and can cause the contract to revert or behave unpredictably.
70_3	2	_updateVaderPrice and _updateUSDVPrice	Incorrect Order of Calculations	In the functions _updateVaderPrice and _updateUSDVPrice, there is unchecked division when calculating the nativeTokenPriceAverage. This unchecked division could lead to incorrect calculations if timeElapsed is zero. This could occur if multiple transactions are included in the same block or due to some other unforeseen circumstances leading to subsequent function calls within the same block. This can lead to an incorrect price average calculation.
70_2	1	`_updateVaderPrice`, `_updateUSDVPrice`	Arithmetic Underflow	The unchecked block in the `_updateVaderPrice` and `_updateUSDVPrice` functions doesn't handle the case when `nativeTokenPriceCumulative` is less than `pairData.nativeTokenPriceCumulative`. The operation could result in an underflow.
70_2	2	`syncVaderPrice`, `syncUSDVPrice`	Reentrancy	In the `syncVaderPrice` and `syncUSDVPrice` functions, the contract state `pairData.pastLiquidityEvaluation` is updated after an external call to `_updateVaderPrice` and `_updateUSDVPrice` which in turn make external calls to `getChainlinkPrice`. This could potentially lead to reentrancy attacks if the `getChainlinkPrice` function is not implemented securely.
70_2	3	`getChainlinkPrice`	Stale Oracle Data	In the `getChainlinkPrice` function, there is a check if the latest round data is newer or equal to the roundId. However, there is no check to see if the roundId is actually recent enough. If the chainlink oracle data is stale, it might still pass this check, but the data may not reflect the actual current market price.
70_2	4	`_calculateVaderPrice`, `_calculateUSDVPrice`	Integer Overflow	In the `_calculateVaderPrice` and `_calculateUSDVPrice` functions, there's multiplication of variables without adequate checks for potential integer overflow.
70_2	5	constructor	Incorrect Zero Address Check	In the constructor, there is a check for zero addresses. However, the check for `_vaderPool` is incorrect. It should check against address(0), not IVaderPoolV2(address(0)).
70_2	1	reimburseImpermanentLoss	Potential Integer Division Error	In the function `reimburseImpermanentLoss`, there is a potential integer division error. Solidity performs integer division, which means that the division of `amount / usdvPrice` or `amount * vaderPrice` could lead to incorrect results due to truncation if `usdvPrice` or `vaderPrice` is significantly larger than `amount`. This could potentially lead to users getting reimbursed less than they should. It's recommended to use a library like OpenZeppelin's `SafeMath` or handle these cases more carefully.
70_2	2	grant and reimburseImpermanentLoss	Potential Re-Entrancy	The `grant` and `reimburseImpermanentLoss` functions use the `safeTransfer` method from the OpenZeppelin `SafeERC20` library, which makes a call to an external contract. The state variable `lastGrant` is updated after this external call in the `grant` function, which could potentially lead to a re-entrancy bug. Although `SafeERC20` mitigates some risks of re-entrancy, it's still generally best practice to make state changes before external calls to ensure contract state integrity.
70_2	3	grant and reimburseImpermanentLoss	Unchecked Return Value	The `safeTransfer` function does not have its return value checked in both `grant` and `reimburseImpermanentLoss` functions. While the `safeTransfer` function from OpenZeppelin's `SafeERC20` library will revert if the transfer fails, there are some ERC20 tokens that do not adhere to the standard and do not return a boolean value. It would be safer to check the return value of the `safeTransfer` call to ensure it returns `true`.
70_2	1	mint, burn	Potential Integer Division Error	In both the `mint` and `burn` functions, there's a potential issue with integer division. Solidity performs integer division, which means that the division of `vPrice * vAmount / 1e18` or `uPrice * uAmount / 1e18` could lead to incorrect results due to truncation if `vPrice` or `uPrice` is significantly larger than `vAmount` or `uAmount` respectively. This could potentially lead to users getting minted or burned less than they should. It's recommended to use a library like OpenZeppelin's `SafeMath` or handle these cases more carefully.
70_2	2	mint, burn	Potential Re-Entrancy	The `mint` and `burn` functions use the `transferFrom`, `burn`, `mint`, and `transfer` methods from the `IERC20Extended` contract, which makes a call to an external contract. This is done before updating state variables, which could potentially lead to a re-entrancy bug. While re-entrancy might not necessarily lead to issues in this specific case, it's generally best practice to make state changes before external calls to ensure contract state integrity.
70_2	3	mint, burn, claim, claimAll	Unchecked Return Value	The `transferFrom`, `burn`, `mint`, and `transfer` functions do not have their return values checked in `mint`, `burn`, `claim`, and `claimAll` functions. While these functions from OpenZeppelin's `ERC20` and `IERC20Extended` contracts will revert if the transfer or burn fails, there are some ERC20 tokens that do not adhere to the standard and do not return a boolean value. It would be safer to check the return value of these calls to ensure it returns `true`.
70_2	4	mint	Order of Operations	In the `mint` function, the `uAmount` is calculated before checking if the `cycleMints` plus `uAmount` would exceed the `dailyLimit`. If the `cycleMints` does exceed the `dailyLimit`, the function reverts and the tokens that were transferred from the sender and burned are not returned or minted back. It would be safer to perform this check before burning the tokens.
66_2	null
61_2	null
61_2	null
61_2	null
61_2	null
60_2	1	debitAccount	Unexpected Values	There is no check for whether the account has enough balance before debiting the amount. This could lead to underflow if the amount to be debited is greater than the account balance. This can be avoided by adding a condition to check if the balance is greater than or equal to the amount to be debited.
60_2	2	settleAccount	Unexpected Values	Similarly, in the settleAccount function, there is no check before subtracting the amount from the account balance. This could result in an underflow if the amount is greater than the account balance. A condition to check if the balance is greater than or equal to the amount to be subtracted should be added.
60_2	3	settleAccount	Incorrect Order of Calculations	In the settleAccount function, the shortfall is added twice when the newBalance is negative. Once within the if block and once after the if block. This could result in an inaccurate calculation of the shortfall. The shortfall should only be updated once in the if block.
56_3	null
58_3	null
59_3	2	`setEarlyExitBps`	Input validation	This function allows setting a value that's higher than 100% which is probably not intended. It should validate that the input value is between 0 and 1000.
59_3	3	`initialize`	Zero address check	The function should include require statements to check that none of the address parameters are the zero address.
59_3	1	`getPegDeltaFrequency()`	Incorrect Order of Calculations	The multiplication with `10000` should be done after the division to avoid loss of precision due to rounding errors.
59_3	2	`getAverageParticipation()`	Incorrect Use of Variables	The variable `initialAuction` should ideally not start from 0 if the `currentAuctionId` is less than `auctionAverageLookback`. This may lead to performance issues with large auction history.
59_3	3	`consult(uint256 excess)`	Potential Overflow	The calculation `(frequency + (participation * 2)) / 3` could potentially overflow if `participation` is very large. This is unlikely given the function's context, but it's good practice to consider the maximum possible values a variable can hold.
59_2	1	consult()	Precision loss	The skew calculation `(frequency + (participation * 2)) / 3;` suffers from precision loss due to integer division. This could lead to slightly inaccurate results.
59_2	2	getAverageParticipation()	Integer overflow	In the line `aggregate.maxCommitments = aggregate.maxCommitments + maxCommitments;` and `aggregate.commitments = aggregate.commitments + commitments;`, there is a potential for integer overflow which could lead to incorrect calculations.
59_2	3	setAuctionAverageLookback()	Unbounded array size	There's no check for the maximum size of the `pegObservations` array. This could lead to out of gas errors if the array becomes too large. It could also be exploited to fill up the blockchain storage.
59_2	4	getRealBurnBudget()	Integer underflow	In the line `uint256 usableExcess = maxBurnSpend.sub(premiumExcess);`, it is not checked whether `maxBurnSpend` is greater than or equal to `premiumExcess` before the subtraction. This can potentially cause an underflow if `premiumExcess` is larger than `maxBurnSpend`.
59_2	1	exitEarly	Unexpected Values	In the `exitEarly` function, there is a lack of validation for the `amount` input. This could potentially lead to negative values, or values that are too high, being used in the function. A require statement should be added to ensure that the `amount` is greater than 0 and less than or equal to the user's balance.
59_2	2	earlyExitReturn	Incorrect Order of Calculations	There could be a potential for underflow in the `earlyExitReturn` function. The line `uint256 userOutstanding = userCommitment - userRedeemed;` assumes that `userCommitment` is always larger than or equal to `userRedeemed`. If for some reason it isn't, this could lead to an underflow error. There should be a check to ensure `userRedeemed` is not larger than `userCommitment`.
59_2	3	_calculateMaltRequiredForExit	Incorrect Order of Calculations	The same potential for underflow exists in the `_calculateMaltRequiredForExit` function as well, with the line `if (amount > (userCommitment - userRedeemed))`. It should be checked that `userRedeemed` is not larger than `userCommitment` before this calculation.
59_2	4	setEarlyExitBps	Use of Incorrect Variables	In the function `setEarlyExitBps`, the requirement checks if `_earlyExitBps` is greater than 0 and less than or equal to 1000, but the comment above says it should be between 0-100%. It looks like a mismatch between the comment and the actual code. The comment should be updated to reflect the actual requirement or vice versa.
59_2	5	earlyExitReturn and _calculateMaltRequiredForExit	Incorrect Order of Calculations	Division before multiplication can lead to loss of precision due to integer division. `maltQuantity.mul(currentPrice) / pegPrice;` this should be rearranged to `maltQuantity.mul(currentPrice).div(pegPrice);` to prevent the loss of precision.
58_2	1	deposit	Deviating Semantics	The "deposit" function uses an error message "BF" when the balance factor equals 0. The error message is not descriptive and might confuse users or developers. A more explicit error message might be used, like "Balance factor cannot be zero."
58_2	2	withdraw	Incorrect Order of Calculations	In the "withdraw" function, there's a possibility that the total supply could be zero, causing a division by zero error when calculating tokenAmounts[i]. This could be mitigated by checking if the total supply is greater than zero before performing the division.
58_2	3	_chargeFees	Incorrect Variable Use	In the "_chargeFees" function, the elapsed time is calculated by subtracting lastFeeCharge from the current block timestamp. However, if this function is called before any fee has been charged, lastFeeCharge would be zero, causing the elapsed time to be incorrectly calculated as the current timestamp. This could lead to incorrect fee charges.
56_2	null
52_2	null
52_2	null
52_2	1	_burn	Potential Underflow/Overflow	The `_burn` function contains potential underflow points with the expressions `reserveNative - amountNative` and `reserveForeign - amountForeign`. If `amountNative` or `amountForeign` is greater than their corresponding reserves, this could lead to underflow.
52_2	2	_update	Potential Underflow/Overflow	The `_update` function contains potential overflow points with the expressions `balanceNative <= type(uint112).max` and `balanceForeign <= type(uint112).max`. If `balanceNative` or `balanceForeign` exceed their max limit, this could lead to an overflow.
52_2	3	_onlyRouter, _supportedToken	Incorrect function modifier	These functions have been designed as view functions, but they should actually be modifiers. View functions are expected to return a value, which these do not.
52_2	4	swap	Unexpected value	In the `swap` function, it's expected that either `nativeAmountIn` or `foreignAmountIn` should be greater than zero, but not both. However, if both are greater than zero, there is no check or error message for this case, which can lead to unexpected behavior.
52_2	5	rescue	Unexpected value	In the `rescue` function, the smart contract transfers tokens to `msg.sender`, which can be any address. This could be a potential security risk if an unexpected address calls this function.
52_2	6	mint	Unchecked Math	In the `mint` function, there is unchecked addition `totalLiquidityUnits + liquidity`. If the sum of these two values exceeds the maximum uint256 value, it will cause an overflow.
52_2	1	burnFungible	Incorrect SafeMath Operation	In the 'burnFungible' function, there is a subtraction operation in 'pair.totalSupply = _totalSupply - liquidity;' without using SafeMath which can lead to underflow if '_totalSupply' is less than 'liquidity'.
52_2	2	_update	Incorrect SafeMath Operation	The function '_update' is being called with operations like addition and subtraction of 'reserveNative' and 'reserveForeign' with 'nativeDeposit' and 'foreignDeposit' respectively, without using SafeMath, which can lead to underflow or overflow.
52_2	3	mintSynth	Incorrect SafeMath Operation	In the 'mintSynth' function, there's an addition operation in '_update' call without using SafeMath which can lead to overflow if 'reserveNative' and 'nativeDeposit' are large enough.
52_2	4	mintFungible	Incorrect SafeMath Operation	In the 'mintFungible' function, there are addition operations in '_update' call and 'pair.totalSupply = totalLiquidityUnits + liquidity;' without using SafeMath which can lead to overflow if the operands are large enough.
52_2	5	burn	Use of incorrect variable	In the 'burn' function, there is a use of '_ONE_YEAR' variable which is not defined anywhere in the contract. It might lead to compilation error.
52_2	6	mintSynth, burnSynth, burn, mintFungible, burnFungible	Potential re-entrancy vulnerability	While the 'nonReentrant' modifier is used to prevent re-entrancy attacks in the aforementioned functions, it is important to note that the 'nonReentrant' modifier implementation is not provided in the provided contract code. It's usually a part of OpenZeppelin's 'ReentrancyGuard' contract which is not imported here. If it's not implemented correctly, it might expose the contract to re-entrancy attacks.
52_2	7	mintFungible	No validation of 'nativeDeposit' and 'foreignDeposit'	In the 'mintFungible' function, there are no checks to ensure 'nativeDeposit' and 'foreignDeposit' are greater than zero. If either of these values are zero, it could lead to the creation of a pair with zero liquidity.
52_2	null
49_2	1	fetchPricePoint, computeDepth	Arithmetic Overflow/Underflow	The contract does not use SafeMath for uint operations which means there can be cases of overflow or underflow. Although Solidity 0.8.0 has built-in overflow and underflow protection, it is still necessary to handle such cases where the contract can revert because of an overflow or underflow error.
49_2	2	fetchPricePoint, computeDepth	Integer Division	Solidity rounds down the results of integer divisions. In the functions `fetchPricePoint` and `computeDepth`, such divisions can lead to imprecision in the calculations, especially when dealing with small values.
49_2	3	Constructor	Potential Uninitialized Storage Reference	The constructor is calling four other contracts or libraries via their constructors. If any of these contracts fail to initialize properly, the state of the OverlayV1UniswapV3Market contract could be unpredictable or incorrect.
47_2	1	mint and burn	Potential re-entrancy attack	The `mint` and `burn` functions call external contracts (`ibbtc.transferFrom` and `ibbtc.transfer` respectively) after a state change. If the ibbtc contract is malicious, it could potentially make a re-entrant call into the contract.
47_2	1	mint, burn	Re-entrancy Attack	The `mint` and `burn` functions call external contracts (`ibbtc.transferFrom` and `ibbtc.transfer` respectively) after a state change. If the ibbtc contract is malicious, it could potentially make a re-entrant call into the contract.
47_2	2	mint, burn	Lack of input validation	The `mint` and `burn` functions don't validate the `_shares` input. If `_shares` is an extremely high value, it could potentially overflow.
47_2	3	updatePricePerShare	Front-running Attack	The `updatePricePerShare` function is public and can be called by anyone. This could potentially allow an attacker to front-run transactions by updating the price per share before executing their own transactions.
47_2	4	updatePricePerShare	Timestamp Manipulation	The `updatePricePerShare` function relies on the `now` keyword (alias for `block.timestamp`). Miners have some leeway in manipulating this value, which could potentially impact the logic of your smart contract.
47_2	5	balanceToShares, sharesToBalance	Incorrect Calculation	The functions `balanceToShares` and `sharesToBalance` use a magic number `1e18`. It would be better to define this value as a constant at the beginning of the contract to improve readability and maintainability.
39_3	null
42_3	1	flashLoan	Reentrancy	The function `flashLoan` could potentially be vulnerable to a reentrancy attack. It transfers an amount of tokens to a flash loan receiver and then expects the same amount of tokens back. If the receiver is a malicious contract, it could call `flashLoan` again before returning the tokens, causing reentrancy. To prevent this, consider using the Checks-Effects-Interactions pattern.
42_3	2	flashLoan	Uncontrolled External Call	The function `flashLoan` makes an external call to `_receiver.onFlashLoan(...)`. This could potentially be an issue if the receiver contract's `onFlashLoan` function has malicious code or if the receiver contract is not implemented correctly. Be cautious when making calls to external contracts and consider using secure patterns like the Withdrawal pattern instead of direct transfers.
42_3	3	repay	Arithmetic Underflow	The function `repay` subtracts `_amount` from `debts` without checking whether `_amount` is less than or equal to `debts`. This could result in an underflow if `_amount` is greater than `debts`. Although the `require(_amount > 0, "zero");` statement might mitigate this problem to some extent, it's still recommended to use SafeMath library or similar mechanism for arithmetic operations to prevent underflows and overflows.
44_3	2	swapByQuote	Cases with Unexpected Values or Deviating Semantics	The function swapByQuote uses the msg.value to determine if the operation involves Ether. If the operation is supposed to involve Ether but msg.value is 0, the function reverts. However, it may be more appropriate to check if msg.value is equal to the amount that is supposed to be sent. If the two values do not match, the function should revert.
45_3	null
45_2	1	_sortArray	Unbounded Loops	This function employs a bubble sort algorithm, which has a time complexity of O(n^2). In the worst-case scenario (an array that is reverse sorted), it could lead to excessive gas costs and possible transaction failure if the array is large enough, due to exceeding the Ethereum block gas limit.
45_2	2	getLockedAmount	Unchecked Return Value	In the function `getLockedAmount`, there are multiple return statements within the for loop. If none of the `array[i].staker` elements match the `account` input, the function will return 0. While not necessarily an error, it might lead to unexpected behavior if this case isn't properly handled where the function is called.
45_2	3	getLockedAmount	Use of Magic Numbers	The function `getLockedAmount` has a magic number 1 in the expression `newLockedAmount = array[i].lockedAmount - 1`. This could lead to confusion and potential errors in the future. It's generally good practice to define such numbers as constants with descriptive names.
45_2	4	getCreditLimit	Inefficient Storage Pattern	The `getCreditLimit` function returns a median value based on an array of values passed as a parameter. If this data is frequently used, it may be more efficient to store it in a state variable to avoid calculating the median repeatedly.
44_2	null
42_2	null
39_2	1	withdraw	Reentrancy	The function `withdraw` in the contract could be susceptible to a reentrancy attack as the state (`withdrawals[e] = 0;`) is updated after the transfer (`token.transfer(admin, token.balanceOf(address(this)));`). An attacker might take advantage of this by causing the contract to perform a callback to their contract.
39_2	2	setFee	Lack of input validation	There seems to be no input validation for the `setFee` function. It allows the admin to set any arbitrary fee value without any checks if the fee is within a certain range or limit.
39_2	3	initiateVaultFillingZcTokenInitiate, initiateZcTokenFillingVaultInitiate, initiateZcTokenFillingZcTokenExit, initiateVaultFillingVaultExit, exitZcTokenFillingZcTokenInitiate, exitVaultFillingVaultInitiate, exitVaultFillingZcTokenExit, exitZcTokenFillingVaultExit	Incorrect order of calculations (Integer Division)	Integer division in Solidity discards the remainder. This is fine for some cases but it can lead to imprecision and rounding errors. In multiple parts of the code, there are instances where the value is multiplied by 1e18, divided by a variable, then again divided by 1e18. This could lead to a loss of precision. One potential fix is to rearrange the operations to perform the multiplication last.
39_2	4	exitZcTokenFillingZcTokenInitiate, exitZcTokenFillingVaultExit	Potential Underflow	The lines `uToken.transferFrom(o.maker, msg.sender, principalFilled - a - fee);` and `uToken.transfer(msg.sender, principalFilled - a - fee);` could potentially underflow if `a` and `fee` are greater than `principalFilled`. It's recommended to use SafeMath or Solidity 0.8.0 or higher (which has built-in overflow and underflow protection).
34_2	null
31_2	1	balanceOfPool()	Incorrect order of calculations	In the balanceOfPool() function, the value of bCVXToCVX is retrieved and checked for its value after it is used to calculate valueInLocker. If bCVXToCVX is less than or equal to 10**18, the function reverts with "Loss Of Peg". This check should be performed before the calculation is made to ensure that the peg has not been lost and to prevent unnecessary calculations if it has.
31_2	2	_withdrawSome()	Incorrect use of variables	In the _withdrawSome() function, it requires that max is greater than or equal to _amount multiplied by 9_980 divided by MAX_BPS. However, the variable "max" is set to the balance of the "want" token in the contract's address, and it may not be the correct amount for this check. This could potentially lead to incorrect calculations and potentially unwanted behavior.
31_2	3	manualRebalance()	Cases with unexpected values	In the manualRebalance() function, if the newLockRatio is less than or equal to the currentLockRatio, the function will deposit all CVX into the vault without considering the toWantRatio. This may lead to more tokens being locked than expected, thus not respecting the desired balance defined by the toLock parameter.
31_2	4	_deposit()	Incorrect use of variables	In the _deposit() function, the contract calls the function CVX_VAULT.withdraw() with the amount intended to be deposited. This seems to be a mistake and it should be CVX_VAULT.deposit() instead.
30_2	null
30_2	null
25_3	null
25_3	null
25_3	1	_updateUserRewards	Arithmetic Precision Loss	In the _updateUserRewards function, you are calculating the accumulated rewards for a user. The calculation involves a division operation at the end (`_balanceOf[user] * (rewardsPerToken_.accumulated - userRewards_.checkpoint) / 1e18`). This operation might lead to a precision loss because of the integer division, which in turn might lead to small inaccuracies in the rewards assigned to a user. This issue might be insignificant for large balances and rewards but could potentially be more noticeable for small balances and rewards.
17_3	1	_updateRatios	Erroneous order of calculations	In the `_updateRatios` function, the `tolerance` argument is compared against the result of calculations involving `check` variable. However, `check` is calculated by subtracting `_ratio` from `chainRatios[i].div(CHAIN_FACTOR)`. This can potentially lead to an underflow if `_ratio` is greater than `chainRatios[i].div(CHAIN_FACTOR)`. To fix this, it would be advisable to ensure `_ratio` is always less than or equal to `chainRatios[i].div(CHAIN_FACTOR)`.
17_3	2	setBasisPointsLmit	Incorrect variables	The function name `setBasisPointsLmit` appears to be a typo. It should be `setBasisPointsLimit`.
17_3	3	stableToUsd	Unexpected values	The `stableToUsd` function calculates LP amount by calling `curvePool.calc_token_amount(_tokenAmounts, deposit)`, but there's no guarantee that the `deposit` variable will always be `true` when it should be for deposit operations. Incorrect value for `deposit` variable can lead to unexpected results.
17_3	4	poolBalances	Incorrect variables	In the `poolBalances` function, the `_balances` array is returned as `balances`. This is unnecessary and potentially confusing. The function should just return `_balances` directly.
29_2	null
29_2	null
29_2	null
25_2	null
25_2	null
25_2	null
17_2	null
16_3	null
16_3	null
16_3	null
16_3	null
16_2	null
16_2	null
16_2	2	latestAnswer	Cases with unexpected values	The function `latestAnswer` doesn't check if the `gasPrice` or `ethPrice` is zero before performing multiplication. This could potentially lead to an unexpected zero output if the oracles do not behave as expected.
16_2	3	toWad	Deviating Semantics	The `toWad` function expects the oracle to provide the correct decimal count. If the oracle behaves in a malicious or unexpected way, it could potentially break the contract logic. While you do check that `_decimals <= MAX_DECIMALS`, it would be better to also check that `_decimals` is not less than a reasonable minimum (e.g., 0).
16_2	1	minimumMargin	Cases with unexpected values	The function `minimumMargin` doesn't check if `maximumLeverage` is zero before performing division. This could potentially lead to a division by zero error if `maximumLeverage` is not properly validated.
16_2	2	wadToToken	Incorrect order of calculations	The function `wadToToken` performs division before multiplication. If `wadAmount` is less than `scaler`, it will return 0 due to the integer division. It might be better to perform multiplication first to maintain precision and then perform division.
14_2	null
14_2	null
8_2	null
5_3	1	calcSwapOutput, calcSwapFee, calcLiquidityUnits, getSlipAdustment, and others	Integer Division Precision Loss	In Solidity, division of integers results in the removal of the remainder, which can lead to precision loss. This is prevalent in your contract where you're calculating shares, fees, and other values. To ensure the correct values, you might want to use a library like OpenZeppelin's SafeMath, or handle precision appropriately in your calculations.
5_3	2	Various	Potential Re-Entrancy	While there are no explicit external calls that could lead to re-entrancy, the contract is calling multiple external contracts (iVADER, iROUTER, etc.). If any of these contracts have functions that could call back into this contract, it could potentially lead to re-entrancy attacks. Consider using the Checks-Effects-Interactions pattern to prevent this.
5_3	3	init	Lack of Input Validation	The 'init' function does not check if the input addresses are valid (non-zero) before assignment. This could lead to unexpected behavior if the function is called with invalid addresses.
5_3	4	isBase, isPool	Variable Shadowing	In the 'isBase' and 'isPool' functions, the return variables 'base' and 'pool' are not explicitly set in all paths, leading to potential variable shadowing and unexpected return values.
5_3	1	`_removeLiquidity`, `swap`, `burnSynth`, `lockUnits`, `unlockUnits`, `transferOut`	Integer Overflow / Underflow**	The mentioned functions make use of subtraction for calculation which is vulnerable to underflow if the subtrahend is greater than the minuend. The Solidity version 0.8.0 has built-in checks for arithmetic underflow or overflow, but it is always better to have an explicit check for such conditions.
5_3	2	`transferOut`	Unchecked External Call**	In the `transferOut` function, the external call to `iERC20(_token).transfer(_recipient, _amount)` is not checked for its return status. ERC20 `transfer` function returns a boolean status which should be checked to ensure the transfer was successful.
5_3	3	`removeLiquidity`, `removeLiquidityDirectly`, `swap`, `burnSynth`, `transferOut`	Reentrancy**	The mentioned functions make external calls to untrusted contracts (ERC20 token contracts) and may potentially allow for reentrancy attacks. Though the reentrancy attack is mitigated in Solidity 0.8.x due to the change in the gas rules, it is still recommended to use checks-effects-interactions pattern or a reentrancy guard for better security.
5_3	4	`init`, `addLiquidity`, `removeLiquidity`, `removeLiquidityDirectly`, `swap`, `sync`, `deploySynth`, `mintSynth`, `burnSynth`, `syncSynth`, `lockUnits`, `unlockUnits`	Missing Function Access Modifiers**	The mentioned functions are public or external but don't have any access control modifiers such as `onlyOwner` or `onlyAuthorized`. This could potentially allow any address to call these functions and manipulate the contract state.
5_3	5	`addLiquidity`, `removeLiquidity`, `removeLiquidityDirectly`, `swap`, `sync`, `deploySynth`, `mintSynth`, `burnSynth`, `syncSynth`, `lockUnits`, `unlockUnits`	No Input Validation**	The mentioned functions do not have any input validation. It's always a good practice to validate function parameters to avoid unexpected situations.
5_3	6	`swap`, `mintSynth`, `burnSynth`	Potential Front-running**	The functions handle token transfers based on input data without any protection against front-running. This could potentially allow an attacker to execute a transaction before the user's transaction gets mined, affecting the outcome of the user's transaction.
5_3	7	`init`	Uninitialized Storage Pointers**	The contract does not initialize its storage pointers (VADER, USDV, ROUTER, FACTORY) in its constructor but instead in the `init` function. This is a bad practice as it exposes the contract state to manipulation before the `init` function is called.
5_2	1	addLiquidity	Uninitialized variable usage	The contract uses the uninitialized variable `_actualInputBase` within the `addLiquidity` function. This could potentially lead to incorrect calculations or unexpected behavior.
5_2	2	sync	Incomplete function implementation	In the `sync` function, there's an unfinished condition branch for `isSynth()`. This might cause unexpected behavior if this condition should be handled in a certain way. This can be considered an incomplete function implementation bug.
5_2	3	addLiquidity, removeLiquidityDirectly, _removeLiquidity, etc.	No input validation	There is no input validation for the external functions. This might lead to unexpected behaviors when the function parameters are not as expected. For example, the `addLiquidity` function does not validate if `base` and `token` are valid token addresses.
5_2	4	_removeLiquidity	Potential re-entrancy bug	In the `_removeLiquidity` function, the contract calls `transferOut` to an arbitrary address before it finishes updating its state. This could potentially open up a re-entrancy vulnerability if the recipient contract calls back into the contract.
5_2	5	lockUnits, unlockUnits	Lack of access control	The functions `lockUnits` and `unlockUnits` can be called by any external caller without any restrictions. This can lead to unauthorized changes to the contract's state.
5_2	1	calcValueInBase	Possible Division by Zero Error	The function `calcValueInBase` can potentially encounter a division by zero error. The function retrieves pool amounts `_baseAmt` and `_tokenAmt` from `getPoolAmounts`. If `_tokenAmt` is ever zero, then the subsequent calculation `(amount * _baseAmt) / _tokenAmt;` would lead to a division by zero error. There should be a condition to check if `_tokenAmt` is zero before performing the division.
5_2	2	calcValueInToken	Possible Division by Zero Error	Similar to the `calcValueInBase` function, the `calcValueInToken` function can potentially encounter a division by zero error. If `_baseAmt` is ever zero, then the subsequent calculation `(amount * _tokenAmt) / _baseAmt;` would lead to a division by zero error. There should be a condition to check if `_baseAmt` is zero before performing the division.
5_2	3	calcSwapOutput	Possible Division by Zero Error	The function `calcSwapOutput` can potentially encounter a division by zero error. If `x` and `X` are both zero, then the denominator calculation `(x + X) * (x + X)` would result in zero, leading to a division by zero error when calculating `numerator / denominator`. There should be a condition to check if `(x + X)` is zero before performing the division.
5_2	4	calcSwapFee	Possible Division by Zero Error	The function `calcSwapFee` can potentially encounter a division by zero error. If `x` and `X` are both zero, then the denominator calculation `(x + X) * (x + X)` would result in zero, leading to a division by zero error when calculating `numerator / denominator`. There should be a condition to check if `(x + X)` is zero before performing the division.
5_2	5	calcSwapSlip	Possible Division by Zero Error	The function `calcSwapSlip` can potentially encounter a division by zero error. If `x` and `X` are both zero, then the denominator calculation `(x + X)` would result in zero, leading to a division by zero error when calculating `(x*10000) / (x + X)`. There should be a condition to check if `(x + X)` is zero before performing the division.
3_2	null
3_2	null
3_2	1	`_makeHourlyBond`	Arithmetic Overflow/Underflow	In the `_makeHourlyBond` function, the `bond.amount` and `lendingMeta[issuer].totalLending` are incremented by `amount`. In Solidity, if these variables are already at their maximum value, this addition could lead to an overflow, resetting the value to zero, which could lead to erroneous behavior. The same issue applies for underflow when subtracting `amount` in the `_withdrawHourlyBond` function.
3_2	2	`updateHourlyBondAmount`	Arithmetic Overflow/Underflow	The same issue applies in the `updateHourlyBondAmount` function where `deltaAmount = bond.amount - oldAmount` and `lendingMeta[issuer].totalLending += deltaAmount;` could cause an overflow or underflow.
3_2	3	`getUpdatedHourlyYield`	Unchecked External Call	The function `getUpdatedHourlyYield` involves a complex calculation and updates to various parameters. If any of these internal calls fail, it will stop the execution of the contract. This could be mitigated by using checks, effects, and interactions pattern in Solidity.
3_2	4	`calcCumulativeYieldFP`	Uncontrolled loop iteration	In the function `calcCumulativeYieldFP`, there is a loop that runs based on the `hoursDelta` value which is calculated from user input `timeDelta`. If the `hoursDelta` value is large, the loop may consume an excessive amount of gas, which may result in an out-of-gas error. It may also allow for a potential Denial-of-Service (DoS) attack.
3_2	5	`getUpdatedHourlyYield`, `calcCumulativeYieldFP`	Magic numbers	In several places in the code, there are hardcoded values (like `FP32`, `1 hours`, `100`). These are often referred to as "magic numbers" and are generally discouraged because they can make code harder to understand and maintain. It would be better to declare these as named constants at the top of the contract.
3_2	null
