191_3	null
190_3	1	hook	User period reset issue	The hook function does not correctly reset the user period. It sets the lastUserPeriodReset to the current block timestamp, but it should be set for each user individually. This leads to incorrect behavior where a reset affects all users rather than being specific to each user.
190_3	2	hook	Integer underflow	In the hook function, there is an integer underflow risk when calculating the fee using "_fee = _amountBeforeFee - _amountAfterFee;". If _amountAfterFee is greater than _amountBeforeFee, it will cause an integer underflow.
190_3	3	setTreasury, setTokenSender	Incorrect access control	The setTreasury and setTokenSender functions are declared as public, which allows anyone to call them. However, these functions should be limited to only authorized roles. To fix this issue, change the function visibility from public to external.
192_1	null
191_1	1	winnerClaimNFT	Re-entrancy vulnerability	The winnerClaimNFT function is vulnerable to a re-entrancy attack. The function calls an external contract (IERC721EnumerableUpgradeable) to transfer the NFT to the winner before emitting the WinnerSentNFT event. A malicious user could exploit this vulnerability by creating a contract that re-enters the winnerClaimNFT function during the transfer of the NFT, potentially enabling them to claim the NFT multiple times.
191_1	3	initialize	Unchecked external call return values	The initialize function checks if the provided NFT and drawing token contract addresses are contracts by checking their `code.length`. However, this is not a reliable way to check if an address is a contract, as it only checks if there's code associated with the address, but does not guarantee it's a valid contract. A more reliable way is to use the `extcodesize` assembly function. Replace the existing checks with a helper function that uses `extcodesize`:
190_1	1	hook	Incorrect implementation of user-specific period resets	The implementation of user-specific period resets in the `hook` function has a bug. The `lastUserPeriodReset` variable is shared among all users, so when any user resets their period, it resets for everyone else as well. This can lead to incorrect enforcement of user withdrawal limits.
115_3	null
113_3	1	repay	Reentrancy	The `repay` function transfers the funds before updating the state of the loan, which can potentially lead to a reentrancy attack. An attacker can create a malicious contract that can re-enter the `repay` function, making it possible to withdraw the collateral multiple times. To fix this, the state of the loan should be updated before transferring the funds.
113_3	2	calculateInterest	Integer overflow	In the `calculateInterest` function, there is a possibility of integer overflow. When calculating the interest, the function does not check if the resulting interest is greater than or equal to 2**128, which may lead to an overflow. To fix this, the function should include a check to ensure that the resulting interest does not exceed the maximum possible value.
113_3	3	requestAndBorrow	Potential for front-running attacks	The `requestAndBorrow` function is susceptible to front-running attacks. An attacker can monitor pending transactions and submit a transaction with a higher gas price to take advantage of a favorable lending opportunity before the original borrower. To mitigate this, an off-chain order matching system can be used to prevent front-runners from benefiting from these opportunities.
113_3	4	updateLoanParams	Potential for manipulation of loan parameters	In the `updateLoanParams` function, a borrower or lender can change the loan parameters (valuation, duration, and annualInterestBPS) after the loan has been requested but before it has been accepted. This could be used to manipulate the terms of the loan and exploit the other party. To fix this issue, a more robust validation mechanism should be implemented to ensure that the loan parameters cannot be changed after the loan has been requested.
109_3	1	_burnTokenFrom	Reentrancy	The '_burnTokenFrom' function calls the external contract IERC20(tokenAddress) using low-level 'call()' method, which may make it susceptible to reentrancy attacks. An attacker could potentially call back into the contract before the state is updated, leading to undesirable results or double spends. To mitigate this issue, consider using the 'Checks-Effects-Interactions' pattern, where the state is updated before calling external contracts, or using the 'ReentrancyGuard' modifier from OpenZeppelin.
109_3	2	admins	Denial of Service (DoS)	The 'admins' function iterates through the list of admins using a for loop. If the list of admins grows too large, the function may require a significant amount of gas to execute, which could result in a denial of service (DoS) attack. To mitigate this issue, consider implementing a pagination mechanism to return admins in smaller subsets, or utilize a mapping with an index to access the list of admins directly.
109_3	3	N/A	Missing input validation	The 'sendToken' and 'callContractWithToken' functions take 'destinationChain' and 'destinationAddress' as input parameters. However, there is no validation on the input strings, which could potentially lead to unexpected behavior or security issues. It's recommended to add input validation checks to ensure that the provided strings are in the correct format.
145_1	null
145_1	null
131_1	1	_executeInflationRateUpdate()	Incorrect Inflation Decay Calculation	In the _executeInflationRateUpdate() function, the inflation decay calculations do not properly consider the time since the last decay. The code updates the inflation amounts using the annual decay rate, regardless of the actual time passed since the last decay. This can lead to incorrect inflation rate updates.
131_1	2	setToken()	Missing Token Initialization Check	In the setToken() function, there is a check to ensure that the token address has not already been set. However, there is no check to ensure that the provided token address is not the zero address. A zero address could be accidentally set as the token address, leading to a broken contract state.
131_1	3	_mint()	Inaccurate Total Supply	In the _mint() function, the totalAvailableToNow variable is updated before the new tokens are minted. However, the update for the totalAvailableToNow variable should be after the minting of new tokens. Otherwise, it may lead to an inaccurate representation of the total supply.
122_1	1	getDutchAuctionStrike	Integer Overflow	The multiplication of `progress` by itself can potentially cause an integer overflow. It is safer to use the SafeMath library to perform arithmetic operations, especially when dealing with user inputs or external data.
122_1	2	withdraw	Re-entrancy	The `withdraw` function is potentially vulnerable to re-entrancy attacks due to the call to `harvest()` before transferring the token. A re-entrancy attack can occur if the attacker can call the function again before the execution is complete. The `harvest()` function should be called after transferring the tokens to mitigate this vulnerability.
122_1	3	buyOption	Front-running	The `buyOption` function is potentially vulnerable to front-running attacks. An attacker can observe the transaction pool and submit a transaction with a higher gas price to buy an option before the original user. It is recommended to implement a commit-reveal scheme or other mechanisms to mitigate front-running attacks.
122_1	4	transferFrom	Improper Access Control	In the `transferFrom` function, the access control checks for the `from` address are insufficient. An attacker can potentially bypass the access control by setting the `from` address to the contract address or other addresses that they control. It is advised to strengthen the access control checks and validate that the `from` address is not the contract address or other addresses controlled by the attacker.
115_1	1	depositToVault	Access Control	The depositToVault function does not have any access control mechanism like the onlyOwner modifier. It allows anyone to deposit assets to the contract, which could lead to potential issues if an unauthorized user deposits assets.
115_1	2	executeOperation	Reentrancy	The function executeOperation is vulnerable to reentrancy attacks. It performs external calls to the lendingPool contract and other external contracts. A malicious contract can take advantage of this vulnerability by re-entering the SuperVault contract before the state is updated. To mitigate this vulnerability, you can use the Checks-Effects-Interactions pattern and consider adding a reentrancy guard to the function.
115_1	3	leverageSwap, aggregatorSwap	Integer Overflow/Underflow	In functions leverageSwap and aggregatorSwap, token.approve is called with the argument 2**256 - 1. This value is quite large and could potentially cause integer overflow/underflow issues if not handled properly. It is recommended to use SafeMath or Solidity's built-in checked arithmetic to prevent these issues.
115_1	4	aggregatorSwap	Unchecked Return Values	In the function aggregatorSwap, the low-level call router.call(dexTxData) is used, but the return value is not checked for success. If the call fails, it will silently continue the execution without any errors. It is advisable to check the return value and revert the transaction with a meaningful error message in case of failure. You can use require() to check the return value.
115_1	5	leverage, rebalance, emptyVault	Lack of input validation	In functions leverage, rebalance, and emptyVault, user inputs are passed directly to the external functions without any validation. This can lead to potential vulnerabilities if malicious users provide malformed input data. It is recommended to validate the inputs before passing them to external functions.
113_1	1	repay	Reentrancy	In the `repay` function, external calls to `bentoBox.transfer` are made before the loan state is updated (with `delete tokenLoan[tokenId]`). A malicious contract could call back into the `repay` function during the external call, potentially leading to unexpected behavior. To mitigate this, consider using the Checks-Effects-Interactions pattern and update the state before making external calls.
113_1	2	requestLoan, lend	Front-running	In the `requestLoan` and `lend` functions, the borrower or lender may be subject to front-running attacks by malicious miners or other users who can observe the transactions in the mempool. They can submit their own transaction with a higher gas price to have it mined before the original transaction. This can lead to unexpected behavior for the users. To mitigate this, consider using a commit-reveal scheme to prevent front-running.
113_1	3	updateLoanParams	Improper input validation	In the `updateLoanParams` function, the user can update the loan parameters, but there is no check to ensure that the values are within an acceptable range or non-zero. This can lead to unintended behavior or exploitation. To mitigate this, add proper input validation and constraints on the values for `params.duration`, `params.valuation`, and `params.annualInterestBPS`.
113_1	4	calculateInterest	Integer underflow	In the `calculateInterest` function, the variable `denom_k` may underflow if the value of `YEAR_BPS` is large enough. To mitigate this issue, consider using the SafeMath library or similar solutions to handle integer operations safely.
113_1	5	removeCollateral	Unprotected function calls	In the `removeCollateral` function, the call to `collateral.transferFrom` is not protected by a reentrancy guard. This can potentially allow reentrancy attacks to occur. Consider adding a reentrancy guard, such as a mutex or the ReentrancyGuard from OpenZeppelin, to prevent reentrancy attacks.
113_1	6	N/A	Lack of circuit breaker	There is no emergency stop mechanism or circuit breaker implemented in the smart contract. In case of a bug or security issue, there is no way to pause the contract or stop certain functions from being executed. Consider implementing a circuit breaker pattern to handle emergency situations.
109_1	null
97_3	1	deposit	Incorrect token approval check	The deposit function checks if the token is approved for transfer using both `isApprovedForAll` and `getApproved`. However, it should only use `isApprovedForAll` for checking if the contract is approved to manage all of the user's tokens, and `getApproved` for checking if the contract is approved to manage a specific token.
97_3	2	reclaimTokens	Reentrancy vulnerability	The reclaimTokens function is marked as nonReentrant. However, it allows the contract owner to withdraw tokens from the contract. This could potentially be exploited by a malicious contract owner to withdraw rewards before users have a chance to claim them. Consider adding proper access control and checks to prevent such an exploit.
97_3	3	withdraw	Inefficient loop for searching NFTs	The withdraw function has a loop that searches for the NFT ID in the user's nftIdsStaked mapping. This loop may become inefficient as the number of NFTs staked by a user increases. Consider using a better data structure or strategy to optimize this lookup process.
97_3	4	getUpdatedAccTokenPerShare	Overflow risk	In the getUpdatedAccTokenPerShare function, there is a potential for overflow when calculating the accumulator. Consider using SafeMath or built-in overflow checks to prevent overflow.
97_3	5	_sendErc20AndGetSentAmount	Incorrect handling of native tokens	The function _sendErc20AndGetSentAmount is used for sending ERC20 tokens but is also used to calculate the sent amount for native tokens. This should be handled separately for native tokens (ETH), as the function is not designed to handle them.
83_3	1	_calcRewardIntegral	Incorrect calculation of user rewards	In the `_calcRewardIntegral` function, the user rewards are calculated using the formula `(_balance * (reward.integral - userI)) / 1e20`. However, this calculation can lead to incorrect user rewards due to the potential for rounding errors, especially when dealing with small token amounts or balances. To improve the accuracy of the reward calculation, it is suggested to use a more precise formula or library that handles such calculations with greater precision.
83_3	2	deposit	Potential reentrancy attack	In the `deposit` function, the contract interacts with the external `masterChef` contract after updating the user's deposit state. Since the state update occurs before the external interaction, it may expose the contract to a reentrancy attack. To mitigate this risk, the state update should be moved to the end of the function after interacting with the external contract.
83_3	3	requestWithdraw	Missing input validation	In the `requestWithdraw` function, the `_amount` parameter is not checked for being non-zero. A user could potentially request a withdrawal of 0 tokens, which would result in unnecessary gas usage and state changes. It is suggested to add a require statement to check that the `_amount` is greater than 0.
83_3	4	addRewards	Unsafe external contract interaction	In the `addRewards` function, the contract interacts with multiple external contracts without checking their addresses for validity. This could potentially expose the contract to attacks if the external contracts are malicious or compromised. To mitigate this risk, it is suggested to validate the addresses of external contracts before interacting with them.
83_3	null
103_1	1	swapTokensGeneric	Reentrancy	The `swapTokensGeneric` function is vulnerable to reentrancy attacks because it calls an external contract (via `_executeSwaps` function) before transferring the `postSwapBalance` to the `msg.sender`. A malicious contract may exploit this vulnerability by calling back into the `swapTokensGeneric` function before the `LibAsset.transferAsset` has executed, leading to unexpected behavior or loss of funds.
103_1	1	swap	Reentrancy	The `swap` function in the `LibSwap` library is vulnerable to reentrancy attacks because it calls an external contract (via low-level `call` function) before updating the state (such as token balances) and emitting the `AssetSwapped` event. A malicious contract may exploit this vulnerability by calling back into the `swap` function before the state is updated and the event is emitted, leading to unexpected behavior or loss of funds.
98_1	null
98_1	1	executeMetaTransaction	Reentrancy	In the `executeMetaTransaction` function, a call is made to another contract using `address(this).call()`. This external call can potentially allow the callee to re-enter the contract and execute the same function again before the state is updated, leading to reentrancy attacks. To mitigate this vulnerability, consider using the Checks-Effects-Interactions pattern by updating the state before making the external call.
98_1	2	executeMetaTransaction	Front-running	The `executeMetaTransaction` function is vulnerable to front-running attacks. An attacker can observe a pending meta transaction and create another transaction with a higher gas price, causing their transaction to be mined before the original transaction. This can potentially cause the original transaction to fail, as the nonce will be outdated when it is eventually processed. To mitigate this issue, consider implementing a commit-reveal scheme to prevent front-running or using a decentralized oracle service to ensure transaction ordering.
98_1	3	executeMetaTransaction	Incorrect nonce update	The nonce update in the `executeMetaTransaction` function has an unchecked overflow, which can potentially lead to incorrect nonce values after 2 ^ 256 - 1 transactions. Although it is unlikely for a user to make such a large number of transactions, it is still recommended to handle nonce updates with proper overflow checks using SafeMath or Solidity's built-in overflow checking features.
97_1	1	reclaimTokens	Reentrancy vulnerability	The `reclaimTokens` function has the `nonReentrant` modifier, which should prevent reentrancy attacks. However, it is still important to note that this function allows the owner to withdraw any tokens held by the contract, including potential reward tokens. In a malicious scenario, the owner could drain the contract of rewards or other assets, making it impossible for users to claim their rewards. To mitigate this, the contract could implement checks to prevent withdrawal of specific tokens or have separate functions for withdrawing different types of tokens.
97_1	2	_sendErc20AndGetSentAmount, _sendRewardsForNft	Integer underflow	The `_sendErc20AndGetSentAmount` function calculates the sent amount using subtraction, which can lead to an integer underflow if the recipient's balance after the transfer is less than the initial balance. Similarly, the `_sendRewardsForNft` function has an unchecked block, which can lead to integer underflow in case the `pending` amount is less than the `balance`. To fix this, it is recommended to use the `SafeMath` library for performing arithmetic operations or checking for underflows explicitly.
97_1	3	initalizeRewardPool	Incorrect pool initialization	The `initalizeRewardPool` function can be called by the owner to initialize a reward pool with a specific base token, reward token, and reward per second. However, the function does not check if the base token is different from the reward token, which could lead to unexpected behavior if the same token is used for both. To prevent this, an additional check should be added to ensure the base token and reward token are different.
97_1	4	withdraw	Unbounded loop	The `withdraw` function has a loop that iterates through all the staked NFTs for a user to find the index of the NFT to be withdrawn. This loop can cause gas usage to increase with the number of NFTs staked by a user, potentially making the function unusable for users with many staked NFTs. A possible solution is to maintain a mapping of NFT IDs to their indices in the `nftIdsStaked` array, allowing for a constant-time lookup instead of an unbounded loop.
83_1	1	deposit	Reentrancy	The `deposit` function is exposed to a potential reentrancy vulnerability. The external calls to `IERC20.safeTransferFrom`, `IERC20.safeApprove`, `IConvexDeposits.deposit`, and `MasterChef.deposit` are made before updating the state of the contract. This can potentially allow an attacker to re-enter the contract and manipulate the state before the original transaction has completed. While the contract utilizes the ReentrancyGuard, it is recommended to move these external calls to the end of the function to minimize the risk of reentrancy attacks.
83_1	2	addRewards	Access Control	The `addRewards` function is marked as public but should be restricted to onlyOwner, since it allows anyone to call the function and potentially manipulate the contract state. To fix this, the function should be modified to include the `onlyOwner` modifier, like this: `function addRewards(uint256 _pid) public onlyOwner`.
83_1	3	_calcRewardIntegral	Integer Overflow/Underflow	The `_calcRewardIntegral` function uses unchecked arithmetic operations, which could potentially lead to integer overflow or underflow issues. To prevent this, the SafeMath library should be used for arithmetic operations, or since Solidity 0.8.0 and above, the built-in overflow and underflow checks can be relied upon, ensuring that any potential issues will result in a revert.
83_1	4	constructor	Incomplete Contract Initialization	In the `constructor` function, the `_claimContract` parameter is missing from the function arguments, and the claimContract is never initialized. To fix this, add the `_claimContract` parameter to the constructor and initialize the claimContract with it, like this:
83_1	5	N/A	Use of Magic Numbers	The contract uses magic numbers like "1e20", "2 weeks", and "5". These numbers should be replaced with named constants to make the code more readable and maintainable. For example, you could replace "1e20" with a constant named "REWARD_SCALING_FACTOR", "2 weeks" with a constant named "VOTE_CYCLE_DURATION", and "5" with a constant named "TREASURY_REWARD_PERCENTAGE".
83_1	null
69_3	1	mintAndSell721, mintAndSell721WETH, buyAndSwap721, buyAndSwap721WETH, buyAndRedeem, buyAndRedeemWETH, mintAndSell1155, mintAndSell1155WETH	Reentrancy vulnerability	Though the smart contract has implemented a ReentrancyGuard, it may still be vulnerable to reentrancy attacks in functions that allow external calls such as transfer(), transferFrom(), or call(). In this contract, multiple functions use nonReentrant modifier, but they also call external functions like `transfer`, `transferFrom`, `call`, `deposit`, and `withdraw` on various token contracts. This may introduce a potential reentrancy vulnerability. It is recommended to ensure the state changes are made before making any external calls to reduce the risk of reentrancy attacks.
69_3	2	_mint721, _mint1155	Insufficient validation checks	In the _mint721 and _mint1155 functions, the contract checks if the vault address is not equal to the zero address. However, this may not be sufficient to ensure the safety of these functions. It is recommended to add more validation checks such as verifying if the NFT IDs are valid, if the NFTs are owned by the caller, and if the amounts specified in the function call are within acceptable limits.
69_3	3	mintAndSell721, mintAndSell721WETH, buyAndSwap721, buyAndSwap721WETH, buyAndRedeem, buyAndRedeemWETH, mintAndSell1155, mintAndSell1155WETH	Potential frontrunning vulnerability	Transactions in Ethereum are public, and miners can choose the order of transactions within a block. This can lead to frontrunning, where a malicious user observes a pending transaction and submits their own transaction with a higher gas price, effectively "jumping the queue" and executing their transaction first. In this contract, functions like `mintAndSell721`, `mintAndSell721WETH`, `buyAndSwap721`, `buyAndSwap721WETH`, `buyAndRedeem`, `buyAndRedeemWETH`, `mintAndSell1155`, and `mintAndSell1155WETH` are susceptible to frontrunning as they involve trading of assets. Using commit-reveal schemes or other methods to mitigate frontrunning risks is recommended.
69_3	1	addLiquidity721ETHTo	Reentrancy vulnerability	The function 'addLiquidity721ETHTo' is marked as nonReentrant. However, a reentrancy vulnerability still exists due to the use of the 'call' function in the 'transferFromERC721' function. An attacker could potentially exploit this vulnerability to manipulate the state of the contract.
69_3	2	transferFromERC721	Incorrect approval check in 'transferFromERC721'	The 'transferFromERC721' function checks for ownership of the CryptoKitties and CryptoPunks NFTs but doesn't check for approvals before attempting to transfer them. An attacker could potentially use this oversight to manipulate the state of the contract and cause unexpected behavior.
69_3	3	_addLiquidity721WETH, _addLiquidity1155WETH	Unbounded loop	The '_addLiquidity721WETH' and '_addLiquidity1155WETH' functions contain loops that iterate through the input arrays. The size of the input arrays is not limited, which can lead to high gas costs and potential denial of service attacks.
68_3	1	joinPool	Integer division	In the joinPool function, there is an integer division when calculating the tokenAmount. This can cause a loss of precision, which can lead to small inaccuracies in the token calculations.
68_3	2	calcTokensForAmount	Integer division	In the calcTokensForAmount function, there is an integer division when calculating the tokenAmount. This can cause a loss of precision, which can lead to small inaccuracies in the token calculations.
68_3	3	calcTokensForAmountExit	Integer division	In the calcTokensForAmountExit function, there is an integer division when calculating the tokenAmount. This can cause a loss of precision, which can lead to small inaccuracies in the token calculations.
78_1	1	transferAndCall	Double transfer	In the `transferAndCall` function, there is a double transfer happening, which can result in an unintended double transfer of tokens. The function first calls `super.transfer(_to, _value)` and then `_transfer(msg.sender, _to, _value)`, essentially transferring the tokens twice to the recipient.
78_1	2	transferAndCall	Reentrancy vulnerability	The `transferAndCall` function calls an external contract `IERC677Receiver` via the `contractFallback` function, which can be a potential reentrancy vulnerability. If the called contract has malicious code, it could call back into the `transferAndCall` function before the first call is completed, leading to unexpected behavior or exploits.
73_1	3	migrateETH, migrateLPT	Missing access control	The functions `migrateETH` and `migrateLPT` do not have any access control mechanism, allowing any external actor to call them. Although it might not cause a severe vulnerability, it's essential to restrict access to these functions to avoid unexpected behavior or misuse.
73_1	4	N/A	Front-running vulnerability	This smart contract does not implement any mechanism to prevent front-running attacks, where an attacker could observe transactions in the mempool and submit their transactions with higher gas prices to gain an advantage. Since this contract deals with value transfers and migrations, front-running could lead to financial losses for users.
70_1	1	mintSynth, burnSynth, mintFungible, burnFungible	Reentrancy	The smart contract has used the `nonReentrant` modifier in `mintSynth`, `burnSynth`, `mintFungible`, and `burnFungible` functions to prevent reentrancy attacks. The use of the `nonReentrant` modifier is a good practice to mitigate potential reentrancy vulnerabilities.
70_1	3	initialize, setQueue, setTokenSupport, setGasThrottle, setFungibleTokenSupport	Access Control	The smart contract uses the `onlyOwner` modifier in the `initialize`, `setQueue`, `setTokenSupport`, `setGasThrottle`, and `setFungibleTokenSupport` functions. This ensures that only the owner of the contract can execute these functions, providing proper access control.
70_1	5	mintSynth, burnSynth, mintFungible, burnFungible	Front-running	The `mintSynth`, `burnSynth`, `mintFungible`, and `burnFungible` functions are vulnerable to front-running attacks, as they involve token transfers and swaps. Miners or attackers with knowledge of pending transactions can manipulate the order of transactions to their advantage. To mitigate this issue, a commit-reveal scheme or using an off-chain solution like zk-rollups or optimistic rollups can be considered.
70_1	2	_castVote	Integer overflow/underflow	Although the contract uses Solidity version 0.8.9, which has built-in overflow/underflow protection, there is still a possible integer overflow in the _castVote function. Unchecked blocks are used when updating the proposal.forVotes and proposal.againstVotes, which could lead to an integer overflow.
70_1	5	cancel	Incorrect access control	The cancel function can only be called by the guardian. However, it might be more appropriate to allow the proposer of the proposal to cancel it, as long as certain conditions are met (e.g., the proposal is still pending or active). By only allowing the guardian to cancel proposals, the contract might concentrate too much power in the hands of the guardian.
70_1	1	_addVaderPair, _addUSDVPair	Incorrect update period validation	In both functions _addVaderPair and _addUSDVPair, the updatePeriod is checked to ensure that it is not zero. However, there is no upper bound check for the updatePeriod, which could lead to excessive update periods and potential abuse or incorrect price updates.
70_1	2	_updateVaderPrice, _updateUSDVPrice	Unchecked underflow	In the functions _updateVaderPrice and _updateUSDVPrice, the code calculates the nativeTokenPriceAverage by subtracting nativeTokenPriceCumulative from the pairData.nativeTokenPriceCumulative and then dividing the result by the timeElapsed. The subtraction is done using the "unchecked" block, which means that underflows can occur if nativeTokenPriceCumulative is less than pairData.nativeTokenPriceCumulative. Although unlikely, this could lead to an incorrect calculation of the nativeTokenPriceAverage and result in an inaccurate price update.
70_1	3	getChainlinkPrice	Stale price vulnerability	In the getChainlinkPrice function, the code retrieves the latest round data from the Chainlink oracle and checks if the answeredInRound is greater than or equal to the roundID. However, there is no check for how recent the answeredInRound is, meaning that if the price data has not been updated for a long time, the function may still return a stale price. This could lead to incorrect calculations and price updates in other functions where the getChainlinkPrice function is used.
70_1	4	constructor	No input validation for constructor	The constructor function does not have any input validation for the _vaderPool parameter. Although it checks that _vader is not the zero address, it only checks that _vaderPool is not equal to IVaderPoolV2(address(0)) which is not a sufficient check for input validation. This could lead to potential issues if an incorrect or malicious contract is passed as the _vaderPool parameter.
69_1	2	buyAndSwap721, buyAndSwap721WETH, buyAndSwap1155, buyAndSwap1155WETH, buyAndRedeem, buyAndRedeemWETH, mintAndSell721, mintAndSell721WETH, mintAndSell1155, mintAndSell1155WETH	Front-running Attack	The smart contract uses Uniswap for buying and selling tokens, which can be susceptible to front-running attacks. An attacker can observe pending transactions and submit a transaction with a higher gas price, enabling them to execute their trade before the victim's transaction. As a result, the victim may receive less favorable exchange rates or fail to complete their intended transaction.
69_1	1	addLiquidity721ETHTo, addLiquidity1155ETHTo, addLiquidity721To, addLiquidity1155To	Reentrancy vulnerability	The `nonReentrant` modifier is used in these functions, which helps protect against reentrancy attacks. However, the use of `call` in the following lines may expose the contract to reentrancy vulnerabilities:
68_1	null
59_3	1	setThreshold	Incorrect error message	In the `setThreshold` function, the error message "Threshold must be between 0-100%" is incorrect, as the threshold must be between 0 (exclusive) and 10000 (inclusive), as per the condition `require(newThreshold > 0 && newThreshold < 10000, "Threshold must be between 0-100%");`.
59_3	2	setPool	Incorrect error message	In the `setPool` function, the error message "Cannot have 0 lookback" is incorrect, as the error is related to setting the pool address and not the lookback. The error message should be something like "Cannot have zero address pool."
59_3	3	setThreshold, setPriceLookback, setPool, addToWhitelist, removeFromWhitelist	Incorrect implementation of access control	In the functions `setThreshold`, `setPriceLookback`, `setPool`, `addToWhitelist`, and `removeFromWhitelist`, the custom `onlyRole` modifier is used to implement access control. However, the correct way to use this modifier is to pass only the role name as the first argument. The second argument (e.g., "Must have admin role") should be removed, as it serves no purpose in the current implementation. The correct usage should be `onlyRole(ADMIN_ROLE)`.
59_3	4	initialize	Missing input validation	In the `initialize` function, there is no validation on input parameters like `_thresholdBps`, `_maltDataLab`, `_lookback`, and `_pool`. There should be checks to ensure that these values are within the expected range and not equal to zero (or the zero address, in the case of `_maltDataLab` and `_pool`). For example, there should be a check to ensure that `_thresholdBps` is between 0 (exclusive) and 10000 (inclusive), similar to the check in the `setThreshold` function.
59_3	3	buyMalt, sellMalt, addLiquidity, removeLiquidity	Unchecked Return Values	The contract does not check the return values from the calls to router.swapExactTokensForTokens() in buyMalt and sellMalt functions, and router.addLiquidity() and router.removeLiquidity() in addLiquidity and removeLiquidity functions. Although not a critical vulnerability, it is a best practice to check for return values to ensure the expected behavior.
59_3	4	buyMalt, sellMalt, addLiquidity, removeLiquidity	Timestamp Dependency	The contract uses the "now" keyword (alias for block.timestamp) as the deadline for the calls to router.swapExactTokensForTokens() in buyMalt and sellMalt functions, and router.addLiquidity() and router.removeLiquidity() in addLiquidity and removeLiquidity functions. This could potentially lead to minor manipulations by miners. It is better to use a user-provided timestamp or a relative time for these deadlines.
54_3	null
64_1	null
61_1	null
60_1	null
59_1	null
59_1	1	buyMalt	Front-running	The buyMalt function is vulnerable to front-running attacks. Attackers can observe the pending transaction in the mempool and submit their own transaction with a higher gas price, causing their transaction to be mined before the original transaction. This could lead to price manipulation and an unfair advantage for the attacker.
54_1	null
52_3	1	rescue	Incorrect Balance Check	The `rescue` function allows the contract owner to withdraw any "unaccounted" tokens that are not part of the reserveForeign. However, the function doesn't check whether the contract owner is the one invoking the function. It is possible that anyone can call this function and potentially withdraw the unaccounted tokens. To fix this issue, you can add a modifier like `onlyOwner` to ensure that only the contract owner can call the `rescue` function.
52_3	2	swap, doubleSwap	Front Running Vulnerability	The `swap` and `doubleSwap` functions are vulnerable to front running attacks. Miners or attackers can manipulate the order of transactions to execute a swap at a better price. This can lead to unfavorable trading conditions for regular users. To mitigate this issue, you can implement a price slippage protection mechanism that limits the price impact of a swap.
52_3	3	mint, _burn, swap, doubleSwap, _update	Integer Overflow and Underflow	There are potential integer overflow and underflow issues in the following functions: `mint`, `_burn`, `swap`, `doubleSwap`, and `_update`. You should use the SafeMath library to perform arithmetic operations, which provides built-in protection against integer overflow and underflow issues.
52_3	4	_supportedToken, _onlyRouter	Missing Function Access Control	The `_supportedToken` and `_onlyRouter` functions are private helper functions, but they are missing the `private` access modifier. To fix this issue, add the `private` access modifier to these functions to ensure that they can only be called from within the contract.
52_3	1	initialize	Incorrect Wrapper Initialization Check	The initialization function checks if `wrapper` is equal to the zero address instead of checking if it has already been initialized. This could potentially allow the contract to be re-initialized, leading to unexpected behavior.
52_3	2	setTokenSupport	Missing Input Validation	The `setTokenSupport` function does not check whether the provided `foreignAsset` is a valid token address (i.e., not the zero address). This could lead to accidentally setting the support status for an invalid token.
52_3	3	setFungibleTokenSupport	Missing Input Validation	The `setFungibleTokenSupport` function does not check whether the provided `foreignAsset` is a valid token address (i.e., not the zero address). This could lead to accidentally setting the support status for an invalid token or creating an LP wrapper for an invalid token.
52_3	4	burn	Loss of Funds	The `burn` function does not send the covered loss back to the user. The `coveredLoss` is calculated but not transferred, which could result in the loss of funds for the user.
52_3	5	toggleQueue	Incomplete Function	The `toggleQueue` function changes the state of `queueActive`, but there is no actual implementation to utilize the queue system. This function does not have any impact on the contract's behavior, and the queue system remains unused.
52_3	1	_swap	Incorrect Path Check	In the _swap function, the checks performed on the path array elements are insufficient. There is no validation to ensure that the tokens in the path array are supported by the Vader pools. A check using `pool.supported(token)` should be included for both foreign assets to ensure that the swap occurs only for supported tokens in the Vader pools.
52_3	2	removeLiquidity	Potential Reentrancy Attack	The removeLiquidity function calls the external reserve.reimburseImpermanentLoss function after transferring assets to the 'to' address. This external call can potentially be exploited in a reentrancy attack. To mitigate this issue, consider using the Checks-Effects-Interactions pattern, where the state changes are made before interacting with external contracts. This can be done by moving the reserve.reimburseImpermanentLoss call before the pool.burn call.
52_3	1	setTimelock	Incorrect function modifiers	The function 'setTimelock' should have the 'onlyGuardian' modifier, to ensure that only the guardian can set the timelock address. However, it currently does not have any modifier. This means that any address can potentially change the timelock address, which can lead to a security risk.
52_3	2	changeCouncil	No input validation	The function 'changeCouncil' should validate if the new council address (council_) is not a zero address. Currently, it does not check for this, which can lead to a scenario where the council address is unintentionally set to a zero address, causing loss of control over the council's functionality.
52_3	3	veto	Incomplete validation	The 'veto' function should validate that the proposal has not been executed or canceled before allowing it to be vetoed. Currently, it only checks if the proposal is in 'Active' or 'Pending' state, but it does not consider the 'canceled' or 'executed' state of the proposal. This can potentially lead to a scenario where a veto is performed on an already executed or canceled proposal, which should not be allowed.
52_3	4	changeFeeReceiver	No input validation	The function 'changeFeeReceiver' should validate if the new fee receiver address (feeReceiver_) is not a zero address. Currently, it does not check for this, which can lead to a scenario where the fee receiver address is unintentionally set to a zero address, causing loss of control over the fee receiver's functionality.
52_3	5	__queueSetTimelockPendingAdmin	No input validation	The function '__queueSetTimelockPendingAdmin' should validate if the new pending admin address (newPendingAdmin) is not a zero address. Currently, it does not check for this, which can lead to a scenario where the pending admin address is unintentionally set to a zero address, causing loss of control over the pending admin's functionality.
52_3	1	grant	Re-entrancy vulnerability	The 'grant' function has a re-entrancy vulnerability due to the lack of a reentrancy guard. The function transfers VADER tokens using the 'safeTransfer' function, which could potentially call back into the contract before the state is updated. This can be exploited by a malicious contract to repeatedly call the 'grant' function and drain the reserve.
52_3	2	reimburseImpermanentLoss	Re-entrancy vulnerability	The 'reimburseImpermanentLoss' function has a re-entrancy vulnerability due to the lack of a reentrancy guard. The function transfers VADER tokens using the 'safeTransfer' function, which could potentially call back into the contract before the state is updated. This can be exploited by a malicious contract to repeatedly call the 'reimburseImpermanentLoss' function and drain the reserve.
53_1	1	sendFees, sendFeesWithRoyalties	Incorrect implementation of SafeERC20	When using SafeERC20 library to handle ERC20 tokens, it should be used consistently throughout the entire contract. However, the `sendFees` and `sendFeesWithRoyalties` functions use `IERC20(_token).safeTransferFrom()` instead of `_token.safeTransferFrom()`. The correct usage should be `_token.safeTransferFrom(_msgSender(), address(this), _amount);`.
53_1	2	releaseToken, releaseETH, sendFees, sendFeesWithRoyalties	Reentrancy vulnerability	Although the contract uses the ReentrancyGuard modifier for these functions, it might not fully protect against reentrancy attacks. The event emissions (`PaymentReleased` and `PaymentReceived`) should be placed before the external calls or transfers, i.e., `_token.safeTransfer()`, `(bool success, ) = _msgSender().call{ value: amount }("")` and `IWETH(weth).withdraw(amount)` to avoid potential reentrancy vulnerabilities.
53_1	null
53_1	null
52_1	1	_burn	Reentrancy attack	The '_burn' function has the 'nonReentrant' modifier. However, the function makes external calls to 'nativeAsset.safeTransfer' and 'foreignAsset.safeTransfer' before updating the state variables 'reserveNative' and 'reserveForeign'. This can potentially allow a reentrancy attack to occur, as external calls can execute arbitrary code.
52_1	2	rescue	Missing input validation	The 'rescue' function does not have any access control, which means that anyone can call the function and potentially steal the unaccounted tokens. To prevent this, the function should have proper access control, like an 'onlyOwner' or 'onlyAdmin' modifier, to restrict the execution to authorized users only.
52_1	1	mintSynth	Uninitialized storage pointer	In the mintSynth function, when the synth does not exist, a new synth is created but the newly created synth is not assigned to the synth variable. This will lead to the usage of an uninitialized storage pointer in the subsequent code execution, which may result in unexpected behavior.
52_1	2	mintSynth, burnSynth, mintFungible, burnFungible	Front-running	The functions mintSynth, burnSynth, mintFungible, and burnFungible are susceptible to front-running attacks. Since these functions update the state of the contract and transfer assets, a malicious miner or user can monitor the pending transactions and insert their own transaction with a higher gas price to gain an advantage.
52_1	1	constructor	Incorrect initialization check	In the constructor, the check for the input _pool address uses an incorrect comparison to the zero address, which should be compared to the address(0).
52_1	2	ensure	Unsafe deadline check	The ensure modifier checks if the deadline has not passed with the expression "deadline >= block.timestamp". This can lead to incorrect results when the timestamp overflows. The check should be "block.timestamp <= deadline".
52_1	3	_swap	Lack of input validation	The _swap function does not perform input validation on the path array. It checks for path length and some specific conditions, but it does not verify if the addresses in the path array are valid ERC20 tokens. This might lead to incorrect behavior in case an invalid token address is provided.
52_1	4	addLiquidity (the second one)	Inefficient code	The addLiquidity function has two versions, one of which is just a wrapper for the other. The wrapper function is marked as "NOTE: For Uniswap V2 compliancy, necessary due to stack too deep", but it is not necessary, as the underlying addLiquidity function is already compliant with Uniswap V2. This leads to increased gas costs when using the wrapper function.
52_1	1	setTimelock	Incorrect access control	The `setTimelock` function should only be called by the guardian, but there is no access control to enforce this constraint. An attacker may be able to set a malicious timelock contract by calling this function.
52_1	2	execute	Reentrancy vulnerability	The `execute` function calls external contracts through `timelock.executeTransaction` in a loop, which can potentially lead to reentrancy attacks. An attacker might be able to manipulate the order of transactions and cause unexpected behavior.
52_1	3	changeFeeReceiver	Incorrect access control	The `changeFeeReceiver` function should only be called by the guardian, but there is no access control to enforce this constraint. An attacker may be able to change the fee receiver to their own address by calling this function.
52_1	4	changeFeeAmount	Incorrect access control	The `changeFeeAmount` function should only be called by the guardian, but there is no access control to enforce this constraint. An attacker may be able to change the fee amount by calling this function.
52_1	5	changeCouncil	Incorrect access control	The `changeCouncil` function should only be called by the timelock, but there is no access control to enforce this constraint. An attacker may be able to change the council address by calling this function.
52_1	6	cancel	Incorrect access control	The `cancel` function should only be called by the guardian, but there is no access control to enforce this constraint. An attacker may be able to cancel a proposal by calling this function.
52_1	null
41_3	null
41_3	null
38_3	null
37_3	null
47_1	2	balanceToShares, sharesToBalance	Integer Overflow/Underflow	The 'balanceToShares' and 'sharesToBalance' functions do not have any input validation or checks in place to prevent potential integer overflows or underflows. Although this specific contract may not be vulnerable to attacks directly, it is good practice to include checks to ensure the input values are within the expected range.
47_1	2	balanceToShares, sharesToBalance	Integer Overflow/Underflow	The 'balanceToShares' and 'sharesToBalance' functions do not have any input validation or checks in place to prevent potential integer overflows or underflows. Although this specific contract may not be vulnerable to attacks directly, it is good practice to include checks to ensure the input values are within the expected range.
47_1	3	mint, burn	Missing input validation	The 'mint' and 'burn' functions do not have input validation checks. Although the contract relies on the internal _mint and _burn functions from the OpenZeppelin library, which handle some validations, it is recommended to include additional checks on the user-provided '_shares' parameter to ensure it is within an expected range and non-zero.
42_1	1	constructor	Missing input validation	The constructor function does not check whether the provided `_governance` address is a valid address (non-zero). A valid address check should be added to ensure the governance address is correctly set.
42_1	2	changeMochi, changeVMochi, changeUSDM, changeMinter, changeGovernance, changeTreasury, changeOperationWallet, changeCSSR, changeProfile, changeDiscountProfile, changeLiquidator, changeFeePool, changeReferralFeePool, changeNFT	Lack of events	There are no events being emitted in the various "change" functions. It is considered a best practice to emit events when updating state variables to make it easier for off-chain systems to track changes.
42_1	3	changeGovernance, changeTreasury, changeOperationWallet	Centralization risk	Although the contract has a governance system in place, there is a risk of centralization as the same address has the power to change the governance, treasury, and operation wallet addresses. It would be recommended to use a decentralized governance system (e.g., multisig or a DAO) to avoid single points of failure and potential abuse of power.
42_1	1	constructor	Missing input validation	The constructor function does not check whether the provided `_engine` and `_uniswap` addresses are valid addresses (non-zero). A valid address check should be added to ensure the engine and uniswap router addresses are correctly set.
42_1	2	changecrvVoterRewardPool, changeTreasuryRatio, changevMochiRatio, sendToTreasury	Lack of events	There are no events being emitted in the various "change" functions and the `sendToTreasury` function. It is considered a best practice to emit events when updating state variables or when executing important actions to make it easier for off-chain systems to track changes.
42_1	3	distributeMochi	Missing access control	The `distributeMochi` function is not protected by any access control mechanism, meaning anyone can call it. Depending on the intended behavior of the contract, it might be necessary to limit the callers of this function, for example, by using a `onlyGov` modifier or some other access control mechanism.
42_1	4	_buyMochi	Insecure approval for token transfer	In the `_buyMochi` function, the contract approves the uniswap router to spend an amount of USDM equal to `mochiShare`. However, this approval is not revoked or reduced after the swap, which could lead to potential risks if the uniswap router is compromised or has a vulnerability. To minimize risks, it is recommended to only approve the exact amount required for the swap and revoke the approval after the swap is executed.
42_1	5	sendToTreasury	Potential reentrancy vulnerability	The `sendToTreasury` function first transfers the USDM to the treasury address and then sets the `treasuryShare` to 0. This ordering could lead to a reentrancy vulnerability if the treasury contract has a fallback function that calls back into the `FeePoolV0` contract. To mitigate this risk, the `treasuryShare` should be set to 0 before the transfer is executed.
41_1	1	settleAuction	Missing input validation	There is no input validation for the arrays 'inputTokens', 'inputWeights', 'outputTokens', and 'outputWeights' to check if they are non-empty. It is possible for a user to pass empty arrays, which could lead to unexpected behavior.
41_1	2	settleAuction	Integer underflow	In the line "uint256 newRatio = a - b;", there is a possibility of integer underflow if 'b' is greater than 'a'. This could lead to an unexpected value for 'newRatio', causing incorrect calculations and potential loss of funds.
41_1	3	N/A	No timelock implementation	The contract lacks a timelock implementation for sensitive functions such as 'startAuction', 'killAuction', and 'initialize'. This allows the owner or privileged accounts to execute these functions without any delay, potentially causing harm to the contract's users.
41_1	4	addBounty	Incorrect implementation of ReentrancyGuard	The function 'addBounty' is missing the 'nonReentrant' modifier, which would protect it from reentrancy attacks. This could potentially allow an attacker to manipulate the state of the contract, leading to fund loss or other undesirable outcomes.
41_1	5	withdrawBounty	No upper bound checks	The function 'withdrawBounty' is missing upper bound checks on 'bountyIds' array elements. This could result in accessing an invalid index, causing a revert due to an out-of-bounds access.
41_1	null
38_1	1	send	Reentrancy	The `send` function calls the `identity.executeBySender` function, which can potentially execute external contract calls before the scheduled mapping is updated. This can lead to reentrancy attacks. To fix this, use the Checks-Effects-Interactions pattern and move the state-changing effect before the external call.
38_1	2	sendTransfer	Integer Overflow/Underflow	The `sendTransfer` function does not check for integer overflow/underflow when increasing nonces. It's a potential vulnerability since an attacker can exploit the nonce value, causing unexpected behavior. To fix this, use the SafeMath library or solidity 0.8.0's built-in overflow/underflow checks.
38_1	3	sendTransfer, sendTxns	Unchecked Return Values	In both the `sendTransfer` and `sendTxns` functions, the external call to `identity.executeBySender` is not checked for success or failure. This may lead to unexpected behavior if the call fails silently. To fix this, either use a require statement to check the return value or use a try-catch block to handle the error.
37_1	null
29_3	1	mint, burn, burnSingle, swap, flashSwap	Reentrancy Attack	Functions mint, burn, burnSingle, swap, and flashSwap are protected by the 'lock' modifier to prevent reentrancy attacks. However, it is important to note that reentrancy vulnerabilities could still arise due to changes in the code or interactions with other smart contracts. As a best practice, it is recommended to use the "ReentrancyGuard" from OpenZeppelin to prevent reentrancy attacks more robustly.
29_3	2	flashSwap	External Calls	The function flashSwap makes an external call to the ITridentCallee(msg.sender).tridentSwapCallback(context) function. This is a potential vulnerability, as the callee function can be maliciously implemented, allowing the attacker to manipulate the state of the contract. To mitigate this risk, it is advised to use the "check-effects-interactions" pattern and perform any external calls at the end of the function, after updating the contract's state.
29_3	3	swap, flashSwap	Frontrunning Attacks	The functions swap and flashSwap are vulnerable to frontrunning attacks since they rely on the transaction ordering by miners. An attacker could observe the transaction pool and insert their own transaction with a higher gas price, causing their transaction to be executed before the original transaction. To mitigate this risk, consider implementing a commit-reveal mechanism, or using batch transactions for atomic swaps.
29_3	4	_compute, _pow, _powApprox, _mul, _div	Integer Overflow/Underflow	The internal functions _compute, _pow, _powApprox, _mul, and _div perform arithmetic operations that are vulnerable to integer overflows or underflows. Although most of these functions use the 'unchecked' keyword to bypass overflow checks, this may lead to unexpected behavior if not handled properly. To prevent such issues, it is recommended to use SafeMath from OpenZeppelin or Solidity's built-in overflow/underflow checks when performing arithmetic operations.
28_3	1	initToken	Unprotected function	The 'initToken' function is marked public, which means anyone can call it. This could allow a malicious actor to reinitialize the token, change the token's name, symbol, and owner, and mint an arbitrary initial supply. To fix this issue, change the visibility of the 'initToken' function from public to internal.
28_3	2	mint	Missing function access control	The 'mint' function is missing the 'onlyRole(MINTER_ROLE)' modifier, which would restrict access to only those who have the MINTER_ROLE assigned. As a result, anyone with the minter role can mint tokens to any address, which is a potential security risk. To fix this issue, add the 'onlyRole(MINTER_ROLE)' modifier to the 'mint' function.
28_3	3	initToken	Unprotected function	The 'initToken' function is called in the 'initToken' function with bytes calldata parameter. This function is also marked as public, which allows any external caller to reinitialize the token. This could lead to the same issues mentioned in Sequence 1. Changing the visibility of the 'initToken' function from public to internal would resolve this issue as well.
21_3	null
35_1	null
35_1	null
35_1	null
30_1	1	withdraw	Reentrancy vulnerability	The 'withdraw' function allows a user to withdraw a specified amount of tokens from the contract. The function calculates the best strategies to withdraw the amount and then calls the 'withdraw' function on each strategy contract. However, there is a reentrancy vulnerability because the external call to the strategy contract's 'withdraw' function happens before updating the internal balance state of the vault in the '_vaultDetails' mapping. An attacker could potentially exploit this vulnerability by implementing a malicious strategy contract that recursively calls the 'withdraw' function in the controller contract during the external call, effectively draining the vault's balance.
30_1	2	setCap	Lack of input validation	In the 'setCap' function, there is no validation to check if the given '_strategy' address is actually a valid strategy address for the '_vault' address. The function updates the cap for the given strategy and, if the balance is above the new cap, it withdraws the difference and sends the funds back to the vault. However, if an invalid strategy address is passed, it may lead to unintended behavior, since the function will update the cap mapping for an invalid strategy.
30_1	3	earn	Incorrect balance update	In the 'earn' function, the vault balance is updated before the deposit call to the strategy contract. This means that, if the strategy contract's deposit function fails for any reason, the vault's balance would still be updated, leading to an incorrect balance state. It would be safer to update the vault balance after the deposit call to the strategy contract has been successfully executed.
29_1	1	flashSwap	Reentrancy	The flashSwap function is vulnerable to reentrancy attacks due to the call to an external contract (ITridentCallee) before updating the internal state (updating reserve amounts). An attacker could implement a malicious tridentSwapCallback function in their contract that calls back into the IndexPool's swap or flashSwap function before the first flashSwap call has finished, leading to incorrect calculations and potentially draining the pool's funds.
29_1	2	_mul	Integer Overflow	The _mul function is susceptible to integer overflow, as it does not use the 'unchecked' keyword while performing multiplication. If an overflow occurs, the result will be incorrect, and this may lead to other incorrect calculations within the contract.
29_1	3	_subFlag	Integer Underflow	The _subFlag function is vulnerable to integer underflow. Although the function uses the 'unchecked' keyword, the underflow is not handled correctly, and the function returns the difference as a uint256 along with a flag indicating whether the subtraction resulted in a negative value. The contract should handle the underflow correctly, and the difference should be returned as a signed integer to avoid potential issues with calculations elsewhere in the contract.
29_1	4	mint, burn, burnSingle, swap, flashSwap	Inadequate input validation	The mint, burn, burnSingle, swap, and flashSwap functions lack input validation for the amounts being passed into them, such as minimum and maximum values. This could lead to unexpected behavior or edge cases when interacting with these functions. It is important to add proper input validation checks to prevent potential issues with the contract's calculations and interactions.
28_1	1	initToken	No access control on initToken function	The initToken function can be called by anyone, allowing them to potentially mint additional tokens by calling initToken with a different _owner and _initialSupply. A proper access control implementation should be added to prevent unauthorized calls to this function.
28_1	2	init	Missing implementation of init function	The init function is declared but has an empty implementation. This is likely an oversight or incomplete implementation. It should be properly implemented or removed if not needed.
28_1	3	initToken	Redundant function declarations	There are two initToken functions with different input parameters. One of them accepts a bytes calldata parameter and decodes it, while the other one accepts individual parameters. The first function seems redundant since the second one can be used directly. This redundancy might lead to confusion or unexpected behavior.
28_1	4	delegate	Missing return statement in delegate function	The delegate function is declared with a return type, but it doesn't have a return statement. The return statement should be added or the return type should be removed if not needed.
28_1	5	mint	Incorrect comment in mint function	The comment in the mint function states that it must only be called by the owner (MasterChef), but the function actually checks for the MINTER_ROLE. The comment should be updated to reflect the accurate requirement for the MINTER_ROLE.
21_1	1	unstake	Reentrancy	The 'unstake' function allows an attacker to repeatedly call it in a recursive manner and potentially drain the contract's balance. This is because the `_token.safeTransfer(_receiver, amount)` function call is made before the `delete ps.unstakeEntries[msg.sender][_id]` line. An attacker could use this vulnerability to perform a reentrancy attack, draining the contract's balance.
21_1	2	setCooldownFee	Missing input validation	The 'setCooldownFee' function allows setting a new cooldown fee without any validation or upper limit. This could be exploited to set an extremely high cooldown fee, making it impractical for users to unstake their tokens.
5_3	2	_transfer	Integer Overflow/Underflow	In the _transfer function, there are no checks to prevent integer underflow when updating the sender's balance. This could lead to unintended balance manipulation.
5_3	3	upgrade	Unchecked External Call	The upgrade function has an unchecked external call to the VETHER token's transferFrom function. If the transferFrom call fails, the user will not be notified, and the function will continue to execute.
5_3	4	init	Missing Input Validation	The init function does not have proper input validation for the addresses provided as arguments. This could lead to unintended behavior if invalid addresses are provided.
5_3	5	transferTo	Improper Usage of tx.origin	The transferTo function uses tx.origin instead of msg.sender, which could cause issues with contracts interacting with this function. The usage of tx.origin is generally considered a bad practice and can lead to security vulnerabilities, such as phishing attacks.
5_3	1	init	Missing input validation	The function init() does not have any access control to restrict multiple calls, which could potentially change the initial contract parameters. An "onlyOwner" or similar modifier should be added to the function to prevent unauthorized access.
5_3	2	withdraw	Re-entrancy vulnerability	The withdraw function first processes the withdrawal (_processWithdraw) and then sends the funds (sendFunds). This allows for a re-entrancy attack because the withdrawal is processed before the funds are sent. An attacker can call the function again before the transfer is completed, leading to an incorrect balance. To mitigate this, the withdrawal state should be updated after the fund transfer is completed.
5_3	3	setParams	No validation on setting parameters	The setParams function does not validate the new parameter values, which could lead to invalid configurations. For example, newEra, newDepositTime, and newGrantTime could be set to zero, which could cause unexpected behavior. Proper validation should be added to ensure the parameters are within a valid range.
5_3	4	_deposit	Incorrect function visibility	The function _deposit is declared as internal, but it should be private, as it's not intended to be called from derived contracts. Changing it to private will further restrict access and prevent unintended calls.
3_3	null
3_3	1	registerWithdrawal	Reentrancy	In the registerWithdrawal function, there is a reentrancy vulnerability, which could allow an attacker to call the function multiple times before the state is updated, leading to an unexpected withdrawal of tokens. This vulnerability exists because the function modifies the account state after external calls, without using a reentrancy guard.
3_3	2	setTokenCap, setCoolingOffPeriod, setLeverage, setLiquidationThresholdPercent	Lack of input validation	The admin functions (setTokenCap, setCoolingOffPeriod, setLeverage, and setLiquidationThresholdPercent) lack input validation. It is possible for an authorized caller to set values that could lead to undesirable consequences, such as setting the token cap, leverage, or liquidation threshold to zero, which could disrupt the normal functioning of the contract or expose users to additional risks. To prevent this, the contract should validate input values and enforce reasonable limits.
20_1	3	swap, swapTo, mintSynth, burnSynth	Front-running	The contract's swap and swapTo functions are vulnerable to front-running attacks, as they rely on the current state of the pool without checking for price slippage. The same applies to the mintSynth and burnSynth functions. An attacker could potentially profit from the price differences by submitting transactions with higher gas prices.
20_1	1	transfer, transferFrom	Reentrancy Vulnerability	The 'transfer' and 'transferFrom' functions can be exploited through a reentrancy attack by a malicious contract. The '_transfer' function is called before updating the allowances, allowing the attacker to call the function repeatedly within a single transaction before the allowance is updated.
20_1	2	sync	No Access Control	The 'sync' function can be called by anyone, potentially leading to unwanted manipulations of the 'baseAmount' and 'tokenAmount' variables. It should be protected by implementing proper access control mechanisms, such as restricting the function to be called only by a specific role or the contract owner.
20_1	1	mintSynth	Missing input validation	The `mintSynth` function does not validate if the `amount` parameter is greater than zero. It is important to add a require statement to check that the `amount` is greater than zero to prevent potential issues or attacks.
20_1	2	increaseAllowance	Integer overflow	The `increaseAllowance` function does not check for potential integer overflow when adding `addedValue` to the existing allowance. To prevent integer overflow, it is necessary to add a check using the SafeMath library or implement a similar check manually.
20_1	3	decreaseAllowance	Integer underflow	The `decreaseAllowance` function does not check for potential integer underflow when subtracting `subtractedValue` from the current allowance. To prevent integer underflow, it is necessary to add a check using the SafeMath library or implement a similar check manually.
20_1	4	approveAndCall	Unnecessary use of max allowance	In the `approveAndCall` function, the user's allowance is set to the maximum possible value. This may pose a security risk, as it effectively grants unlimited approval to the recipient. Instead, the function should only approve the specified `amount`.
20_1	5	mintSynth	Lack of event emission	The `mintSynth` function is missing an event to notify external parties that a new synthetic token has been minted. It is essential to emit an event such as `MintSynth` to ensure transparency and traceability of synthetic token minting operations.
19_1	null
5_1	1	redeemToMember	Reentrancy	The redeemToMember function calls an external contract, iROUTER, while holding a balance of the token USDV. This allows for potential reentrancy attacks, as the state of the contract has not been updated before calling the external contract.
5_1	2	_approve	Unsafe Arithmetic	The _approve function does not use SafeMath when performing subtraction on the allowance, which could potentially result in an underflow.
5_1	3	_transfer	Unsafe Arithmetic	The _transfer function does not use SafeMath when performing addition and subtraction on the balances, which could potentially result in underflows or overflows.
5_1	4	transferTo	tx.origin usage	The transferTo function uses tx.origin instead of msg.sender, which is a security risk as it is susceptible to phishing attacks. Additionally, tx.origin may be deprecated in the future, which would lead to potential issues in the contract.
5_1	5	_burn	Incorrect Error Message	The _burn function uses the error message "address err" in the require statement, which is not descriptive enough to understand the specific issue it checks for. It should use a more specific error message like "burn from the zero address" to make it clearer.
5_1	1	withdraw	Reentrancy vulnerability	The `withdraw` function in the contract allows a member to withdraw their funds. However, it first processes the withdrawal by calling `_processWithdraw` and updating the internal state, then sends the funds to the member using `sendFunds`. This order of operations could allow a reentrancy attack, where the member receiving the funds could call the `withdraw` function again before the state is updated, causing the contract to send more funds than intended.
5_1	2	depositForMember	Missing input validation	The `depositForMember` function does not validate if the `amount` parameter is greater than zero. This could lead to unexpected behavior when someone deposits zero tokens, as the contract will still emit the `MemberDeposits` event and update the internal state. A check should be added to ensure that the deposited amount is greater than zero.
5_1	3	getFunds	Use of tx.origin	The `getFunds` function checks whether `tx.origin` is equal to `msg.sender`. The use of `tx.origin` can be dangerous, as it can be manipulated by malicious contracts in certain cases. It is generally recommended to avoid using `tx.origin` and rely on `msg.sender` to determine the sender of a transaction or call.
3_1	1	borrow	Access control vulnerability	The function `borrow` is marked as internal, which means it can be called by any function within this contract or a contract that inherits from it. However, the goal stated in the comments is that all external functions should only be accessible to the "margintrader" role, except for view functions. To enforce this access control properly, you should change the `borrow` function to be external and add the necessary role-based access control modifier. For example, you can use the `hasRole` modifier from the `RoleAware` contract.
3_1	2	extinguishDebt	Access control vulnerability	Similar to the `borrow` function, the `extinguishDebt` function is marked as internal, which means it can be called by any function within this contract or a contract that inherits from it. To enforce the access control properly, you should change the `extinguishDebt` function to be external and add the necessary role-based access control modifier, like the `hasRole` modifier from the `RoleAware` contract.
3_1	3	adjustAmounts	Access control vulnerability	The function `adjustAmounts` is also marked as internal, which means it can be called by any function within this contract or a contract that inherits from it. To enforce the access control properly, you should change the `adjustAmounts` function to be external and add the necessary role-based access control modifier, like the `hasRole` modifier from the `RoleAware` contract.
3_1	null
Expired and Dented Cartridges.	null
Expired and Dented Cartridges.	null
Expired and Dented Cartridges.	null
Expired and Dented Cartridges.	null
192_3	2	addToPosition, reducePosition	Integer Overflow / Underflow	The functions addToPosition and reducePosition do not validate if the new margin, new price, or the percent is within the acceptable range. This could lead to potential integer overflow or underflow issues.
192_2	null
191_2	null
190_2	null
122_3	3	buyOption	Front Running	A user who wants to buy an option can be front-run by another user who observes the transaction in the mempool and submits a transaction with a higher gas price to buy the option before the original user's transaction is mined. This can lead to a situation where the original user's transaction fails, and they lose the opportunity to buy the option.
122_3	4	createVault	Missing input validation	The createVault function doesn't validate if the token address provided is a valid ERC20 or ERC721 token address. This could lead to a situation where a user creates a vault with an invalid token address, making the vault unusable.
131_3	1	mint	Missing input validation	The function `mint` does not validate if the beneficiary address is a valid non-zero address. Minting tokens to the zero address would result in the loss of tokens.
131_3	2	_executeInflationRateUpdate	Front-running	The `_executeInflationRateUpdate` function uses `block.timestamp` as the source of time. Miners can manipulate the block timestamp within a certain range, potentially allowing for front-running attacks.
131_3	3	_executeInflationRateUpdate	Inefficient code	The `_executeInflationRateUpdate` function calculates the total available tokens by adding the current total inflation multiplied by the time since the last event. This calculation is performed twice, once at the beginning of the function and once within the `_mint` function, which is inefficient and can be optimized.
145_3	null
145_3	1	constructor	Missing input validation	In the constructor, the initial owner of the ENS registry is set to `msg.sender`. However, there is no input validation to check if `msg.sender` is a non-zero address. This could lead to accidental contract deployment with a zero address as the initial owner, making the ENS registry unusable.
145_2	1	constructor	Access Control	The constructor function assigns the ownership of the root node (0x0) to the `msg.sender`. This creates a potential security issue because the root node can be controlled by the deployer of the contract, which might not be the intended behavior.
145_2	3	setUpgradeContract	Incorrect permission control	In the 'setUpgradeContract' function, there is no input validation for the '_upgradeAddress' parameter. The function should check if the address of the new upgrade contract is valid and not a zero address.
131_2	1	mint	Missing input validation	The `mint` function lacks input validation for the `beneficiary` and `amount` parameters. A zero address can be passed as the beneficiary, and a zero amount can be minted.
131_2	2	mint	Potential reentrancy vulnerability	The `mint` function calls the `_mint` function, which in turn calls the `token.mint` function to mint tokens. After this, it calls the `_executeInflationRateUpdate` function, which updates the contract's state. Although the `mint` function has the `nonReentrant` modifier, it would be safer to update the contract's state before calling the `token.mint` function to avoid any potential reentrancy vulnerabilities.
131_2	3	_mint	Function visibility	The `_mint` function is marked as internal, but it does not use any internal variables or functions, and it is only called by the `mint` function, which has the `nonReentrant` modifier. It would be more efficient to merge the `_mint` function into the `mint` function and remove the internal visibility, since it doesn't provide any additional security.
131_2	4	mintNonInflationTokens	Lack of input validation	The `mintNonInflationTokens` function lacks input validation for the `beneficiary` and `amount` parameters. A zero address can be passed as the beneficiary, and a zero amount can be minted.
122_2	1	withdraw	Reentrancy vulnerability	In the `withdraw` function, the contract first calls `harvest()` to send the ETH balance to the vault beneficiary, and then it transfers the tokens from the contract to the caller. However, since the `harvest()` function involves an external call, an attacker might exploit this vulnerability to perform a reentrancy attack, calling the `withdraw` function multiple times before the state is updated, allowing them to drain the contract's balance.
122_2	2	buyOption	Insecure token transfer	In the `buyOption` function, the `_forceTransfer(msg.sender, optionId);` is called. However, there is no proper validation to ensure that the optionId is valid, which may lead to transferring tokens to an unintended address or transferring incorrect amounts.
115_2	1	depositToVault	Access Control	The depositToVault function allows any user to deposit assets into the vault, which could potentially cause unauthorized users to deposit unwanted tokens into the vault. Ideally, only the contract owner or an authorized role should be able to deposit assets into the vault.
115_2	2	executeOperation	Reentrancy	The executeOperation function is vulnerable to reentrancy attacks, as it calls external contracts during token approval and asset transfers. An attacker could potentially use this vulnerability to manipulate the state of the contract or cause a denial of service. The best practice is to use the Checks-Effects-Interactions pattern to mitigate reentrancy vulnerabilities.
115_2	3	aggregatorSwap	Function Visibility	The aggregatorSwap function should have its visibility set to "private" instead of "internal" since it is only used within the same contract. Setting the function visibility to "private" prevents other contracts in the same inheritance chain from accessing it, reducing the potential attack surface.
115_2	4	leverageSwap	Missing Input Validation	The leverageSwap function does not validate the input parameters, allowing potential attackers to pass arbitrary values for parToSell, dexTxData, and dexIndex. It's essential to add appropriate input validation checks to prevent unexpected behavior or possible vulnerabilities.
115_2	5	aggregatorSwap	Missing Input Validation	The aggregatorSwap function does not validate the input parameters, allowing potential attackers to pass arbitrary values for dexIndex, token, amount, and dexTxData. It's essential to add appropriate input validation checks to prevent unexpected behavior or possible vulnerabilities.
113_2	1	_bentoWithdraw()	Reentrancy	The _bentoWithdraw() function is exposed to reentrancy attack. This function interacts with an external contract (BentoBox) and allows for user-controlled arbitrary calls, which can be utilized by a malicious user to re-enter the contract and execute unwanted actions.
113_2	2	calculateInterest()	Integer Overflow	The calculateInterest() function uses an unsafe addition operation that can lead to integer overflow. The interest value can become very large when the number of terms in the compound interest calculation is high. If the interest value overflows (becomes larger than 2**128), it reverts the transaction. This can be exploited by an attacker to keep a loan from being repaid.
113_2	3	requestLoan()	Missing input validation	The requestLoan() function is missing input validation for the TokenLoanParams. This allows a user to request a loan with invalid parameters such as valuation (0 or extremely high), duration (0), and annualInterestBPS (0 or extremely high). This can result in unintended behavior and manipulation of the contract state.
113_2	4	requestAndBorrow()	Unchecked return value	The requestAndBorrow() function calls the external contract ILendingClub with the willLend() function, but does not check the return value of the call. This could lead to unexpected behavior if the ILendingClub contract's willLend() function returns an incorrect value, as the contract assumes it returns true in this case.
109_2	1	sendToken, callContractWithToken	Reentrancy	The 'sendToken' and 'callContractWithToken' functions both call the '_burnTokenFrom' function that further interacts with external contracts via '_callERC20Token'. This could potentially lead to a reentrancy attack if a malicious ERC20 contract is involved. To prevent this vulnerability, it's recommended to use the 'Checks-Effects-Interactions' pattern and consider using a reentrancy guard.
109_2	2	_burnTokenFrom, _deployToken, _mintToken, _burnToken, _approveContractCall, _approveContractCallWithMint, and other internal functions	No access control for internal functions	While the internal functions can only be called by other functions within the contract, they do not have any access control mechanism to restrict who can call them. This could potentially lead to security vulnerabilities if these functions are mistakenly called by unauthorized users in future contract updates. It's recommended to implement access control mechanisms for these internal functions, such as using the 'onlyAdmin' or 'onlySelf' modifiers.
109_2	3	Various functions	No input validation	Many functions in the contract do not perform proper input validation, which could lead to potential attacks or unintended behavior. For example, the 'sendToken', 'callContractWithToken', 'freezeToken', 'unfreezeToken', and other functions do not validate the input parameters (e.g., checking the length of string inputs). It is recommended to add input validation checks to these functions to ensure that the contract behaves correctly with different inputs.
109_2	4	_callERC20Token	Unchecked return values	The '_callERC20Token' function returns the success status of the external call, but in several instances, the return value is not checked, which could lead to unexpected behavior if the external call fails. It is recommended to always check the return values of external calls and handle them appropriately, either by reverting the transaction or logging the failure.
98_3	1	executeMetaTransaction	Reentrancy	The `executeMetaTransaction` function is vulnerable to a reentrancy attack due to the fact that it first updates the state (increments nonce) and then calls another contract via `address(this).call()`. An attacker could potentially call back into this contract before the call is completed, which may lead to unintended behavior.
98_3	2	executeMetaTransaction	Incorrect nonce handling	The contract uses unchecked addition for updating the nonce, which is claimed to save gas. Although it's improbable for someone to perform 2^256-1 meta transactions, this approach might still be considered a bad practice. If the nonce ever overflows, it would reset to zero, enabling an attacker to replay previously executed meta transactions. A better approach would be to use SafeMath or the built-in Solidity `+` operator to prevent overflow.
98_3	5	_qTokenName, _qTokenSymbol	Timestamp Dependency	The contract uses the `_expiryTime` parameter in the `_qTokenName` and `_qTokenSymbol` functions, which is a Unix timestamp. This makes the contract potentially susceptible to miner manipulation. However, since the affected functions only generate names and symbols for QTokens, the impact of this vulnerability is limited.
103_3	1	swap	Reentrancy	The `swap` function is potentially vulnerable to reentrancy attacks. This can happen because the function makes an external call to `_swapData.callTo.call{ value: msg.value }(_swapData.callData)` before the balance is updated, and the called contract could call back into this contract, leading to unexpected behavior.
103_3	2	swap	Front-running	The `swap` function is potentially vulnerable to front-running attacks, where a malicious miner or user can observe pending transactions and insert their own transaction with a higher gas price to execute first. This is possible because the swap function doesn't implement any access control or time locks, allowing anyone to execute it at any time.
103_3	3	swap	No input validation	There is no input validation for the `SwapData` struct in the `swap` function. This can lead to potential issues if incorrect data is passed to the function. It is essential to add input validation checks to ensure that the provided data is valid and within the expected range.
103_3	1	swapTokensGeneric	Reentrancy	The `swapTokensGeneric` function is potentially vulnerable to reentrancy attacks. This can happen because the function makes an external call to `LibAsset.transferAsset` before emitting the `LiFiTransferStarted` event. A malicious contract could call back into this contract when `transferAsset` is executed, leading to unexpected behavior. It is recommended to use the Checks-Effects-Interactions pattern and emit the event before making any external calls.
103_3	2	swapTokensGeneric	Front-running	The `swapTokensGeneric` function is potentially vulnerable to front-running attacks, where a malicious miner or user can observe pending transactions and insert their own transaction with a higher gas price to execute first. This is possible because the swapTokensGeneric function doesn't implement any access control or time locks, allowing anyone to execute it at any time.
103_3	3	swapTokensGeneric	No input validation	There is no input validation for the `LiFiData` and `LibSwap.SwapData[]` structs in the `swapTokensGeneric` function. This can lead to potential issues if incorrect data is passed to the function. It is essential to add input validation checks to ensure that the provided data is valid and within the expected range.
103_2	1	swapTokensGeneric	Reentrancy	The swapTokensGeneric function transfers the post-swap balance of the receiving asset to the user (msg.sender) before emitting the LiFiTransferStarted event. An attacker could potentially use this to perform a reentrancy attack and drain the contract's funds.
103_2	1	swap	Front-Running	The swap function is vulnerable to front-running attacks. An attacker could potentially monitor pending transactions and submit their own transaction with a higher gas price to perform a swap at a more favorable rate, which could result in worse swap rates for the user.
103_2	2	swap	Incorrect Approve Allowance	In the swap function, the contract approves the full `_swapData.fromAmount` without checking if there is an existing allowance. If the contract already has an allowance for a token, it might approve a smaller amount than intended.
98_2	null
98_2	1	executeMetaTransaction	Reentrancy vulnerability	In the `executeMetaTransaction` function, there is a reentrancy vulnerability due to the external contract call `address(this).call` before the state update `emit MetaTransactionExecuted`. An attacker could exploit this vulnerability to manipulate the contract state and execute multiple transactions with the same nonce.
98_2	2	executeMetaTransaction	Unchecked return value	In the `executeMetaTransaction` function, the return value of the `address(this).call` is not checked for success, which could lead to potential issues when the called function fails, and the state of the contract is not updated properly.
97_2	1	reclaimTokens	Reentrancy	The `reclaimTokens` function is marked as nonReentrant, but it uses the `safeTransfer` function from the SafeERC20Upgradeable library. This can potentially allow for reentrancy attacks if the token being transferred is malicious and triggers a callback to the smart contract during the transfer. To fix this issue, consider using the Checks-Effects-Interactions pattern and transfer tokens at the end of the function.
97_2	2	deposit, withdraw, extractRewards	Front-running	The `deposit`, `withdraw`, and `extractRewards` functions are all subject to front-running attacks because they involve updating the staking rewards and transferring tokens based on the current state. An attacker can monitor the pending transactions pool and submit transactions with higher gas prices to manipulate the order of execution. To mitigate front-running attacks, consider implementing a commit-reveal scheme or using a decentralized oracle service to obtain off-chain data.
97_2	3	_sendRewardsForNft	Integer Overflow/Underflow	In the `_sendRewardsForNft` function, there are unchecked arithmetic operations such as `nft.unpaidRewards = pending - balance;` and `nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;`. These operations can lead to integer overflow or underflow. To prevent this issue, use the SafeMath library for arithmetic operations or use Solidity 0.8.0 or higher, which has built-in overflow/underflow protection.
97_2	4	setRewardPerSecond	Improper Access Control	The `setRewardPerSecond` function can only be called by the owner, but it should also check if the provided base token address is valid and registered with the contract. Otherwise, the owner might accidentally set an incorrect reward rate for a non-registered token. Add a require statement to check if the base token is valid.
97_2	5	withdraw	Denial of Service (DoS)	In the `withdraw` function, there is a loop iterating through the `nftIdsStaked` mapping, which can potentially contain a large number of elements. If the number of elements becomes too large, the loop may consume a lot of gas and make the function uncallable. To address this, consider implementing a more gas-efficient data structure or limit the number of elements in the mapping.
83_2	2	deposit	Missing input validation	The function 'deposit' is missing input validation to check if the provided _amount is greater than zero. This can cause users to accidentally deposit zero tokens, leading to unexpected behavior. To fix this, add a require statement to check that _amount is greater than zero.
83_2	1	deposit	Missing depositToken transfer	In the deposit function, the user's deposit tokens are not actually transferred to the contract. This can lead to incorrect accounting of the tokens, and users can potentially exploit this vulnerability to claim rewards without actually depositing any tokens.
83_2	2	withdraw	No withdrawal of deposit tokens	In the withdraw function, the deposit tokens are not transferred back to the user when they withdraw. This can lead to locked funds, as users will not be able to retrieve their tokens after withdrawal.
70_3	1	getVaderPrice, getUSDVPrice	Reentrancy Vulnerability	The `getVaderPrice` and `getUSDVPrice` functions are vulnerable to reentrancy attacks because they call external contracts (Chainlink Oracles) after updating the state. This could allow an attacker to manipulate the state during the external call and potentially make multiple calls, exploiting the contract.
70_3	2	_updateVaderPrice, _updateUSDVPrice	Integer Overflow/Underflow	In the `_updateVaderPrice` and `_updateUSDVPrice` functions, the code is using the `unchecked` keyword to perform arithmetic operations. This may lead to integer overflow or underflow issues. To avoid these vulnerabilities, proper checks should be added, or the SafeMath library should be used for arithmetic operations.
70_3	3	setupVader, setupUSDV, addVaderPair, addUSDVPair	Missing Input Validation	The `setupVader`, `setupUSDV`, `addVaderPair`, and `addUSDVPair` functions lack input validation for the provided parameters, which could result in unintended consequences, such as adding an incorrect or malicious oracle or token pair. It is recommended to add appropriate input validation checks to these functions.
70_3	4	getChainlinkPrice	Stale Oracle Data	The `getChainlinkPrice` function checks if the Chainlink Oracle price is stale by comparing `answeredInRound >= roundID`, but it doesn't account for the possibility that the data could be stale due to the oracle not being updated for an extended period. It is recommended to add a check comparing the `updatedAt` timestamp to the current block timestamp to ensure that the oracle price data is not stale.
70_3	2	_castVote	Integer Overflow/Underflow	The `unchecked` block in the `_castVote` function allows for potential integer overflows when updating the `proposal.forVotes` and `proposal.againstVotes`. Although this is unlikely to happen, it is safer to use the SafeMath library or the 'check' keyword in the Solidity 0.8.x to prevent such issues.
70_3	6	constructor	Incorrect constructor parameters	The `constructor` function sets the `VOTING_PERIOD` as an immutable variable, but it allows the caller to set it to 0. In case the `votingPeriod_` parameter is 0, the `VOTING_PERIOD` is set to 17280. It is recommended to use a require statement to enforce a minimum `votingPeriod_` value instead of silently changing it to a default value.
70_3	1	initialize	Incorrect check for uninitialized state	In the `initialize` function, the check for uninitialized state is performed using `wrapper == ILPWrapper(_ZERO_ADDRESS)`, but it should be performed with `address(wrapper) == _ZERO_ADDRESS` instead. The current implementation checks if the object instances are equal, which is not the intended behavior.
70_3	2	mintSynth, burnSynth, mintFungible, burnFungible	Potential reentrancy vulnerability	The `mintSynth`, `burnSynth`, `mintFungible`, and `burnFungible` functions are all marked with the `nonReentrant` modifier, which is not defined in the provided code. If the `nonReentrant` modifier is not implemented correctly or is missing, it could lead to potential reentrancy vulnerabilities. To mitigate this issue, ensure that the `nonReentrant` modifier is implemented correctly, typically using a mutex or reentrancy guard.
70_3	3	setTokenSupport	Missing input validation	In the `setTokenSupport` function, there is no check to ensure that the provided `foreignAsset` address is not the zero address. This could lead to unintended behavior or vulnerabilities. To fix this issue, add a validation check to ensure that `foreignAsset` is not equal to the zero address before proceeding.
70_3	4	mintSynth	Missing input validation	In the `mintSynth` function, there is no check to ensure that `nativeDeposit` is greater than zero. This could lead to unintended behavior or vulnerabilities. To fix this issue, add a validation check to ensure that `nativeDeposit` is greater than zero before proceeding.
73_3	null
78_3	1	transferAndCall	Double transfer of tokens	In the function `transferAndCall`, the token transfer is being performed twice. The first call to `super.transfer(_to, _value);` transfers the tokens, and then the next line `_transfer(msg.sender, _to, _value);` does the same thing. This can lead to an unintended double transfer of tokens, which may cause a loss of funds for the token sender.
78_3	2	transferAndCall	Reentrancy vulnerability	The `transferAndCall` function is vulnerable to a reentrancy attack. After the tokens are transferred, the contract calls the `contractFallback` function which in turn calls `receiver.onTokenTransfer()`. If the receiver contract is malicious, it can call back into the `transferAndCall` function before the first call to `transferAndCall` has completed. This can potentially cause unexpected behavior or a loss of funds. Implementing a reentrancy guard, such as the "checks-effects-interactions" pattern, can help mitigate this vulnerability.
78_2	1	transferAndCall	Re-entrancy	The `transferAndCall` function in the smart contract is vulnerable to a re-entrancy attack. The function transfers tokens to the recipient address and then calls the `contractFallback` function, which in turn calls the `onTokenTransfer` function of the recipient contract. This opens up the possibility of a re-entrancy attack, where the recipient contract could maliciously call back into the `transferAndCall` function before the initial call to `onTokenTransfer` has finished. This could lead to unintended consequences, such as draining the contract's funds.
78_2	2	transferAndCall	Double transfer	In the `transferAndCall` function, tokens are transferred twice: first with `super.transfer(_to, _value)` and then with `_transfer(msg.sender, _to, _value)`. This results in transferring double the intended amount of tokens to the recipient address, which is an incorrect implementation.
73_2	2	migrateDelegator, migrateUnbondingLocks, migrateSender, migrateETH, migrateLPT	Front-Running 	Functions like migrateDelegator, migrateUnbondingLocks, migrateSender, migrateETH, and migrateLPT are potentially vulnerable to front-running attacks, as they rely on external input parameters and interact with other contracts. Malicious actors could potentially monitor the pending transactions pool and submit their own transactions with higher gas prices to manipulate the execution order.
70_2	1	setTokenSupport	Missing Input Validation	The function setTokenSupport allows the contract owner to set support for a new token and add initial liquidity to the pool. However, there is no input validation for the 'nativeDeposit' and 'foreignDeposit' parameters. This can lead to potential issues if either of these values is set to 0. To mitigate this, add a check to ensure that both 'nativeDeposit' and 'foreignDeposit' are greater than 0 when setting support for a new token.
70_2	2	burnSynth	Reentrancy	The function burnSynth is marked as nonReentrant, which is a good practice to prevent reentrancy attacks. However, the function calls 'synth.burn(synthAmount);' before updating the reserves with the '_update()' function. This may potentially expose the contract to reentrancy attacks if the 'burn' function of the synth token contract is not secure. To mitigate this, the '_update()' function should be called before executing the 'synth.burn()' function.
70_2	3	_min	Incorrect Function Visibility	The function '_min' is marked as private, but it could be marked as pure internal to make it more reusable within the contract and its derived contracts. The function is pure because it does not modify the contract's state, and it should be internal to allow its reuse in derived contracts. To fix this, change the visibility of the '_min' function from private to internal.
70_2	null
70_2	1	getChainlinkPrice	Stale Price Oracle	The getChainlinkPrice function checks if the returned roundID is greater than or equal to answeredInRound but doesn't check if the answer is stale based on the current timestamp. A potential attack is that if the oracle fails to update the price for a long time, the stale price will still be used for calculations.
70_2	2	_updateVaderPrice, _updateUSDVPrice	Integer Overflow	In both _updateVaderPrice and _updateUSDVPrice functions, the currentLiquidityEvaluation is calculated without any overflow check. An attacker could potentially manipulate the reserve values or prices to trigger an overflow, leading to incorrect calculations.
70_2	3	syncVaderPrice, syncUSDVPrice	Front Running	In syncVaderPrice and syncUSDVPrice functions, the prices are updated publicly. This could allow an attacker to monitor the mempool for these transactions and front-run them, leading to potential price manipulation.
70_2	4	_calculateVaderPrice, _calculateUSDVPrice	Inaccurate Weighted Average Calculation	In both _calculateVaderPrice and _calculateUSDVPrice functions, the totalUSD and totalVader (or totalUSDV) variables are calculated iteratively without intermediate overflow checks. An attacker could potentially manipulate liquidityWeights or prices to trigger an overflow, leading to incorrect average price calculations.
69_2	1	buyAndSwap721, buyAndSwap721WETH, buyAndSwap1155, buyAndSwap1155WETH, buyAndRedeem, buyAndRedeemWETH	Reentrancy attack	Functions `buyAndSwap721`, `buyAndSwap721WETH`, `buyAndSwap1155`, `buyAndSwap1155WETH`, `buyAndRedeem`, and `buyAndRedeemWETH` are marked as nonReentrant. However, they have external calls to `WETH.deposit`, `WETH.transfer`, `WETH.transferFrom`, and `WETH.withdraw` before the `nonReentrant` modifier is applied. An attacker can potentially exploit this to reenter the function before the state is updated, leading to a reentrancy attack.
69_2	2	mintAndSell721, mintAndSell721WETH, mintAndSell1155, mintAndSell1155WETH, buyAndSwap721, buyAndSwap721WETH, buyAndSwap1155, buyAndSwap1155WETH, buyAndRedeem, buyAndRedeemWETH	Insufficient validation of `path` length	The functions mentioned above use the `path` parameter for routing through Uniswap. There is no validation to ensure that the `path` length is greater than or equal to 2. An insufficient `path` length might lead to unexpected behavior when interacting with the Uniswap router.
69_2	3	mintAndSell721, mintAndSell721WETH, mintAndSell1155, mintAndSell1155WETH, buyAndSwap721, buyAndSwap721WETH, buyAndSwap1155, buyAndSwap1155WETH, buyAndRedeem, buyAndRedeemWETH	Front-running attack	Functions mentioned above use `minWethOut` or `maxWethIn` as slippage protection parameters for token swaps on Uniswap. However, this approach is not entirely safe against front-running attacks. An attacker could potentially observe a pending transaction and submit their own transaction with a higher gas price, causing their transaction to be processed first and altering the price, leading to the victim's transaction failing or executing at an unfavorable rate.
69_2	4	buyAndSwap721, buyAndSwap1155, buyAndRedeem	Unchecked return values	The functions `buyAndSwap721`, `buyAndSwap1155`, and `buyAndRedeem` use a low-level `call` to transfer Ether to the specified recipient. The return value of this `call` is checked for success, but any additional returned data is ignored. If the recipient contract returns data other than a single `bool`, it could cause unexpected behavior, as the returned data length might not match the expected length of a `bool`. It is recommended to either use a high-level transfer function or check the length of the returned data.
69_2	null
68_2	null
60_3	1	liquidate	Reentrancy vulnerability	The `liquidate` function is marked as `nonReentrant`, which is intended to prevent reentrancy attacks. However, the `nonReentrant` modifier is implemented in the imported `UReentrancyGuard` contract, which is not provided. This may allow a reentrancy attack to occur during the execution of the `liquidate` function.
60_3	2	depositTo, withdrawTo, resolveShortfall, claimFee	Unsafe token transfer	The functions `depositTo`, `withdrawTo`, `resolveShortfall`, and `claimFee` use the custom `Token18` library for pulling and pushing token transfers. It is not possible to review this library, so there is a potential risk if the `Token18` library does not properly handle token transfers in a safe manner. It is recommended to use OpenZeppelin's SafeERC20 library to ensure the safe handling of token transfers.
60_3	3	settleAccount, settleProduct	Integer overflow/underflow	The `settleAccount` and `settleProduct` functions use arithmetic operations that may lead to integer overflow/underflow issues. To prevent this, it is recommended to use the SafeMath library for performing arithmetic operations.
60_3	4	depositTo, withdrawTo, resolveShortfall, claimFee	Potential DoS	The `depositTo`, `withdrawTo`, `resolveShortfall`, and `claimFee` functions use the custom `Token18` library for pulling and pushing token transfers. If the token contract does not follow the ERC20 standard and does not return a boolean value or reverts on failure, these functions may be vulnerable to a denial-of-service attack. Using OpenZeppelin's SafeERC20 library can mitigate this risk.
61_3	2	directSavingsAccountDeposit	Incorrect usage of SafeERC20	The `safeApprove` function from the SafeERC20 library is used in the `directSavingsAccountDeposit` function. However, there is no check to ensure that the current allowance is zero before calling the `safeApprove` function. This can lead to issues with certain ERC20 token implementations that require the allowance to be set to zero before updating it. This can be mitigated by adding a check to ensure that the current allowance is zero before calling the `safeApprove` function.
61_3	3	depositFromSavingsAccount, directDeposit	Insufficient validation of function parameters	The `depositFromSavingsAccount` and `directDeposit` functions do not validate whether the `_from`, `_to`, `_token`, or `_strategy` addresses are non-zero addresses. This can lead to potential issues if these functions are called with invalid addresses. Adding checks to ensure that these addresses are non-zero addresses can mitigate this issue.
64_3	1	claimRewards	Reentrancy vulnerability	In the `claimRewards` function, the `_promotion.token.safeTransfer(_user, _rewardsAmount)` line is transferring the reward tokens to the user before setting the `_claimedEpochs[_promotionId][_user] = _userClaimedEpochs` line, which updates the claimed epochs. This may allow a reentrancy attack to occur, where an attacker could potentially claim rewards multiple times within the same transaction before the claimed epochs are updated. To fix this issue, it is recommended to update the claimed epochs before transferring the tokens.
64_2	null
61_2	null
60_2	1	liquidate	Reentrancy Vulnerability	The 'liquidate' function can be exploited by a reentrancy attack because it sends tokens to an external address (msg.sender) before updating the state. An attacker could call the 'liquidate' function again before the state is updated, potentially draining funds from the contract.
60_2	2	updateLiquidationFee	Missing Input Validation	The 'updateLiquidationFee' function allows the contract owner to set a new liquidation fee without any bounds or restrictions. An attacker who gains control of the owner account could set an extremely high or negative fee, which could lead to unexpected behavior in the contract.
60_2	1	buyMalt	Reentrancy	The `buyMalt` function makes an external call to the router with `router.swapExactTokensForTokens`. This external call can potentially call back into the contract, causing a reentrancy vulnerability. To mitigate this issue, use the checks-effects-interactions pattern and move the external call to the end of the function.
60_2	2	sellMalt	Reentrancy	The `sellMalt` function makes an external call to the router with `router.swapExactTokensForTokens`. This external call can potentially call back into the contract, causing a reentrancy vulnerability. To mitigate this issue, use the checks-effects-interactions pattern and move the external call to the end of the function.
60_2	3	addLiquidity	Reentrancy	The `addLiquidity` function makes an external call to the router with `router.addLiquidity`. This external call can potentially call back into the contract, causing a reentrancy vulnerability. To mitigate this issue, use the checks-effects-interactions pattern and move the external call to the end of the function.
60_2	4	removeLiquidity	Reentrancy	The `removeLiquidity` function makes an external call to the router with `router.removeLiquidity`. This external call can potentially call back into the contract, causing a reentrancy vulnerability. To mitigate this issue, use the checks-effects-interactions pattern and move the external call to the end of the function.
60_2	null
59_2	1	initialize	Missing Input Validation	The function `initialize` is missing input validation for the parameters _thresholdBps, _maltDataLab, _lookback, and _pool. Since there are no checks to ensure that the input parameters are valid or non-zero addresses, this could lead to unexpected behavior or difficulties in managing the contract later on. It is important to add appropriate checks for these parameters to avoid any issues.
59_2	3	removeFromWhitelist	Integer Overflow/Underflow	The function `removeFromWhitelist` does not revert or throw an error when the address being removed is not found in the whitelist. Instead, it silently returns without any action. This could lead to confusion for admins when they expect the removal operation to succeed but it doesn't. To fix this, consider reverting with an appropriate error message when the address is not found in the whitelist.
59_2	1	initialize	Missing input validation	The function `initialize` is missing input validation for the addresses it receives as arguments. This could lead to unintended behavior if an incorrect address is provided. It is a good practice to include input validation, such as checking for zero addresses, to avoid potential issues.
59_2	2	buyMalt, sellMalt, addLiquidity, removeLiquidity	Front running	The functions `buyMalt`, `sellMalt`, `addLiquidity`, and `removeLiquidity` are vulnerable to front running attacks. In these functions, the `now` keyword is used as a deadline for the Uniswap transactions. An attacker could manipulate the transaction ordering in a block to perform a front running attack. To mitigate this issue, it is recommended to use a reasonable time-based deadline instead of the `now` keyword, such as `block.timestamp + x`, where `x` is an acceptable time window.
59_2	3	addLiquidity	Slippage tolerance not adjustable	The `addLiquidity` function has a hardcoded slippage tolerance (95%). This lack of configurability might not suit all users and could lead to unintended consequences in certain market conditions. To address this issue, it is recommended to make slippage tolerance adjustable by either the contract owner or allowing users to specify their desired tolerance when calling the function.
59_2	4	maltMarketPrice	Potential rounding errors	The `maltMarketPrice` function calculates the price and decimals based on the token's decimals. In certain scenarios, this could lead to rounding errors, causing inaccurate price calculations. To address this issue, it is recommended to use a more precise method for handling decimals, such as using fixed-point arithmetic libraries or implementing a custom solution for dealing with decimals.
54_2	3	upgradeLock	Unprotected Function	The function 'upgradeLock()' does not check if the implementation address for the new version is a valid address. This can lead to potential issues while upgrading the lock. To fix this issue, add a check to ensure that the implementation address is valid (not zero) before upgrading the lock.
54_2	4	resetTrackedValue	Unchecked External Calls	The function 'resetTrackedValue()' allows the owner to arbitrarily change the grossNetworkProduct and totalDiscountGranted values. This could be a potential issue if the owner tries to manipulate the contract state. Consider adding a more secure way to update these values, like through a consensus mechanism or based on specific events that occur in the contract.
53_3	1	destroy	Reentrancy vulnerability	The `destroy` function of the smart contract is marked as `nonReentrant`. However, it calls `_safeSubmitOrder` function, which internally calls `OperatorHelpers.callOperator`, allowing an external operator contract to be executed. An attacker could implement a malicious operator contract that calls back into the smart contract (reentrant call) and manipulate the state of the contract.
53_3	2	setReserve	Access control	The `setReserve` function allows the owner to change the reserve address only if the reserve address has not been set before (by checking if `address(reserve) == address(0)`). While this might not be a direct vulnerability, it might be considered a potential implementation issue, as it is not clear whether this is an intended behavior or not. If it is intended, the code should be documented to clarify the reasoning behind this decision.
53_3	3	increaseLockTimestamp	Incomplete input validation	The `increaseLockTimestamp` function updates the lock timestamp for a given NFT ID. It does not validate if the new timestamp is greater than the current timestamp, which could potentially allow an NFT to be locked indefinitely if an earlier timestamp is provided. A check should be added to ensure the new timestamp is greater than the current timestamp.
53_3	4	_submitOrder	Unchecked external call return value	The `_submitOrder` function calls an external operator contract with `OperatorHelpers.callOperator`. However, it does not check the return value of the external contract. This could potentially result in unexpected behavior if the operator contract returns an error. The contract should check the return value of the external call and handle errors accordingly.
53_3	5	_transferToReserveAndStore	Incorrect use of SafeERC20	The `_transferToReserveAndStore` function uses `IERC20(_token).safeTransfer(address(reserve), _amount)` to transfer tokens to the reserve address. The SafeERC20 library should be used here instead to ensure proper handling of potential issues, such as non-standard ERC20 token implementations.
53_3	1	mint, mintWithMetadata	Front Running	The mint and mintWithMetadata functions can be front-run by a malicious user, which might result in the token being minted for the attacker's address instead of the intended user. To mitigate this issue, consider implementing a commit-reveal scheme or using an off-chain signing mechanism.
53_3	1	getAmountDue	Incorrect ETH address usage	The function getAmountDue uses the IERC20 interface to represent the token, but also uses it to represent ETH. Since ETH isn't an ERC20 token, this would result in incorrect behavior when querying for the amount due in ETH.
53_3	2	releaseToken, releaseETH, sendFees, sendFeesWithRoyalties	Reentrancy vulnerability	Although the contract uses the ReentrancyGuard modifier, there are multiple external calls made after state changes in the releaseToken, releaseETH, sendFees, and sendFeesWithRoyalties functions. These external calls include safeTransfer, safeTransferFrom, and the low-level call for transferring ETH. Although the ReentrancyGuard would prevent direct reentrancy attacks, the external calls may still interact with other contracts, which could lead to potential vulnerabilities in a more complex contract interaction scenario.
53_2	1	_computeShareCount	Integer division	The _computeShareCount function performs integer division, which may lead to a loss of precision and potential rounding errors. This can result in small amounts of tokens not being distributed to shareholders, leading to an accumulation of unallocated tokens over time.
53_2	2	sendFeesWithRoyalties	No Reentrancy Guard on sendFeesWithRoyalties	The sendFeesWithRoyalties function is missing the nonReentrant modifier, which should be added to prevent potential reentrancy attacks. Reentrancy attacks can occur when a contract calls an external contract, which then calls back into the original contract before the first call has finished. By adding the nonReentrant modifier, the contract can mitigate the risk of reentrancy attacks.
53_2	3	findShareholder	Unbounded loop	The findShareholder function contains a for loop that iterates over the shareholders array. As the number of shareholders grows, the loop could become gas-expensive and eventually exceed the block gas limit, making it impossible to execute the function. A possible solution to mitigate this issue is to implement a mapping to store shareholder indices, allowing the function to access shareholder information in constant time.
53_2	4	_sendFees	Unallocated tokens	The _sendFees function calculates the shares for each shareholder and updates the totalShares variable. However, due to the potential rounding errors in the _computeShareCount function, there might be a small amount of unallocated tokens left after the distribution. To fix this issue, the contract could keep track of the remaining balance after distributing the shares and allocate the leftover tokens in a fair manner, such as proportionally to the shareholders' weights.
53_2	1	mint, mintWithMetadata	Front-Running	When minting a new token with the 'mint' and 'mintWithMetadata' functions, there is a possibility of front-running. A malicious actor could watch the pending transactions and submit their own transaction with a higher gas price to mint the token before the intended recipient.
53_2	2	increaseLockTimestamp	Missing input validation	The function increaseLockTimestamp allows the token owner to update the lock timestamp of the NFT. However, there is no input validation to check if the new timestamp is greater than the current timestamp. As a result, an owner can set the lock timestamp to a past date, effectively unlocking the token immediately.
53_2	3	removeOperator	Unhandled exception	In the removeOperator function, there is a while loop that searches for the operator to remove. However, there is no boundary check in the loop, so it can potentially run indefinitely if the operator is not found. To fix this issue, add a boundary check within the loop, and handle the case where the operator is not found appropriately.
53_2	4	_submitInOrders	Unchecked underflow	In the _submitInOrders function, the calculation of feesAmount and the assertion of amountSpent <= _inputTokenAmount - feesAmount could potentially lead to an underflow if feesAmount is greater than _inputTokenAmount. To prevent this underflow, you should ensure that feesAmount is never greater than _inputTokenAmount.
52_2	1	swap	Inadequate input validation in swap function	In the swap function, there is no check to ensure that the nativeAmountIn and foreignAmountIn are positive. An attacker can call the swap function with both nativeAmountIn and foreignAmountIn set to zero, which will bypass the require condition on line 120 and allow them to execute the function without actually swapping any tokens. It's recommended to check whether nativeAmountIn and foreignAmountIn are positive when either of them is not zero.
52_2	2	doubleSwap	Potential price manipulation vulnerability	The doubleSwap function can be exploited by an attacker to manipulate the price of the native asset and the two foreign assets involved in the double swap. Since there is no slippage protection or oracle price checks, an attacker can take advantage of the lack of price validation to manipulate prices in their favor. It's recommended to implement slippage protection or utilize an external oracle to verify the price before executing a double swap.
52_2	3	rescue	Rescue function can be called by anyone	The rescue function can be called by anyone, allowing any user to transfer unaccounted tokens from the contract to their own address. It's recommended to add an access control mechanism (such as onlyOwner or a similar modifier) to the rescue function to ensure that only authorized accounts can call it.
52_2	4	_burn	Potential rounding error in the burn function	In the _burn function, the calculations for amountNative and amountForeign (lines 78-79) could potentially lead to rounding errors due to integer division. This can cause discrepancies in the token balances and reserve amounts. To mitigate this issue, consider using a more precise arithmetic library or adjusting the calculations to account for potential rounding errors.
52_2	1	mintSynth	Reentrancy	The mintSynth function uses nativeAsset.safeTransferFrom which is an external call before updating the state of the contract. This can potentially expose the contract to reentrancy attacks.
52_2	2	burnSynth	Reentrancy	The burnSynth function uses IERC20(synth).safeTransferFrom and synth.burn which are external calls before updating the state of the contract. This can potentially expose the contract to reentrancy attacks.
52_2	3	mintFungible	Reentrancy	The mintFungible function uses nativeAsset.safeTransferFrom and foreignAsset.safeTransferFrom which are external calls before updating the state of the contract. This can potentially expose the contract to reentrancy attacks.
52_2	4	burnFungible	Reentrancy	The burnFungible function uses IERC20(lp).safeTransferFrom and lp.burn which are external calls before updating the state of the contract. This can potentially expose the contract to reentrancy attacks.
52_2	5	burn	Missing input validation	The burn function does not check if the id parameter is valid or not. This can lead to incorrect behavior or unexpected results when invalid id values are passed.
52_2	6	toggleQueue	Unprotected internal state	The toggleQueue function can be called by the contract owner to change the queueActive state. This allows the contract owner to change the contract's behavior at will, which might not be desirable for a decentralized application.
52_2	7	setTokenSupport	Unprotected internal state	The setTokenSupport function can be called by the contract owner to change the supported state of a token. This allows the contract owner to change the contract's behavior at will, which might not be desirable for a decentralized application.
52_2	8	setFungibleTokenSupport	Unprotected internal state	The setFungibleTokenSupport function can be called by the contract owner to create a wrapper for a foreignAsset. This allows the contract owner to change the contract's behavior at will, which might not be desirable for a decentralized application.
52_2	1	_swap	Incorrect Path Check	The check for path[0] != path[1] && path[1] == pool.nativeAsset() && path[2] != path[1] in the _swap function does not consider the possibility of path[0] == path[2]. This could lead to unexpected behavior, as the user may mistakenly provide the same token as input and output in a double swap operation, leading to potential loss of funds.
52_2	2	addLiquidity	Missing Validation on addLiquidity	The addLiquidity function does not validate the provided `amountADesired` and `amountBDesired` against the zero value. It is possible for users to call this function with zero values for one or both token amounts, leading to unintended behavior or potential loss of funds. It is recommended to add a validation check ensuring that both `amountADesired` and `amountBDesired` are greater than zero.
52_2	3	addLiquidity	Unused Parameters	The addLiquidity function has two unused parameters, amountAMin and amountBMin. While this does not pose any security risk, it could be misleading for users trying to understand the function's behavior. It is recommended to remove these parameters if they are not intended to be used, or to implement the intended behavior if they are meant to serve a purpose.
52_2	null
52_2	null
42_3	1	distributeMochi	Reentrancy Vulnerability	The distributeMochi function is vulnerable to a reentrancy attack. When '_buyMochi()' is called, it interacts with an external contract 'uniswapRouter' by calling 'swapExactTokensForTokens'. An attacker could potentially create a malicious token contract that calls 'distributeMochi()' function in its callback function during the token swap, leading to reentrancy.
42_3	2	distributeMochi, sendToTreasury	Lack of access control	The 'distributeMochi()' and 'sendToTreasury()' functions lack proper access control mechanisms, which means that any user can call these functions. This could result in unintended consequences or manipulation of the contract state.
42_3	3	updateReserve	Integer Overflow	The 'updateReserve()' function can potentially cause an integer overflow when calculating the new reserve. If the balance of USDM tokens in the contract address is very large, the subtraction operation could cause an overflow resulting in an incorrect value for the new reserve. To mitigate this risk, it is recommended to use SafeMath library or Solidity's built-in checks for arithmetic operations.
42_3	4	changecrvVoterRewardPool, changeTreasuryRatio, changevMochiRatio	Missing event logs	The functions 'changecrvVoterRewardPool()', 'changeTreasuryRatio()', and 'changevMochiRatio()' lack event logs to notify the users of the contract about the changes made. It is recommended to emit events whenever the contract state is modified so that users can monitor and track these changes.
42_3	1	changeMochi, changeVMochi, changeUSDM, changeMinter, changeGovernance, changeTreasury, changeOperationWallet, changeCSSR, changeProfile, changeDiscountProfile, changeLiquidator, changeFeePool, changeReferralFeePool, changeNFT	Missing event logs	All the change functions in the MochiEngine contract lack event logs to notify users of the contract about the changes made. It is recommended to emit events whenever the contract state is modified so that users can monitor and track these changes.
42_3	2	N/A	Centralization of control	The MochiEngine contract relies on a single governance address to control all the change functions. While it is common for a contract to have a governance address, it may be beneficial to implement a decentralized governance mechanism such as a multisig wallet or a DAO to reduce the risks associated with centralized control.
42_3	3	constructor	Incomplete Initialization	The constructor initializes the vaultFactory, governance, and operationWallet, but other contract components like mochi, vMochi, usdm, minter, cssr, mochiProfile, discountProfile, liquidator, feePool, referralFeePool, and nft are not initialized in the constructor. This leaves the contract in an incomplete state after deployment, and proper initialization is left to the governance address. To mitigate this risk, the constructor could require these components as input arguments and initialize them during deployment.
47_3	1	mint, burn	Reentrancy	The 'mint' and 'burn' functions contain external calls to the ERC20 `transferFrom` and `transfer` functions, respectively. These external calls can be used to execute reentrancy attacks by exploiting callbacks. Although the contract uses the Checks-Effects-Interactions pattern, it is still a good practice to use a reentrancy guard to prevent any future changes to the code that could introduce reentrancy vulnerabilities.
47_3	2	updatePricePerShare	No proper access control	The 'updatePricePerShare' function is permissionless, meaning that anyone can call it. While this may be intentional, it can lead to potential manipulation of the price per share value by malicious actors or front-runners. It is recommended to implement some form of access control or rate-limiting to mitigate this risk.
47_3	3	updatePricePerShare	Use of now	The 'updatePricePerShare' function uses the 'now' keyword to get the current timestamp. The 'now' keyword is an alias for 'block.timestamp', which can be manipulated by miners to some extent. It is recommended to use a more reliable source of time, such as a trusted oracle or other external sources.
47_3	4	mint, burn	Missing input validation	The 'mint' and 'burn' functions do not validate the input '_shares' parameter. A user can pass a zero value for '_shares', resulting in wasted gas and unnecessary contract interactions. It is recommended to add a require statement to check that the '_shares' value is greater than zero.
47_3	1	mint, burn	Reentrancy	The 'mint' and 'burn' functions contain external calls to the ERC20 `transferFrom` and `transfer` functions, respectively. These external calls can be used to execute reentrancy attacks by exploiting callbacks. Although the contract uses the Checks-Effects-Interactions pattern, it is still a good practice to use a reentrancy guard to prevent any future changes to the code that could introduce reentrancy vulnerabilities.
47_3	2	mint, burn	Missing input validation	The 'mint' and 'burn' functions do not validate the input '_shares' parameter. A user can pass a zero value for '_shares', resulting in wasted gas and unnecessary contract interactions. It is recommended to add a require statement to check that the '_shares' value is greater than zero.
47_3	3	pricePerShare	Oracle manipulation	The 'pricePerShare' function relies on an external oracle to provide the price per share. This design exposes the contract to potential oracle manipulation attacks, where a malicious actor could manipulate the oracle data to impact the contract's functionality. It is important to ensure that the oracle used is secure, reliable, and resistant to manipulation.
47_3	4	mint, burn	Missing events	The 'mint' and 'burn' functions lack events for logging important actions. It is recommended to emit events when significant state changes occur, such as minting or burning tokens. This provides a transparent and auditable record of the contract's actions for users and developers. Add appropriate events in the 'mint' and 'burn' functions to track these state changes.
47_2	1	mint	Missing input validation	The mint function lacks input validation for the _shares parameter. An attacker can exploit this by calling mint with an extremely large value for _shares, potentially causing unexpected behavior or consuming excessive gas.
47_2	2	burn	Reentrancy vulnerability	The burn function is vulnerable to reentrancy attacks. The external call to ibbtc.transfer is made after the _burn function. This can potentially be exploited by an attacker who creates a malicious contract that calls burn recursively, leading to unexpected behavior or loss of funds.
47_2	3	transfer, transferFrom	Inaccurate comment	The comments for the transfer and transferFrom functions mention that the _balances mapping represents the underlying ibBTC shares ("non-rebased balances"). However, this comment may be misleading as _balances actually represent the wrapped ibBTC (wibBTC) shares, not the underlying ibBTC shares.
47_2	4	burn	Missing input validation	The burn function lacks input validation for the _shares parameter. An attacker can exploit this by calling burn with an extremely large value for _shares, potentially causing unexpected behavior or consuming excessive gas.
47_2	1	mint	Missing input validation	The mint function lacks input validation for the _shares parameter. An attacker can exploit this by calling mint with an extremely large value for _shares, potentially causing unexpected behavior or consuming excessive gas.
47_2	2	burn	Reentrancy vulnerability	The burn function is vulnerable to reentrancy attacks. The external call to ibbtc.transfer is made after the _burn function. This can potentially be exploited by an attacker who creates a malicious contract that calls burn recursively, leading to unexpected behavior or loss of funds.
47_2	3	transfer, transferFrom	Inaccurate comment	The comments for the transfer and transferFrom functions mention that the _balances mapping represents the underlying ibBTC shares ("non-rebased balances"). However, this comment may be misleading as _balances actually represent the wrapped ibBTC (wibBTC) shares, not the underlying ibBTC shares.
47_2	4	burn	Missing input validation	The burn function lacks input validation for the _shares parameter. An attacker can exploit this by calling burn with an extremely large value for _shares, potentially causing unexpected behavior or consuming excessive gas.
47_2	5	updatePricePerShare	Stale price data	The updatePricePerShare function allows anyone to update the pricePerShare variable, but there is no mechanism in place to ensure that the price data is updated frequently enough or within a specific timeframe. This could lead to stale or inaccurate price data being used in the contract calculations.
42_2	1	constructor	Missing input validation	In the constructor, the _governance address is not validated. A potential vulnerability could occur if a zero address is passed as the governance address. It is recommended to add a validation check to ensure a non-zero address is provided.
42_2	2	changeGovernance, changeTreasury, changeOperationWallet, changeCSSR, changeProfile, changeDiscountProfile, changeLiquidator, changeFeePool, changeReferralFeePool, changeNFT	Centralization risks	All the change* functions can only be called by the current governance address (onlyGov modifier is applied), creating a centralization risk. If the governance address is compromised, an attacker could potentially change critical components of the system. A potential solution to mitigate this risk is to implement a multisig wallet or a decentralized governance mechanism like a DAO.
42_2	1	constructor	Missing input validation	In the constructor, the _engine and _uniswap addresses are not validated. A potential vulnerability could occur if zero addresses are passed as the engine or uniswap addresses. It is recommended to add validation checks to ensure non-zero addresses are provided.
42_2	2	changecrvVoterRewardPool, changeTreasuryRatio, changevMochiRatio	Centralization risks	The functions changecrvVoterRewardPool, changeTreasuryRatio, and changevMochiRatio can only be called by the current governance address, creating a centralization risk. If the governance address is compromised, an attacker could potentially change critical components of the system. A potential solution to mitigate this risk is to implement a multisig wallet or a decentralized governance mechanism like a DAO.
42_2	3	sendToTreasury	No approval check for USDM token	The function sendToTreasury transfers the USDM token directly to the treasury without checking if the contract has enough allowance to make the transfer. It is recommended to add a check to ensure that the contract has enough allowance to transfer the USDM token to the treasury.
41_2	null
41_2	3	mint, mintTo, burn, changePublisher, changeLicenseFee, publishNewIndex	Front-running	There is no explicit protection against front-running attacks in the contract. Users who call the functions mint, mintTo, burn, changePublisher, changeLicenseFee, and publishNewIndex might be affected by front-runners. These attacks could be mitigated by implementing mechanisms such as commit-reveal schemes or by leveraging layer-2 solutions.
38_2	1	sendTransfer	Reentrancy	In the sendTransfer function, external calls to the token contract (IERC20.transfer) are made to transfer tokens to the recipient and sender. However, these external calls are executed after updating the nonce. This may allow an attacker to re-enter the contract and execute further transactions, exploiting the fact that the nonce has already been incremented. To mitigate this issue, it is recommended to use the Checks-Effects-Interactions pattern, updating the nonce after external calls have been executed.
38_2	2	send	Front-running	In the send function, when only one of the two signatures is provided, the transaction is scheduled with a timelock. However, this allows a potential front-running attack by miners or other users who can execute the scheduled transaction before the original sender if the timelock has passed. To reduce the risk of front-running, consider adding a mechanism to prevent other users from executing the scheduled transaction.
38_2	3	send, sendTransfer, sendTxns	Incorrect nonce handling	In the send, sendTransfer, and sendTxns functions, the nonces are incremented before performing any validations or actions. This can lead to nonce skipping and incorrect nonce values being used for subsequent transactions. To prevent this, increment the nonce after all validations and actions have been performed successfully.
38_2	4	isValidSignature	Insufficient input validation	In the isValidSignature function, the input signature is decoded, but no validation is performed to ensure that the decoded values are valid, like checking if the addresses are not zero addresses or the length of signatures is correct. To improve the security of the contract, input validation should be added to the isValidSignature function to ensure that the decoded values are valid and avoid potential misuse.
37_2	null
30_3	2	setCap	Lack of input validation	The function `setCap` does not validate if the provided `_vault` and `_strategy` addresses are valid and allowed before updating the cap. This can lead to unexpected behavior.
35_3	1	collect()	Reentrancy vulnerability	The `collect()` function calls the `position.pool.collect()` function, which may contain external contract interactions. Then, it transfers tokens to the `recipient` without using a reentrancy guard. A malicious contract can exploit this vulnerability to call the `collect()` function again before the state has been updated, causing undesired behavior.
35_3	2	burn()	Missing input validation	The `burn()` function allows for burning tokens by providing a `tokenId`. However, there is no input validation to check if the provided `tokenId` is valid or within the range of existing tokens. This can lead to unexpected behavior if an invalid `tokenId` is provided.
35_3	3	positionMintCallback()	Missing function access control	The `positionMintCallback()` function does not use any access control mechanism like `onlyPool` or `onlyMasterDeployer`. This allows any external actor to call this function and mint new positions. This can lead to an unlimited minting of positions and a potential attack on the token supply.
35_3	1	addIncentive()	Missing input validation	The `addIncentive()` function accepts an `Incentive` struct as input, but there is no input validation to check if the provided incentive is valid or not. This can lead to unexpected behavior or potential attacks by adding incentives with incorrect parameters.
35_3	2	subscribe(), claimReward(), and getReward()	Incorrect use of positionId as incentiveId	In the `subscribe()`, `claimReward()`, and `getReward()` functions, `positionId` is used to access the incentive instead of `incentiveId`. This can lead to incorrect incentives being accessed, causing unexpected behavior or vulnerabilities. The correct implementation should use `incentiveId` to access the incentives mapping.
35_3	3	reclaimIncentive()	Incorrect access control	The `reclaimIncentive()` function allows the incentive owner to withdraw unclaimed rewards, but it does not check if the caller is the owner of the position before executing the function. This can lead to unauthorized withdrawals by other users.
35_3	4	subscribe()	Missing input validation	The `subscribe()` function does not validate if the position has already subscribed to the incentive. If a position subscribes to the same incentive multiple times, the position might claim more rewards than intended, leading to incorrect distribution of rewards.
35_3	1	insert()	Missing access control	The `insert()` function is marked as public, which means any user can call it to modify the ticks. However, this function is supposed to be an internal helper function for managing ticks. As a result, there should be access control in place to prevent unauthorized calls to this function. Changing the visibility of the function to internal will resolve this issue.
35_3	2	remove()	Missing access control	The `remove()` function is marked as public, which means any user can call it to modify the ticks. However, this function is supposed to be an internal helper function for managing ticks. As a result, there should be access control in place to prevent unauthorized calls to this function. Changing the visibility of the function to internal will resolve this issue.
35_3	3	getMaxLiquidity()	Function visibility mismatch	The `getMaxLiquidity()` function is marked as internal, but it is not used in the same contract or inherited by another contract. If it is intended to be a utility function that should be accessible by other contracts, the visibility should be changed to public or external. If it is not meant to be used by other contracts, it can be removed or marked as private.
35_3	4	insert() and remove()	Unchecked arithmetic	The `insert()` function updates the liquidity of ticks without checking for overflows, and the `remove()` function updates the liquidity of ticks without checking for underflows. Although Solidity >=0.8.0 has built-in overflow and underflow checks, it is always a good practice to use SafeMath or to handle overflows and underflows explicitly in the code to avoid potential issues.
35_2	2	remove	Integer Overflow/Underflow	In the `remove` function, the unchecked block is used while decrementing the `liquidity` property of the `Tick` struct. If the `amount` is greater than the `current.liquidity`, it will cause an underflow, resulting in an incorrect value for the `liquidity`.
35_2	3	insert, remove	Access control vulnerability	The `insert` and `remove` functions are marked as `public` and do not have any access control checks (like `onlyOwner` or `onlyAuthorized`). This allows any external actor to call these functions, which can lead to unauthorized modifications of the ticks mapping.
35_2	4	insert, remove	Function visibility	The `insert` and `remove` functions are declared as public functions, but they should be internal functions. These functions are part of the library and should not be exposed to external callers.
35_2	5	insert	Invalid input validation	In the `insert` function, there are multiple input validations, such as checking if `lower < upper` and if `TickMath.MIN_TICK <= lower`. However, there is no validation to ensure that the `amount` parameter is greater than zero. Adding liquidity with an amount of zero does not make sense and can potentially cause unexpected behavior.
35_2	1	addIncentive	Access Control Vulnerability	The `addIncentive` function is public and allows anyone to add incentives without any access control checks. This could lead to unauthorized incentives being added to the contract.
35_2	2	claimReward	Front-Running	The `claimReward` function is susceptible to front-running attacks because it does not use any mechanism to prevent them. An attacker can monitor pending transactions and submit their own transaction with a higher gas price to claim the reward before the original user, potentially causing a loss for the original user.
35_2	3	claimReward	Integer Overflow/Underflow	In the `claimReward` function, there is no explicit check for integer overflow or underflow while updating `incentive.rewardsUnclaimed` and `incentive.secondsClaimed`. Although unlikely, this could cause incorrect values in the calculation of the reward.
35_2	4	_transfer	Unchecked Return Values	The `_transfer` function, which is called in multiple places throughout the contract, does not check the return value of the underlying token transfer. This could potentially lead to an unnoticed failure of the transfer.
35_2	5	_transfer	Function Visibility	The `_transfer` function is an internal helper function that should not be exposed to external callers. It is not declared within the given smart contract but is assumed to be in one of the imported contracts. It should be declared as an internal function to prevent external access.
35_2	1	_getAssets	Function Visibility	The `_getAssets` function is an internal helper function that should not be exposed to external callers. It should be declared as an internal function to prevent external access.
35_2	2	_transfer	Function Visibility	The `_transfer` function is an internal helper function that should not be exposed to external callers. It should be declared as an internal function to prevent external access.
35_2	3	collect	Reentrancy Vulnerability	The `collect` function is vulnerable to reentrancy attacks because it performs external calls to the `_transfer` function, which in turn calls the BentoBox contract, without implementing proper reentrancy guards. An attacker might be able to call back into the contract during the transfer, potentially causing unexpected behavior.
35_2	4	_transfer	Unchecked Return Values	The `_transfer` function, which is called in multiple places throughout the contract, does not check the return value of the underlying token transfer or the BentoBox transfer. This could potentially lead to an unnoticed failure of the transfer.
35_2	5	burn	Front-Running	The `burn` function is susceptible to front-running attacks because it does not use any mechanism to prevent them. An attacker can monitor pending transactions and submit their own transaction with a higher gas price to burn the position before the original user, potentially causing a loss for the original user.
30_2	1	inCaseTokensGetStuck	Lack of input validation	The function `inCaseTokensGetStuck` allows the strategist to transfer any amount of any token from the controller to the treasury. However, it lacks input validation for the _amount parameter. If the _amount is greater than the balance of the token in the controller, the function may result in an undesired token transfer. To prevent this, it's necessary to add a check to ensure that the requested _amount is less than or equal to the controller's token balance.
30_2	2	withdraw	Reentrancy	The `withdraw` function is prone to reentrancy attacks as it updates the `_vaultDetails[msg.sender].balance` after transferring tokens to `msg.sender`. A malicious vault contract can call back into the `withdraw` function, causing the vault balance to be updated multiple times, potentially draining the controller's funds. To mitigate this risk, the contract should follow the "Checks-Effects-Interactions" pattern by updating the balance before performing the token transfer.
30_2	3	setCap	Lack of input validation	The `setCap` function is missing input validation checks for the `_cap` and `_convert` parameters. Since the `_cap` parameter is used to limit the balance of the strategy, it is necessary to ensure that it is a positive value. Additionally, the `_convert` parameter should be checked against a list of valid token addresses to avoid potential loss of funds in case of a wrong token address being passed.
30_2	4	Various functions	Inconsistent use of SafeMath	Although SafeMath is used in most places throughout the contract, it is not consistently applied. For instance, in functions like `setCap`, `_balance.sub(_cap)` is used, while in others, such as `withdraw`, `_amount = _amount.sub(_balance);` is used. It is essential to apply SafeMath consistently across the contract to ensure protection against integer overflows and underflows.
30_2	5	Various functions	Centralization risk	The contract relies heavily on the strategist role, which introduces centralization risks. Functions such as `inCaseTokensGetStuck`, `inCaseStrategyGetStuck`, `setInvestEnabled`, `setMaxStrategies`, and others can only be called by the strategist, giving them significant control over the contract. It may be worth considering a more decentralized governance model or introducing multi-signature capabilities to mitigate this risk.
29_2	1	flashSwap	Reentrancy vulnerability	The `flashSwap` function in the smart contract calls an external contract using `ITridentCallee(msg.sender).tridentSwapCallback(context);` without having updated the state of the contract. This could potentially introduce a reentrancy vulnerability where the external contract can call the `flashSwap` function again before the state is updated, leading to an unintended behavior.
29_2	2	_subFlag	Integer overflow/underflow	The `_subFlag` function uses the `unchecked` keyword when calculating the difference between `a` and `b`, which may lead to integer overflow or underflow. This can cause unexpected results when used in other calculations.
28_2	1	initToken	Access control	The initToken function is public and does not have any access control. This allows anyone to call the function, mint tokens, and modify the roles. This can lead to unauthorized access and unintended token minting.
28_2	2	_beforeTokenTransfer	Reentrancy	The _beforeTokenTransfer function is called before the actual transfer of tokens takes place in the ERC20 contract. The function contains a call to _moveDelegates, which emits an event (DelegateVotesChanged). This could make the contract vulnerable to reentrancy attacks if it interacts with external contracts. To prevent this vulnerability, consider using the Checks-Effects-Interactions pattern or the OpenZeppelin ReentrancyGuard.
28_2	3	initToken	Missing input validation	The initToken function does not validate the input parameters. Specifically, it does not check if the _initialSupply is within a reasonable range. This can lead to an unexpected token supply or even integer overflow issues. To prevent this, consider adding input validation checks to ensure that the supplied values are within acceptable limits.
21_2	1	unstake	Integer Division Precision Loss	In the 'unstake' function, the amount of tokens to be unstaked is calculated as follows:
21_2	2	depositProtocolBalance	No revert case for Zero Value Inputs	In the 'depositProtocolBalance' function, there is a require statement to check if _amount is greater than 0:
21_2	3	withdrawProtocolBalance	No revert case for Zero Value Inputs	In the 'withdrawProtocolBalance' function, there is a require statement to check if _amount is greater than 0:
19_3	2	prepare, fulfill, cancel	Front-running	The contract does not implement any specific measures to prevent front-running attacks. Attackers may observe pending transactions and attempt to front-run users by submitting transactions with higher gas prices. This can be particularly harmful in the `prepare`, `fulfill`, and `cancel` functions, where users may be competing to interact with the contract in time-sensitive situations.
20_3	1	_handleTransferIn	Re-entrancy vulnerability	The _handleTransferIn function is vulnerable to a re-entrancy attack because it performs an external call using the `transferFrom` function to transfer tokens, and the state of the contract is not updated before that call. If the token being transferred is maliciously implemented, it can call back into the contract before the transferFrom call is finished, causing unexpected behavior or allowing the attacker to drain funds.
20_3	2	decreaseAllowance	Missing input validation	In the decreaseAllowance function, there is no validation to check if the subtractedValue is greater than or equal to 0. This could lead to an underflow if a negative value is passed to the function, which might cause unintended behavior.
20_3	3	_burn	Missing input validation	The _burn function does not check if the amount to be burned is greater than 0. This could lead to unintended behavior if the function is called with an amount of 0.
20_3	4	_approve, increaseAllowance	No check for integer overflow	In the _approve and increaseAllowance functions, there is no check for integer overflow when updating the allowance. If the allowance goes beyond the maximum value of uint256, it will wrap around to a smaller value, which might cause unintended behavior.
20_3	5	approveAndCall, transferAndCall	Unchecked external call	In the approveAndCall and transferAndCall functions, there is an external call to iBEP677(recipient).onTokenApproval and iBEP677(recipient).onTokenTransfer functions. There is no check for the return value of these calls, which may lead to potential issues if the external contract returns an unexpected value or fails.
20_3	1	removeLiquidityExact	Reentrancy	The function removeLiquidityExact allows for removing liquidity from the pool. After transferring the pool tokens from the user to the pool, it calls the Pool(_pool).removeForMember(_member) function (or Pool(_pool).remove() if token is address(0)). Since the implementation of these functions is not provided, if they include external calls (e.g., token transfers) and have not properly implemented reentrancy protection, this could lead to a reentrancy attack.
20_3	2	_handleTransferOut	Unchecked external call	In the _handleTransferOut function, the external call payable(_recipient).call{value:_amount}(""); does not check for the success of the call. This might lead to a situation where the transfer of funds fails silently without reverting the transaction, potentially causing loss of funds or other unexpected behavior.
20_3	3	revenueDetails	Integer Overflow and Underflow	The revenueDetails function calculates the updated revenue for the pool by incrementing mapAddress_30DayDividends[_pool] by _fees. If _fees are very large, this could cause an integer overflow and result in an incorrect revenue amount being stored. Proper checks or the use of SafeMath library should be implemented to prevent this issue.
20_3	4	getsDividend	Function visibility	The getsDividend function is marked as internal but is not used by any other function within the contract. This might be a design flaw as the function is not utilized, and it could potentially be removed or its visibility changed to match the intended use.
20_3	5	_handleTransferIn	Incorrect implementation of WBNB deposit and withdrawal	The _handleTransferIn function tries to deposit native BNB into the WBNB contract by calling payable(WBNB).call{value: _amount}("");. This is not the correct way to deposit BNB into WBNB. Instead, it should be done using the deposit function provided by the WBNB contract (i.e., iWBNB(WBNB).deposit{value:_amount}();).
20_3	1	transfer	Reentrancy	The 'transfer' function in the contract is vulnerable to a reentrancy attack. The function updates the balance (_balances) of the sender and recipient before emitting the Transfer event. An attacker can use a malicious contract to call the 'transfer' function again before the Transfer event is emitted, leading to an unexpected state of the contract and potential loss of tokens.
20_3	2	_approve	No checks on approval amount	The '_approve' function does not check if the new allowance amount is greater than or equal to the current allowance amount. An attacker can exploit this by front-running a user's transaction to set the allowance to a smaller value, and then, once the user's transaction is executed, setting the allowance back to a larger value. This can lead to unexpected behavior and potential token theft.
20_3	3	sync	No synchronization between internal and external token balances	The 'sync' function updates the internal state (baseAmount and tokenAmount) of the contract to match the external token balances. This function can be called by anyone, and there are no checks in place to prevent external manipulation of token balances between the sync function call and other contract functions that rely on these balances. This can lead to unexpected behavior and potential loss of tokens.
20_3	4	_addPoolMetrics	Function visibility	The '_addPoolMetrics' function is marked as 'internal', which means it can only be called from within the contract. However, it does not have any checks in place to prevent misuse by other internal functions. It's best to mark the function as 'private' to ensure it's only callable by the specific functions that require it.
20_3	5	addForMember, removeForMember, swapTo, mintSynth, burnSynth	Lack of input validation	Functions like 'addForMember', 'removeForMember', 'swapTo', 'mintSynth', and 'burnSynth' do not perform any input validation on the 'member' address parameter. It is possible to pass an address(0) as the 'member' parameter, which can lead to unexpected behavior, such as tokens being sent to the zero address or tokens being irretrievable. Adding a 'require' statement to check that the 'member' address is not equal to address(0) can mitigate this issue.
20_2	1	transfer	Reentrancy	There is a potential reentrancy vulnerability in the `transfer` function. It can be exploited if a malicious contract is the recipient of the transfer. The malicious contract could call back into the transfer function before the state is updated, allowing it to withdraw more tokens than intended. It is recommended to use the "checks-effects-interactions" pattern to mitigate this vulnerability.
20_2	2	sync	Missing access control	The `sync` function is missing access control, which allows any external account to call this function and potentially update the `baseAmount` and `tokenAmount` state variables. This can lead to manipulation of the pool balances by a malicious actor. To fix this issue, consider adding a modifier like `onlyOwner` or `onlyAdmin` to restrict access to this function.
20_2	3	addFee	Unbounded loop	The `addFee` function contains a loop that iterates through the `revenueArray`. Since there is no explicit length check or limitation on the length of `revenueArray`, an attacker could potentially increase the length of the array causing the loop to consume a large amount of gas leading to a Denial of Service (DoS) attack. Consider adding an explicit length check or limit to the `revenueArray` to mitigate this issue.
20_2	4	addForMember	No input validation	The `addForMember` function does not validate the input parameters, allowing a user to provide a zero address as the `member`. This could lead to tokens being minted to the zero address and being lost forever. Consider adding a require statement to check if the provided `member` address is not the zero address.
20_2	5	removeForMember	No input validation	The `removeForMember` function does not validate the input parameters, allowing a user to provide a zero address as the `member`. This could lead to tokens being transferred to the zero address and being lost forever. Consider adding a require statement to check if the provided `member` address is not the zero address.
20_2	1	transfer	Reentrancy	The `transfer` function in the contract does not implement any reentrancy guard. An attacker could potentially use a malicious contract to call back into the `transfer` function and execute a reentrancy attack, causing unintended behavior.
20_2	2	_addPoolMetrics	Timestamp dependence	The `_addPoolMetrics` function uses `block.timestamp` to check for the passage of time (lastMonth and 2592000). Miners can manipulate the block timestamp within a certain range, which could potentially lead to unexpected behavior in the contract.
20_2	3	mintSynth, burnSynth	No input validation for external contract calls	Both `mintSynth` and `burnSynth` functions make external calls to the iSYNTH contract without validating the provided synth address. This can potentially lead to malicious contract interaction or wrong contract interaction, causing unintended behavior.
20_2	4	transferAndCall, approveAndCall	No input validation for external contract calls	The `transferAndCall` and `approveAndCall` functions make external calls to iBEP677 contracts without validating the provided recipient address. This can potentially lead to malicious contract interaction or wrong contract interaction, causing unintended behavior.
20_2	5	sync	Lack of proper access control	The `sync` function updates the `baseAmount` and `tokenAmount` variables without any access control mechanism. This can allow any external user to call the function and potentially cause incorrect updates to the pool balances, leading to unexpected behavior.
20_2	1	mintSynth	Missing input validation	The function mintSynth does not validate if the provided 'amount' is greater than zero. This can lead to unwanted behavior when a user tries to mint synth with an amount of zero.
20_2	2	realise	Missing input validation	The function realise does not validate if the provided 'pool' address is a valid and non-zero address. This can lead to unwanted behavior and potential loss of funds when a user tries to call realise with an invalid or zero address.
20_2	3	_handleTransferIn	Front-running vulnerability	The function _handleTransferIn calculates the received amount by checking the difference in token balance before and after the transfer. This method is vulnerable to front-running attacks, where an attacker could manipulate the balances between the two balance checks, causing incorrect calculations for the actual received amount.
20_2	4	burnSynth	Reentrancy vulnerability	The function burnSynth does not use the Checks-Effects-Interactions pattern, which could lead to reentrancy attacks. The function first updates the contract's state variables, then calls an external contract (Pool) to burn the LP tokens. An attacker could exploit this by having the external contract call back into the burnSynth function before the original call has completed, potentially causing unintended behavior or a loss of funds.
19_2	3	prepare	Missing input validation	The function `prepare` lacks input validation for `invariantData.callDataHash`. This value should be checked for emptiness to avoid potential issues related to empty call data hash.
19_2	4	N/A	Front-running attacks	There are no measures to protect against front-running attacks in this contract. Users who submit transactions with low gas prices may have their transactions delayed or front-run by others. It is up to the user to ensure that they use appropriate gas prices to mitigate this risk.
19_2	5	fulfill	Use of unsafe `approve` function	The function `fulfill` uses the `LibERC20.approve` function to set allowances for ERC20 tokens. This function might be prone to allowance race conditions if the allowance is not set to zero before updating it to a new non-zero value. Consider using a safe approval pattern or the `increaseAllowance` and `decreaseAllowance` functions instead.
5_2	3	approve	Unlimited Approval	The approve function allows for unlimited approval, which could potentially be exploited by attackers in combination with the transferFrom function. An attacker may repeatedly call transferFrom before the token owner has a chance to modify their allowance, draining more tokens than initially intended. To mitigate this risk, it is recommended to first set the allowance to 0 before setting it to a new amount.
5_2	4	init	Unprotected function	The init function can be called by any address, as there are no access control restrictions. This may allow an attacker to initialize the contract with malicious addresses for VETHER, USDV, and UTILS. It is recommended to add a modifier (e.g., onlyDAO) to restrict access to the init function.
5_2	1	init	Unprotected function call	The `init` function can be called by any address, not just the DAO or the contract owner. This can lead to unauthorized setting of key contract addresses, which may lead to loss of funds or other unintended consequences. To fix this issue, add a modifier that only allows the contract owner or the DAO to call the `init` function.
5_2	2	depositForMember	Missing input validation	The `depositForMember` function does not have a check to ensure that the `amount` being deposited is greater than zero. This can lead to unnecessary function calls and event emissions for deposits with zero value. To fix this issue, add a require statement to check if the deposited amount is greater than zero.
5_2	3	withdraw	Re-entrancy vulnerability	The `withdraw` function sends tokens to the member using `sendFunds` before updating the state variables in `_processWithdraw`. This can lead to a re-entrancy vulnerability where a malicious contract can exploit the function to drain the funds. To fix this issue, move the state updates before sending funds in the `_processWithdraw` function.
5_2	4	setParams	Missing input validation	The `setParams` function does not have any validation checks on the input parameters. This can lead to unintended consequences, such as setting a very low `newEra` or `newDepositTime`. To fix this issue, add require statements to validate the input parameters based on the expected business logic.
5_2	5	grant	Unprotected function call	The `grant` function can only be called by the DAO, but there is no additional protection against potential governance attacks. To increase security, consider adding a timelock or multisig to the function, so that grants are not executed immediately and have a chance to be reviewed by the community.
3_2	1	getLastDepositBlock	Missing access control	The function getLastDepositBlock is missing access control, which allows any external address to query the last deposit block of a trader. While this might not be a critical vulnerability, it might expose sensitive information that could be used in combination with other exploits.
3_2	2	min	Missing access control	The function min is marked as internal, but it should be marked as private to prevent any unintended access from derived contracts.
3_2	1	setTokenCap	Access control vulnerability	The setTokenCap function relies on the isTokenActivator function to check if the caller is authorized to modify the token cap. However, the isTokenActivator function is not defined in the provided smart contract. This could lead to unintended access control behavior and could potentially be exploited by malicious actors.
3_2	2	registerDeposit, registerBorrow, registerWithdrawal, registerOvercollateralizedBorrow, registerTradeAndBorrow, registerLiquidation	Access control vulnerability	All of these functions rely on the isMarginTrader function to check if the caller is authorized to perform the respective operations. However, the isMarginTrader function is not defined in the provided smart contract. This could lead to unintended access control behavior and could potentially be exploited by malicious actors.
