A193_3	1	price	The price function calculates the price of the fractional tokens based on the reserves of the base token and the fractional tokens. It is defined as: (_baseTokenReserves() * ONE) / fractionalTokenReserves(). Since the contract allows users to add and remove liquidity, buy, and sell tokens, they can influence the reserves of the base and fractional tokens. Consequently, users can manipulate the price by influencing the reserves through these functions.
A83_3	1	enableUnlock	The `enableUnlock` function allows the KPI oracle to enable withdrawals of the USDM token. If the KPI oracle is malicious or compromised, it may enable withdrawals at an unfavorable time, thus potentially manipulating the price.
A83_3	2	provide	The `provide` function adds liquidity to the usdm3crv pool, which may be used to manipulate the price of USDM or pool3 tokens. An attacker could potentially add a large amount of liquidity, causing the price to change in their favor.
A83_3	3	removeLiquidity	The `removeLiquidity` function allows the removal of liquidity from the usdm3crv pool, which can also potentially affect the price of USDM or pool3 tokens. If a guardian were to remove a large amount of liquidity, it could cause the price to move in an unfavorable direction for other users.
A83_3	4	deposit	The `deposit` function allows users to deposit USDM and pool3 tokens into the contract. A malicious user may deposit a large amount of tokens to manipulate the price or liquidity in the contract.
A83_3	5	withdraw	The `withdraw` function allows users to withdraw USDM and pool3 tokens from the contract when withdrawals are enabled. An attacker may withdraw a large amount of tokens to manipulate the price or liquidity in the contract.
A78_3	1	purchasePyroFlan	The `purchasePyroFlan` function calculates the current price of Flan based on the balances of Flan and stablecoin in the Uniswap liquidity pool (flanLP). The contract then mints new Flan and adds liquidity to the pool, which results in a price tilt. The tilted price is calculated again based on the updated balances of Flan and stablecoin in the flanLP. There is a check in place to ensure that the tilted price is below the `acceptableHighestPrice` for the stablecoin to prevent price manipulation. However, this approach is still vulnerable to price manipulation through flash loans, as an attacker could manipulate the balances of Flan and stablecoin in the flanLP to artificially increase or decrease the price of Flan. This could be exploited to mint more PyroFlan than intended or disrupt the Flan ecosystem.
A78_3	1	setEYEBasedAssetStake	The 'setEYEBasedAssetStake' function allows users to stake their assets and increase their daily fate rewards. The function calculates the amount of EYE tokens based on the staked asset and the user's selected strategy (directRoot or indirectTwoRootEye). However, there is a potential for price manipulation due to the lack of a reliable oracle to determine the EYE token's price. Since this function relies on the EYE token balance in the staking asset, an attacker could artificially inflate or deflate the EYE balance to manipulate the calculated rewards.
A78_3	2	burnAsset	The 'burnAsset' function allows users to burn their assets in exchange for fate tokens. The amount of fate tokens received depends on the EYE token balance of the burned asset. Similar to the 'setEYEBasedAssetStake' function, the lack of a reliable oracle to determine the EYE token's price makes this function susceptible to price manipulation. An attacker could manipulate the EYE token balance in the burned asset to receive more or less fate tokens than they should.
A193_2	1	price	The price function calculates the price of the fractional tokens using the baseTokenReserves and fractionalTokenReserves. It's calculated as (_baseTokenReserves() * ONE) / fractionalTokenReserves(). Since the contract fetches the baseTokenReserves and fractionalTokenReserves internally from the contract balances, manipulation of the reserves can impact the price. If an attacker can manipulate the token balances in the contract, they can influence the price calculation.
A193_2	2	buyQuote, sellQuote	The buyQuote and sellQuote functions are used to estimate the input/output amount for a trade. They are calculated using the baseTokenReserves and fractionalTokenReserves. For buyQuote, the calculation is (outputAmount * 1000 * baseTokenReserves()) / ((fractionalTokenReserves() - outputAmount) * 997). For sellQuote, the calculation is (inputAmount * 997 * baseTokenReserves()) / ((fractionalTokenReserves() * 1000) + (inputAmount * 997)). In both cases, manipulation of the baseTokenReserves or fractionalTokenReserves can influence the estimated input or output amounts for a trade.
A83_2	1	provide	In the 'provide' function, the contract takes the USDM token balance and provides liquidity to the usdm3crv pool by matching USDM and pool3 amounts in a 1:1 ratio. A malicious actor with control over the kpiOracle can manipulate the price of the USDM token and influence the amount of liquidity provided to the pool.
A83_2	2	removeLiquidity	The 'removeLiquidity' function allows a guardian to remove liquidity from the usdm3crv pool by burning LP tokens. A malicious actor with control over the kpiOracle can manipulate the price of the USDM token to influence the amount of liquidity removed from the pool.
A78_2	1	purchasePyroFlan	The `purchasePyroFlan` function takes stablecoin inputs, mints Flan and PyroFlan, and provides liquidity for Uniswap pairs to tilt the price of Flan higher. The current implementation uses the balance of tokens in Uniswap pairs to calculate the price, which is vulnerable to manipulation through flash loans or other techniques. This may result in artificial price increases for Flan and PyroFlan tokens. The function checks for price manipulation with the `acceptableHighestPrice` mapping, but this may not be sufficient to prevent all price manipulation attempts.
A78_2	1	setEYEBasedAssetStake	The 'setEYEBasedAssetStake' function allows users to stake EYE-based assets to increase their daily FATE rewards. The function calculates the asset's clout (FATE rewards) based on the amount of EYE staked in the asset. The calculation of FATE rewards relies on the EYE balance of the asset, which is fetched from the contract. If an attacker can manipulate the EYE balance of an asset, they can potentially manipulate the FATE rewards calculation and impact the overall FATE distribution.
A78_2	2	burnAsset	The 'burnAsset' function allows users to burn assets and receive FATE rewards. The amount of FATE created depends on the amount of EYE held by the asset. An attacker who can manipulate the EYE balance of an asset can impact the FATE rewards calculation in the 'burnAsset' function, potentially leading to unfair FATE distribution.
A193_1	1	price	The price function calculates the price of the fractional tokens based on the base token reserves and the fractional token reserves. It uses the formula: price = (baseTokenReserves * ONE) / fractionalTokenReserves. The base token reserves are fetched using the _baseTokenReserves() function, and the fractional token reserves are fetched using the balanceOf[address(this)] value. Since these values are internal to the contract and can be manipulated by the functions that change the baseTokenReserves and fractionalTokenReserves (like add, remove, buy, sell, wrap, unwrap), an attacker could potentially manipulate the price by calling these functions with a specific strategy.
A83_1	1	enableUnlock	The function enableUnlock can only be called by the kpiOracle. If the kpiOracle is compromised, an attacker could manipulate when the users can withdraw their USDM tokens, which could potentially affect the price.
A83_1	2	provide	The provide function, which can only be called by a guardian, allows for adding liquidity to the USDM-POOL3 curve pool. A malicious guardian could add or withhold liquidity to manipulate the pool's price.
A83_1	3	removeLiquidity	The removeLiquidity function, also only callable by a guardian, allows for removing liquidity from the USDM-POOL3 curve pool. A malicious guardian could remove liquidity to manipulate the pool's price.
A52_1	null
A52_1	null
A52_1	null
A52_1	1	_swap	The _swap function can be potentially manipulated due to its reliance on external data fetched from the pool contract. The pool contract calculates the conversion rate between assets, and if the pool contract is manipulated or has incorrect pricing data, it would lead to inaccurate conversions and potential price manipulation. The manipulation could occur due to oracle attacks or front-running in the pool contract, which would have a cascading effect on the smart contract relying on that data.
A42_3	1	distributeMochi	In the distributeMochi function, the contract is using the Uniswap V2 router to swap USDM tokens for Mochi tokens. Since the contract relies on the Uniswap V2 router for obtaining Mochi tokens, an attacker can potentially manipulate the price oracle by placing large trades to skew the price on Uniswap before calling the distributeMochi function. This would allow the attacker to buy Mochi tokens at a manipulated price, which could lead to an unfair distribution of Mochi tokens.
A42_3	2	_buyMochi	The _buyMochi function is also susceptible to price oracle manipulation for the same reasons mentioned above for the distributeMochi function. It relies on the Uniswap V2 router to swap USDM tokens for Mochi tokens, which could be manipulated by an attacker through large trades on Uniswap. This would allow the attacker to obtain Mochi tokens at an artificially skewed price.
A42_3	1	veCRVInitialize	In the veCRVInitialize function, the contract uses the Uniswap V2 router to swap USDM tokens for CRV tokens in the _buyCRV function. Since the contract relies on the Uniswap V2 router for obtaining CRV tokens, an attacker can potentially manipulate the price oracle by placing large trades to skew the price on Uniswap before calling the veCRVInitialize function. This would allow the attacker to buy CRV tokens at a manipulated price, which could lead to an unfair distribution of CRV tokens.
A42_3	2	veCRVlock	The veCRVlock function is also susceptible to price oracle manipulation for the same reasons mentioned above for the veCRVInitialize function. It relies on the Uniswap V2 router to swap USDM tokens for CRV tokens in the _buyCRV function, which could be manipulated by an attacker through large trades on Uniswap. This would allow the attacker to obtain CRV tokens at an artificially skewed price.
A23_3	1	getNetCashGroupValue	The `getNetCashGroupValue` function indirectly uses external data through the `cashGroup.calculateOracleRate` function, which fetches the oracle rate for a given maturity and block time. This oracle rate is then used to calculate the risk-adjusted present value of an fCash asset within the function. Since the oracle rate comes from an external source, it could potentially be manipulated, leading to incorrect calculations and potentially causing an impact on the smart contract's overall operation.
A23_3	2	getLiquidityTokenValue	The `getLiquidityTokenValue` function also uses external data through the `market.oracleRate`, which is loaded in the function using `cashGroup.loadMarket` function. The market oracle rate is then used to calculate the present value of the fCash claim or the risk-adjusted present value. As with the previous function, the oracle rate comes from an external source and could be manipulated, affecting the calculations within the smart contract.
A42_2	1	distributeMochi	The distributeMochi function is responsible for buying Mochi with the mochiShare, which is executed through the _buyMochi internal function. This process fetches price data from Uniswap by using the IUniswapV2Router02's swapExactTokensForTokens function. An attacker can manipulate the price of the Mochi token on Uniswap by executing a sandwich attack, for instance, by placing large buy and sell orders around the target transaction. This manipulation can lead to an incorrect price feed, which could result in the FeePoolV0 contract buying Mochi at an inflated or deflated price.
A42_2	2	distributeMochi	The distributeMochi function also shares the bought Mochi tokens between the vMochi vault and the crvVoterRewardPool, which is executed through the _shareMochi internal function. The price manipulation mentioned in the first sequence can impact the distribution of Mochi tokens to these pools. If the Mochi token price is manipulated, the contract might distribute an incorrect amount of tokens to the vMochi vault and crvVoterRewardPool, leading to potentially unfair allocations for users participating in these pools.
A42_2	1	veCRVInitialize	The veCRVInitialize function calls the _buyCRV internal function to buy CRV tokens with veCRVShare. This function fetches price data from Uniswap by using the IUniswapV2Router02's swapExactTokensForTokens function. An attacker can manipulate the price of the CRV token on Uniswap by executing a sandwich attack, for instance, by placing large buy and sell orders around the target transaction. This manipulation can lead to an incorrect price feed, which could result in the MochiTreasuryV0 contract buying CRV at an inflated or deflated price.
A42_2	2	veCRVlock	The veCRVlock function calls the _buyCRV internal function to buy CRV tokens with veCRVShare before locking them in the veCrv contract. The price manipulation mentioned in the first sequence can impact the amount of CRV tokens bought and subsequently locked. If the CRV token price is manipulated, the contract might lock an incorrect amount of tokens in the veCrv contract, leading to potentially unfair allocations for users participating in the system.
A23_2	1	getNetCashGroupValue	The `getNetCashGroupValue` function calculates the present value of assets and underlying assets by calling `getLiquidityTokenValue` and `getRiskAdjustedPresentValue`. Both of these functions depend on oracle rates provided by the `cashGroup.calculateOracleRate` function. A potential attack vector for price manipulation is through the oracle rates used in these calculations. If an attacker can manipulate the oracle rates, they can influence the value of the assets and underlying assets in the smart contract.
A42_1	1	distributeMochi	The distributeMochi function calls the internal functions _buyMochi and _shareMochi. The _buyMochi function fetches external data from the Uniswap router to swap USDM for Mochi tokens. Since Uniswap uses an automated market maker model, it is vulnerable to price manipulation attacks, such as sandwich attacks or front-running. This can impact the price of Mochi tokens when they are being bought in this function, potentially leading to losses for the smart contract.
A42_1	2	_buyMochi	In the _buyMochi function, the smart contract fetches external data from the Uniswap router to swap USDM for Mochi tokens. As mentioned earlier, since Uniswap uses an automated market maker model, it is vulnerable to price manipulation attacks. An attacker can manipulate the price oracle by trading large volumes of tokens right before or after this function is called, which can lead to incorrect token prices and affect the outcome of the swap.
A42_1	3	_shareMochi	In the _shareMochi function, the smart contract fetches external data from the Mochi token balance to distribute Mochi to vMochi Vault and veCRV Holders. Although there isn't a direct price oracle manipulation in this function, if the price oracle is manipulated in the _buyMochi function, it will affect the Mochi token balance and the amounts distributed in this function. This can lead to incorrect distribution of rewards and losses for the participants in the smart contract.
A42_1	1	veCRVInitialize	The veCRVInitialize function calls the internal function _buyCRV to swap USDM for CRV tokens using the Uniswap router. As Uniswap relies on an automated market maker model, it is vulnerable to price manipulation attacks such as sandwich attacks or front-running. This can impact the price of CRV tokens when they are being bought in this function, potentially leading to losses for the smart contract.
A42_1	2	_buyCRV	In the _buyCRV function, the smart contract fetches external data from the Uniswap router to swap USDM for CRV tokens. Since Uniswap uses an automated market maker model, it is vulnerable to price manipulation attacks. An attacker can manipulate the price oracle by trading large volumes of tokens right before or after this function is called, which can lead to incorrect token prices and affect the outcome of the swap.
A42_1	3	veCRVlock	The veCRVlock function calls the internal functions _buyCRV and _lockCRV. Although there isn't a direct price oracle manipulation in the _lockCRV function, the _buyCRV function is vulnerable to price manipulation attacks, as explained earlier. If the price oracle is manipulated in the _buyCRV function, it will affect the CRV token balance and the amounts locked in the veCRVlock function. This can lead to incorrect locking of funds and losses for the participants in the smart contract.
A23_1	1	getRiskAdjustedPresentValue	In the getRiskAdjustedPresentValue function, the oracle rate is used to calculate the present value of an fCash asset with risk adjustments. Since the oracle rate is fetched from an external source, manipulating the oracle rate would directly impact the calculated present value of an fCash asset in the smart contract, potentially affecting the overall valuation of the assets.
A23_1	2	getLiquidityTokenValue	The getLiquidityTokenValue function calculates the asset cash claim and the present value of the fCash asset (if it exists) using the market oracle rate. As the market.oracleRate is fetched from an external source, price manipulation could occur if the oracle rate is manipulated. The manipulated oracle rate will affect the present value calculations for the fCash assets.
A23_1	3	getNetCashGroupValue	The getNetCashGroupValue function calculates the present value of assets in the cash group using the oracle rate fetched from the cash group through the calculateOracleRate method. This external dependency on the oracle rate means that if the oracle rate is manipulated, the present value calculations for the assets in the cash group would be affected, resulting in potential price manipulation.
A20_3	1	mintSynth	The mintSynth function mints synthetic tokens based on the received LP tokens. However, the contract relies on external data fetched from the DAO's UTILS contract (iUTILS) to calculate the actual value of the synthetic tokens to mint. An attacker could potentially manipulate the price oracle used by the UTILS contract to impact the minted synthetic tokens' value.
A20_3	2	burnSynth	Similar to the mintSynth function, the burnSynth function relies on external data fetched from the DAO's UTILS contract to calculate the value of synthetic tokens to burn. An attacker could manipulate the price oracle used by the UTILS contract, which would impact the number of synthetic tokens and LP tokens being burned.
A20_3	3	realise	The realise function calculates the value of LP tokens and synthetic tokens using external data fetched from the DAO's UTILS contract. It then burns the premium of the LP tokens if the LP tokens' value exceeds the synthetic tokens' value. An attacker could manipulate the price oracle used by the UTILS contract, impacting the values of the LP and synthetic tokens, and potentially causing an incorrect burning of LP tokens.
A20_3	1	harvestSingle	The smart contract relies on external data fetched via iUTILS(_DAO().UTILS()).calcSpotValueInBase(iSYNTH(_synth).LayerONE(), _amount) to determine the weight of user's deposit and the value of the reward. Since the weight calculation depends on the price of the underlying asset (LayerONE token) fetched from an external oracle, a malicious actor with the ability to manipulate the oracle can influence the weight calculation and, consequently, the rewards distribution in the SynthVault.
A20_3	1	swap	In the swap function, external price data is fetched from the pool contracts. If an attacker can manipulate the price of tokens in these pools, they can create artificial arbitrage opportunities and exploit them, leading to incorrect token prices and potential losses for other users.
A20_3	1	calcSwapOutput	The 'calcSwapOutput' function calculates the output of a swap based on the input amount, the token reserves, and the base reserves. The function uses the formula `y = (x * X * Y) / (x + X)^2`. An attacker can manipulate the oracle price by manipulating the reserves of the pool, i.e., changing the values of X and Y, which will affect the swap output.
A20_3	2	calcSwapFee	The 'calcSwapFee' function calculates the swap fee based on the input amount, the token reserves, and the base reserves. The function uses the formula `y = (x * x * Y) / (x + X)^2`. Similar to the 'calcSwapOutput' function, an attacker can manipulate the oracle price by manipulating the reserves of the pool, i.e., changing the values of X and Y, which will affect the swap fee calculation.
A20_3	3	calcSpotValueInBaseWithPool	The 'calcSpotValueInBaseWithPool' function calculates the spot value of a token in the base currency using the pool address and the amount of the token. The function uses the formula `(amount * baseAmount) / tokenAmount`. An attacker can manipulate the price oracle by altering the baseAmount and tokenAmount values, affecting the spot value calculation.
A20_3	4	calcSpotValueInTokenWithPool	The 'calcSpotValueInTokenWithPool' function calculates the spot value of the base currency in the token using the pool address and the amount of the base currency. The function uses the formula `(amount * tokenAmount) / baseAmount`. Similar to the 'calcSpotValueInBaseWithPool' function, an attacker can manipulate the price oracle by altering the baseAmount and tokenAmount values, affecting the spot value calculation.
A16_3	1	recordTrade	The 'recordTrade' function relies on an external price oracle (Chainlink) to fetch the current oracle price. The function calls 'oracle.latestAnswer()' which can be manipulated if the oracle's data sources are compromised or if the oracle itself is manipulated. This can lead to incorrect prices being recorded, and may affect the contract's other functions such as updating funding rates, insurance funding rates, or time values.
A3_3	1	getPriceFromAMM	The function getPriceFromAMM retrieves the price from the AMM, but it has some potential for price manipulation. The contract checks if the output amount is within a predefined range (UPDATE_MIN_PEG_AMOUNT and UPDATE_MAX_PEG_AMOUNT) before updating the token price. An attacker could manipulate the price in the AMM by placing large orders to force the output amount outside of the predefined range, causing the contract to not update the price. This manipulation could lead to incorrect pricing data being used in the smart contract.
A3_3	2	setLiquidationPath	The function setLiquidationPath sets the liquidation path from a given token to the current liquidation peg. The path and tokens are provided externally and not verified within the contract, which may leave the contract vulnerable to price manipulation. An attacker could provide a custom path that includes a manipulated token price in the AMM or even a malicious AMM contract. This could lead to incorrect pricing data being used in the smart contract, impacting the liquidation process and other contract functions that rely on accurate pricing information.
A20_2	1	realise	The 'realise' function is vulnerable to price manipulation through oracle manipulation. This function calculates the value of the LP tokens (baseValueLP) and the value of the synths (baseValueSynth) by querying external contracts, which fetch data from external sources. If an attacker can manipulate these external sources, they can create a significant difference between baseValueLP and baseValueSynth, leading to the burning of an incorrect amount of LP tokens. This can result in an unfair distribution of tokens and impact the overall market.
A20_2	2	mintSynth	The 'mintSynth' function is also vulnerable to price manipulation through oracle manipulation. In this function, the received LP units are calculated using '_getAddedLPAmount' function. If the attacker can manipulate the price oracle used to determine the LP units, they can artificially inflate or deflate the value of the underlying assets. This can lead to incorrect minting of synthetic tokens and impact the market.
A20_2	1	harvestSingle	In the `harvestSingle` function, the `calcCurrentReward` function is used to calculate the user's current reward. This function depends on the `calcReward` function, which in turn relies on external data fetched from the `iUTILS` contract to calculate the reward share. A price oracle manipulation in the `iUTILS` contract could potentially result in inaccurate reward calculations, which would affect the rewards distribution in the SynthVault contract.
A20_2	1	swapTo	In the 'swapTo' function, tokens are swapped from one token to another, including the BASE token. This can lead to price manipulation if an attacker manipulates the prices of external tokens before interacting with the smart contract. Additionally, the contract relies on the prices provided by the liquidity pools created in the Pool contract. An attacker could potentially manipulate the prices in the liquidity pools through flash loans or by providing a large amount of tokens in a single transaction, which could impact the prices used in the 'swapTo' function.
A20_2	2	buyTo	The 'buyTo' function allows a user to buy a token by transferring the BASE token. This function relies on the price provided by the Pool contract, which can be manipulated by an attacker through flash loans or providing large amounts of tokens in a single transaction. The manipulation of the price in the liquidity pools will affect the price used in the 'buyTo' function, leading to potential price manipulation.
A20_2	3	sellTo	In the 'sellTo' function, users can sell their tokens in exchange for the BASE token. Similar to the 'buyTo' function, this function relies on the price provided by the Pool contract, which can be manipulated by an attacker. The price manipulation in the liquidity pools will impact the price used in the 'sellTo' function, leading to potential price manipulation.
A20_2	4	swapAssetToSynth	The 'swapAssetToSynth' function allows users to swap an asset to a synth token. This function relies on the prices provided by the Pool contract and the synth tokens. An attacker could potentially manipulate the prices in the liquidity pools and synth tokens, impacting the prices used in the 'swapAssetToSynth' function, leading to potential price manipulation.
A20_2	5	swapSynthToAsset	The 'swapSynthToAsset' function allows users to swap a synth token to an asset. Similar to the 'swapAssetToSynth' function, this function relies on the prices provided by the Pool contract and the synth tokens. An attacker could potentially manipulate the prices in the liquidity pools and synth tokens, impacting the prices used in the 'swapSynthToAsset' function, leading to potential price manipulation.
A20_2	1	calcSpotValueInBaseWithPool	The calcSpotValueInBaseWithPool function calculates the value of a token amount in the base token by using the pool's baseAmount and tokenAmount. A potential price manipulation could occur if an attacker can manipulate the baseAmount or tokenAmount of the pool, which would subsequently affect the calculated value.
A20_2	2	calcSpotValueInTokenWithPool	Similarly to the calcSpotValueInBaseWithPool function, the calcSpotValueInTokenWithPool function calculates the value of a base token amount in the token by using the pool's baseAmount and tokenAmount. Price manipulation is also possible here if an attacker can manipulate the baseAmount or tokenAmount of the pool, affecting the calculated value.
A20_2	3	calcSwapValueInBaseWithPool	The calcSwapValueInBaseWithPool function calculates the output of swapping a token amount to the base token using the pool's baseAmount and tokenAmount. If an attacker can manipulate the baseAmount or tokenAmount of the pool, it would affect the swap output, leading to price manipulation.
A20_2	4	calcSwapValueInTokenWithPool	The calcSwapValueInTokenWithPool function calculates the output of swapping a base token amount to the token using the pool's baseAmount and tokenAmount. Just like the previous functions, price manipulation can occur if an attacker can manipulate the baseAmount or tokenAmount of the pool, affecting the swap output.
A16_2	1	recordTrade	In the `recordTrade` function, the `tradePrice` is used to update the hourly tracer prices. Since the `tradePrice` is not directly fetched from the oracle but passed as a function argument, it may be manipulated by an attacker to influence the hourly prices.
A16_2	2	updatePrice	The `updatePrice` function is called in the `recordTrade` function, and it also takes `marketPrice` and `oraclePrice` as input arguments. Since these arguments are passed down from the `recordTrade` function, they might be manipulated by an attacker to influence the hourly prices and eventually affect the funding rate and time value.
A16_2	3	fairPrice	The `fairPrice` function directly uses the `oracle.latestAnswer()` to calculate the fair price. If an attacker can manipulate the oracle's latest answer, it can result in an incorrect fair price. This can be mitigated by using a secure oracle implementation, but it's crucial to be aware of the possibility of oracle manipulation affecting the smart contract.
A16_2	4	get24HourPrices	The `get24HourPrices` function calculates the average 24-hour price for both the tracer and oracle prices. If an attacker is able to manipulate the input prices in the `recordTrade` and `updatePrice` functions, they can influence the 24-hour average prices returned by this function. This would eventually impact the time value calculation and other functions that rely on the 24-hour average prices.
A16_2	5	getHourlyAvgTracerPrice	The `getHourlyAvgTracerPrice` function calculates the hourly average price for a given tracer market. Since this function relies on the hourly tracer prices, which can be manipulated through the `recordTrade` and `updatePrice` functions, an attacker could influence the hourly average price for a tracer market.
A16_2	6	getHourlyAvgOraclePrice	The `getHourlyAvgOraclePrice` function calculates the hourly average price for a given oracle market. This function relies on the hourly oracle prices, which can be manipulated through the `recordTrade` and `updatePrice` functions. An attacker could influence the hourly average price for an oracle market, affecting the overall price calculation and funding rates.
A3_2	1	getPriceFromAMM	The getPriceFromAMM function fetches the price of a token from an external AMM (Automated Market Maker) and updates the stored price of the token. The prices fetched from external AMMs can be manipulated if a malicious actor has a substantial influence on the liquidity of the token. This could lead to incorrect price updates, affecting the smart contract's behavior.
A3_2	2	getCurrentPriceInPeg	The getCurrentPriceInPeg function retrieves the current price of the token in the pegged currency. The price is fetched by calling the getPriceFromAMM function, which is susceptible to price manipulation as explained above. If the price of the token is manipulated in the AMM, it will affect the price returned by this function as well.
A3_2	3	viewCurrentPriceInPeg	The viewCurrentPriceInPeg function is a view function that returns the current price of a token in the pegged currency. It calculates the price by using data fetched from external AMMs through UniswapStyleLib.getAmountsOut, which can be manipulated if a malicious actor has a significant influence on the liquidity of the token. This can lead to incorrect price estimations, impacting the contract's behavior.
A20_1	1	mintSynth	The mintSynth function allows a pool to mint new synthetic tokens based on the amount of LP tokens added. However, there is no validation on the price oracles used to determine the value of the underlying assets. An attacker could manipulate the oracle to create an inaccurate price, allowing them to mint more synthetic tokens than they should be able to. This would result in an imbalanced pool and potential losses for other participants.
A20_1	2	burnSynth	The burnSynth function allows users to burn synthetic tokens and receive LP tokens in return. Similar to mintSynth, the function relies on external price data to calculate the amount of LP tokens to return. If an attacker manipulates the oracle to provide an inaccurate price, they could receive more LP tokens than they should, causing an imbalance in the pool and potential losses for other participants.
A20_1	3	realise	The realise function is designed to burn excess LP tokens when their value outweighs the value of the synthetic token supply. The function relies on external price data to calculate the value of LP tokens and synthetic tokens. If an attacker manipulates the oracle, they could cause the function to burn more or less LP tokens than necessary, leading to imbalances in the pool and potential losses for other participants.
A20_1	1	harvestSingle	The smart contract fetches external data such as prices through the iUTILS contract. The iUTILS contract calculates prices based on the liquidity pools in the DAO, which are external to the SynthVault contract. The calcCurrentReward and calcReward functions, which are used by the harvestSingle function, rely on these external prices to calculate rewards for the user. If an attacker can manipulate the prices in the liquidity pools, they could potentially manipulate the rewards distribution, causing incorrect reward payouts. This could lead to the exploitation of the SynthVault contract and have an impact on the price of various tokens in the system.
A20_1	1	swapTo	The 'swapTo' function allows swapping of tokens in the contract. The external data is fetched from the '_DAO()' function that returns the DAO's address, which is used to fetch the pool factory. However, price oracle manipulation could potentially occur if an attacker manipulates the price of the tokens in the pool, leading to an incorrect valuation of the tokens being swapped, causing potential losses for the users interacting with the smart contract. This is also applicable to other functions that use '_DAO()' to fetch pool-related information such as 'addLiquidity', 'zapLiquidity', 'removeLiquidity', etc.
A20_1	2	swapAssetToSynth	The 'swapAssetToSynth' function allows swapping of assets to synthetic assets. It fetches data from the '_DAO()' function to obtain the pool factory and eventually the pool. Price oracle manipulation could occur if the price of the synthetic asset is manipulated, leading to an incorrect valuation of the synthetic asset being minted, causing potential losses for the users interacting with the smart contract.
A20_1	3	swapSynthToAsset	The 'swapSynthToAsset' function allows swapping of synthetic assets to other assets. It fetches data from the '_DAO()' function to obtain the pool factory and eventually the pool. Price oracle manipulation could occur if the price of the synthetic asset is manipulated, leading to an incorrect valuation of the synthetic asset being burned, causing potential losses for the users interacting with the smart contract.
A20_1	1	calcSpotValueInBaseWithPool	The function calcSpotValueInBaseWithPool calculates the value of an amount in the base token, given a pool. However, it relies on data fetched from external contracts (iPOOL(pool).baseAmount() and iPOOL(pool).tokenAmount()), which can be manipulated by malicious actors, potentially impacting the calculated spot value in the base token.
A20_1	2	calcSpotValueInTokenWithPool	Similar to calcSpotValueInBaseWithPool, calcSpotValueInTokenWithPool calculates the value of an amount in a token given a pool, and it also relies on the same external data (iPOOL(pool).baseAmount() and iPOOL(pool).tokenAmount()). As a result, this function is also susceptible to price manipulation.
A20_1	3	calcSwapValueInBaseWithPool	The function calcSwapValueInBaseWithPool calculates the value of an amount after a swap in the base token, given a pool. This function uses external data fetched from iPOOL(pool).baseAmount() and iPOOL(pool).tokenAmount(). Since these external data points can be manipulated, this function is vulnerable to price manipulation.
A20_1	4	calcSwapValueInTokenWithPool	The function calcSwapValueInTokenWithPool calculates the value of an amount after a swap in a token, given a pool. It also relies on external data from iPOOL(pool).baseAmount() and iPOOL(pool).tokenAmount(), which makes it susceptible to price manipulation if these data points are manipulated.
A16_1	1	recordTrade	The function 'recordTrade' updates pricing information and uses the external oracle's latest answer through 'uint256 currentOraclePrice = oracle.latestAnswer();'. This exposes the contract to potential price oracle manipulation. An attacker could manipulate the oracle's data, thus influencing the pricing information in the smart contract, which could lead to incorrect funding rates and other consequences.
A16_1	2	fairPrice	The 'fairPrice' function returns the fair price by using the external oracle's latest answer through 'oracle.latestAnswer()'. This exposes the contract to potential price oracle manipulation. An attacker could manipulate the oracle's data, which would lead to an incorrect fair price being returned, possibly affecting the decision-making process of the smart contract's users.
A3_1	1	getPriceFromAMM	In this smart contract, the getPriceFromAMM function is responsible for fetching the price of a token from the AMM (Automated Market Maker). While the contract does have some mechanisms in place to prevent price manipulation, the getPriceFromAMM function can still be susceptible to manipulation. The reason being that it relies on the external data provided by the AMM, which can be subject to manipulation through methods like sandwich attacks or flash loans. An attacker could temporarily manipulate the prices on the AMM and influence the token prices fetched by the getPriceFromAMM function.
A3_1	2	getCurrentPriceInPeg	The getCurrentPriceInPeg function is responsible for determining the current price of a token in the peg. This function relies on the prices fetched by the getPriceFromAMM function, which, as mentioned earlier, can be manipulated. Therefore, any manipulation in getPriceFromAMM can also affect the getCurrentPriceInPeg function. This can potentially lead to incorrect price estimations and impact the entire smart contract's functionality.
A70_3	1	cumulativePrices	The function `cumulativePrices` calculates the price of the native asset (e.g., Ether) in terms of the foreign asset (e.g., an ERC20 token) based on the reserves stored in the contract. It calculates the price using the FixedPoint library, which may have rounding errors or limitations in precision. An attacker could manipulate the price by executing trades that exploit these rounding errors or limitations, leading to incorrect price calculations.
A70_3	2	mintSynth	The `mintSynth` function allows users to deposit native assets and receive synthetic tokens in return. The amount of synth tokens received is based on the current reserves of native and foreign assets, which could be manipulated by an attacker through several means, such as performing trades that create imbalances in the reserves or repeatedly depositing and withdrawing assets. This could result in users receiving an incorrect amount of synthetic tokens, either overvalued or undervalued, compared to the actual market price.
A70_3	3	burnSynth	The `burnSynth` function allows users to burn their synthetic tokens and receive native assets in return. Similar to `mintSynth`, the amount of native assets received is based on the current reserves of native and foreign assets. If the reserves are manipulated, users may receive an incorrect amount of native assets, either more or less than the actual market price.
A70_3	4	mintFungible	The `mintFungible` function allows users to deposit native and foreign assets to receive liquidity tokens. The amount of liquidity tokens received is based on the current reserves of native and foreign assets, which could be manipulated by an attacker through similar means as mentioned before, leading to users receiving an incorrect amount of liquidity tokens, either overvalued or undervalued, compared to the actual market price.
A70_3	5	burnFungible	The `burnFungible` function allows users to burn their liquidity tokens and receive native and foreign assets in return. Similar to `mintFungible`, the amount of native and foreign assets received is based on the current reserves of native and foreign assets. If the reserves are manipulated, users may receive an incorrect amount of native and foreign assets, either more or less than the actual market price.
A70_3	null
A70_3	1	mint	The mint function calculates the amount of USDV tokens to be minted based on the current VADER token price fetched from the Liquidity Based TWAP (LBT) pricing mechanism using the `lbt.getVaderPrice()` function. If an attacker can manipulate the price of VADER tokens in the LBT, they can potentially mint more USDV tokens than they should.
A70_3	2	burn	The burn function calculates the amount of VADER tokens to be minted based on the current USDV token price fetched from the Liquidity Based TWAP (LBT) pricing mechanism using the `lbt.getUSDVPrice()` function. If an attacker can manipulate the price of USDV tokens in the LBT, they can potentially receive more VADER tokens than they should when burning USDV tokens.
A67_3	1	investedAssets	The `investedAssets()` function calculates the total amount of underlying assets in the contract by first fetching the latest exchange rate from the `exchangeRateFeeder` contract and then using the Curve pool's `get_dy_underlying()` function to convert UST assets back to the underlying currency. The potential for price manipulation exists if the `exchangeRateFeeder` contract or the Curve pool can be manipulated by an attacker to provide incorrect or skewed exchange rates. This could lead to inaccurate calculations of the total underlying assets in the strategy, potentially affecting the decisions made by the smart contract or its users.
A70_2	1	cumulativePrices	In the cumulativePrices function, external data is fetched from the pairInfo mapping, which stores reserve data for each foreignAsset. The function calculates the price0CumulativeLast and price1CumulativeLast based on the reserve data and the block timestamp. An attacker could potentially manipulate the reserves in the pairInfo mapping through the mintSynth, burnSynth, mintFungible, and burnFungible functions, which could lead to incorrect price calculations. Furthermore, an attacker might also try to manipulate block.timestamp, but this would be much more difficult and likely less effective.
A70_2	2	mintSynth	The mintSynth function calculates the amount of synth to be minted based on the nativeDeposit, reserveNative, and reserveForeign. An attacker could manipulate the amount of synth minted by changing the reserves through other functions like mintFungible and burnFungible, thus indirectly affecting the price.
A70_2	3	burnSynth	Similar to mintSynth, the burnSynth function calculates the amount of native tokens to be returned based on the synthAmount, reserveNative, and reserveForeign. An attacker could manipulate the reserves through other functions like mintFungible and burnFungible, indirectly affecting the price.
A70_2	4	mintFungible	The mintFungible function calculates the liquidity provided based on the nativeDeposit, foreignDeposit, reserveNative, and reserveForeign. An attacker could potentially manipulate the reserves through other functions like mintSynth and burnSynth, indirectly affecting the price.
A70_2	5	burnFungible	The burnFungible function calculates the amount of native and foreign tokens returned based on the liquidity, reserveNative, and reserveForeign. An attacker could manipulate the reserves through other functions like mintSynth and burnSynth, indirectly affecting the price.
A70_2	null
A70_2	1	mint	The mint function calculates the number of USDV tokens to be minted based on the vAmount argument (amount of VADER tokens) multiplied by the VADER token price fetched from the lbt.getVaderPrice() function. If the price oracle is manipulated, an attacker could artificially inflate or deflate the VADER token price, causing the mint function to issue an incorrect amount of USDV tokens.
A70_2	2	burn	The burn function calculates the number of VADER tokens to be received based on the uAmount argument (amount of USDV tokens) multiplied by the USDV token price fetched from the lbt.getUSDVPrice() function. If the price oracle is manipulated, an attacker could artificially inflate or deflate the USDV token price, causing the burn function to return an incorrect amount of VADER tokens.
A67_2	1	investedAssets	In the `investedAssets` function, the price of aUstToken is fetched using the `exchangeRateFeeder.exchangeRateOf` function. If the external contract providing the exchange rate is manipulated, it can result in incorrect calculation of invested assets in the strategy. Also, the `curvePool.get_dy_underlying` function is used to calculate the underlying assets from UST, which is also dependent on external data provided by the Curve pool. If the Curve pool can be manipulated, this could lead to incorrect valuation of invested assets.
A78_1	1	purchasePyroFlan	The function `purchasePyroFlan` in the given smart contract is prone to price manipulation, particularly due to the way it calculates the price using the balance of the Flan and Stablecoin tokens in the liquidity pool. Since the contract relies on the token balances instead of a price oracle, the opportunity for price manipulation through flash loans exists. An attacker could use a flash loan to artificially inflate or deflate the price before calling this function, which could lead to incorrect price calculations and unfair token distribution. Additionally, the contract uses the `config.acceptableHighestPrice` variable to prevent price manipulation, but this approach relies on the community's ability to set an appropriate circuit breaker, and it only checks for price manipulation after the liquidity pairs have already been minted.
A78_1	1	setEYEBasedAssetStake	The function 'setEYEBasedAssetStake' allows users to stake assets, which increases their voting power in the DAO. The price of the asset is fetched using the balance of EYE tokens in the asset's contract. However, this approach might be susceptible to price manipulation, as an attacker can potentially manipulate the balance of EYE tokens in the asset's contract, which would directly affect the staking and voting process. This manipulation could lead to imbalanced voting power and decision-making within the DAO.
A78_1	2	burnAsset	The 'burnAsset' function allows users to burn assets in exchange for newly created FATE tokens. The amount of FATE tokens received depends on the amount of EYE tokens held by the asset. This approach is vulnerable to price manipulation, as an attacker could potentially manipulate the balance of EYE tokens in the asset's contract to increase the FATE tokens received when burning assets. This manipulation could lead to an artificial increase in the user's voting power in the DAO, potentially compromising the decision-making process.
A70_1	1	cumulativePrices	In the cumulativePrices function, prices are calculated based on the current reserves of native and foreign assets in the pool. An attacker could manipulate the reserves by executing a large trade, affecting the price ratio between the two assets. This could lead to inaccurate price data being returned by this function.
A70_1	2	mintSynth	The mintSynth function calculates the amount of Synth to be minted based on the deposited native asset and the current reserves. An attacker could manipulate the price by executing a large trade, impacting the reserves, and consequently, the amount of Synth minted. This could lead to unintended consequences for users of the Synth token.
A70_1	3	burnSynth	In the burnSynth function, the amount of native asset to be received when burning a Synth token is calculated based on the current reserves. Similar to the previous cases, an attacker could manipulate the price by executing a large trade, impacting the reserves, and consequently, the amount of native asset received. This could lead to unfair payouts for users burning their Synth tokens.
A70_1	4	mintFungible	The mintFungible function calculates the amount of liquidity to be minted based on the deposited native and foreign assets and the current reserves. An attacker could manipulate the price by executing a large trade, impacting the reserves, and consequently, the amount of liquidity minted. This could lead to unintended consequences for users providing liquidity to the pool.
A70_1	5	burnFungible	In the burnFungible function, the amounts of native and foreign assets to be received when burning liquidity tokens are calculated based on the current reserves. An attacker could manipulate the price by executing a large trade, impacting the reserves, and consequently, the amounts of native and foreign assets received. This could lead to unfair payouts for users burning their liquidity tokens.
A70_1	null
A70_1	1	mint	In the mint function, the price of VADER (vPrice) is fetched from the lbt contract using the getVaderPrice() function. If the price oracle in the lbt contract is manipulated, the number of USDV tokens minted could be inflated or deflated based on the manipulated VADER price.
A70_1	2	burn	In the burn function, the price of USDV (uPrice) is fetched from the lbt contract using the getUSDVPrice() function. If the price oracle in the lbt contract is manipulated, the number of VADER tokens received in return for burning USDV tokens could be inflated or deflated based on the manipulated USDV price.
A67_1	1	investedAssets	In the `investedAssets()` function, the `exchangeRateOf` function is called from the `exchangeRateFeeder` contract, which is an external contract that may be potentially manipulated by bad actors to influence the exchange rate. If the exchange rate is manipulated, it would affect the calculation of `ustAssets`, which in turn affects the calculation of the total amount of underlying assets.
A67_1	2	_swapUnderlyingToUst	In the `_swapUnderlyingToUst()` function, the `curvePool.exchange_underlying()` function is called to swap the underlying token to UST. As the Curve pool is an external contract, it could be potentially manipulated by bad actors, affecting the conversion rate of the underlying token to UST. This would have a direct impact on the funds that are deposited into EthAnchor.
A67_1	3	_swapUstToUnderlying	Similar to the `_swapUnderlyingToUst()` function, the `_swapUstToUnderlying()` function calls `curvePool.exchange_underlying()` to swap UST back to the underlying token. Again, as the Curve pool is an external contract, bad actors could manipulate the conversion rate. This would affect the amount of the underlying token the contract receives when swapping back from UST, which in turn influences the overall balance of the strategy.
A52_3	1	_addLiquidity	The _addLiquidity function calculates the amount of tokenA and tokenB to be added to the liquidity pool. Since the function does not use a price oracle to determine the relative value of tokenA and tokenB, it is susceptible to price manipulation attacks. An attacker can manipulate the prices of tokenA and tokenB externally, leading to incorrect valuations when adding liquidity.
A52_3	2	_swap	The _swap function is responsible for swapping tokens using the provided path. It determines the pool and the amounts to be swapped but does not use an oracle to fetch external price data. Instead, it relies on the pool's reserves to calculate the swap amount. Since the pool's reserves can be manipulated by external factors, the _swap function is vulnerable to price manipulation attacks.
A52_3	3	calculateInGivenOut	The calculateInGivenOut function calculates the input amount required for a specific output amount using the provided path. It does not use an oracle for fetching external price data and instead relies on the reserves of the pool. As mentioned earlier, the pool's reserves can be manipulated by external factors, leading to price manipulation in this function.
A52_3	4	calculateOutGivenIn	Similar to calculateInGivenOut, the calculateOutGivenIn function calculates the output amount given a specific input amount using the provided path. It relies on the reserves of the pool and does not use an oracle for fetching external price data. This makes it vulnerable to price manipulation attacks due to the potential manipulation of pool reserves.
A52_3	null
A52_3	1	mintSynth	The mintSynth function calculates the amount of synthetic assets to mint based on the native asset deposit and the current reserves. It uses the VaderMath.calculateSwap function for this calculation. However, there is no validation or control over the accuracy of the input data or external data sources, making the contract potentially susceptible to price oracle manipulation. An attacker could provide manipulated price data to exploit the contract and mint an incorrect amount of synthetic assets.
A52_3	2	burnSynth	Similar to the mintSynth function, the burnSynth function calculates the amount of native assets to redeem based on the synthetic asset amount and the current reserves using the VaderMath.calculateSwap function. The contract does not have any validation or control over the accuracy of the input data or external data sources, making it potentially susceptible to price oracle manipulation. An attacker could provide manipulated price data to exploit the contract and redeem an incorrect amount of native assets.
A52_3	1	_swap	The function _swap is prone to price manipulation as it does not have any checks for slippage tolerance. An attacker could manipulate the price of the tokens in the pool before the transaction is executed to get an unfair advantage or cause losses to the users. To mitigate this risk, it is recommended to add slippage tolerance checks in the _swap function.
A52_2	1	_swap	The _swap function allows swapping of assets within a single Vader pool pair or across two different Vader pairs. Price manipulation is possible if an attacker manages to manipulate the price of the native asset or foreign assets within the pool. Since the contract relies on the pool for calculating the price of tokens being swapped, a price oracle attack on the pool would have a direct impact on the VaderRouterV2 contract. This type of attack could lead to an incorrect token exchange rate and result in unintended gains or losses for users interacting with the contract.
A52_2	1	mintSynth	The mintSynth function mints synthetic assets based on the native asset amount deposited. The price for minting these synthetic assets is calculated using the current reserve values of native and foreign assets. However, there is no direct price oracle or external data fetched in this function. An attacker could manipulate the reserves or amounts deposited to influence the price of minted synthetic assets.
A52_2	2	burnSynth	The burnSynth function allows burning of synthetic assets, and the redeemed amount of native asset is calculated based on the current reserve values. Similar to the mintSynth function, there is no direct price oracle or external data fetched in this function. An attacker could manipulate the reserves or amounts burned to influence the price of the redeemed native asset.
A52_2	3	mintFungible	The mintFungible function mints liquidity in fungible tokens. The liquidity issued is calculated using the current reserve values of native and foreign assets. As with the previous functions, there is no direct price oracle or external data fetched in this function. An attacker could manipulate the reserves or amounts deposited to influence the liquidity minted.
A52_2	4	burnFungible	The burnFungible function allows burning of liquidity issued in fungible tokens, and the redeemed amounts of native and foreign assets are calculated based on the current reserve values. As with the previous functions, there is no direct price oracle or external data fetched in this function. An attacker could manipulate the reserves or amounts burned to influence the price of the redeemed assets.
A52_2	null
A52_2	1	_swap	In the _swap function, the contract fetches the pool reserves and calculates the amountOut using the reserve amounts. Since the reserve amounts are fetched from the external VaderPool contract, it is possible for an attacker to manipulate the prices in that external contract, thus affecting the prices and the output of the swap function.
A52_2	2	calculateInGivenOut	In the calculateInGivenOut function, the contract fetches the pool reserves and calculates the amountIn based on the given amountOut and the reserve amounts. Since the reserve amounts are fetched from the external VaderPool contract, it is possible for an attacker to manipulate the prices in that external contract, thus affecting the prices and the output of the calculateInGivenOut function.
A52_2	3	calculateOutGivenIn	In the calculateOutGivenIn function, the contract fetches the pool reserves and calculates the amountOut based on the given amountIn and the reserve amounts. Since the reserve amounts are fetched from the external VaderPool contract, it is possible for an attacker to manipulate the prices in that external contract, thus affecting the prices and the output of the calculateOutGivenIn function.
